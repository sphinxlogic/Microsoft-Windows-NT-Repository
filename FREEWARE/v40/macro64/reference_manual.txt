 






















                    MACRO-64_Assembler_for_OpenVMS_AXP_Systems__________
                    Reference Manual

                    Order Number: AA-PT9KA-TE


                    November 1992

                    This document describes the MACRO-64 assembly
                    language.







                    Revision/Update Information:  This is a new manual.

                    Software Version:             MACRO-64 Assembler for
                                                  OpenVMS AXP Systems
                                                  Version 1.0

                    Operating System and Version: OpenVMS AXP Version 1.0



                    Digital Equipment Corporation
                    Maynard, Massachusetts

 






              ________________________________________________________________
              November 1992

              The information in this document is subject to change
              without notice and should not be construed as a commitment
              by Digital Equipment Corporation. Digital Equipment
              Corporation assumes no responsibility for any errors that
              may appear in this document.

              The software described in this document is furnished under
              a license and may be used or copied only in accordance with
              the terms of such license.

              No responsibility is assumed for the use or reliability
              of software on equipment that is not supplied by Digital
              Equipment Corporation or its affiliated companies.

              © Digital Equipment Corporation 1992.

              All Rights Reserved.

              The postpaid Reader's Comments forms at the end of this
              document request your critical evaluation to assist in
              preparing future documentation.

              The following are trademarks of Digital Equipment
              Corporation: Alpha AXP, AXP, DEC, DEC 4000, DECchip,
              DECwindows, Digital, OpenVMS, OpenVMS AXP, VAX, VAX
              DOCUMENT, VMS, the AXP logo, and the DIGITAL logo.

              The following are third-party trademarks:

              Ada[R] is a registered trademark of the U.S. Government,
              Ada Joint Program Office.

              This document was prepared using VAX DOCUMENT, Version 2.1.

 














     _________________________________________________________________

                                                              Contents



     Preface...................................................     xi

     1  Introduction

         1.1  Language Features................................    1-1
         1.1.1  Alpha AXP Native Mode Instructions ............    1-1
         1.1.2  Direct Assignment Statements ..................    1-2
         1.1.3  Assembler Directives ..........................    1-2
         1.1.3.1   General Assembler Directives................    1-2
         1.1.3.2   Macro Directives............................    1-2
         1.2  Invoking MACRO-64 on OpenVMS Systems.............    1-3
         1.2.1  Command Line Qualifiers .......................    1-3

     2  Components of MACRO-64 Source Statements

         2.1  Source Statement Format..........................    2-1
         2.1.1  Label Field ...................................    2-3
         2.1.2  Operator Field ................................    2-4
         2.1.3  Operand Field .................................    2-4
         2.1.4  Comment Field .................................    2-5
         2.2  Character Set....................................    2-5
         2.3  Numbers..........................................    2-8
         2.3.1  Integers ......................................    2-9
         2.3.2  Floating-Point Numbers ........................    2-9
         2.4  Quoted Literals..................................   2-10
         2.5  Symbols..........................................   2-11
         2.5.1  Permanent Symbols .............................   2-11
         2.5.2  User-Defined Symbols and Macro Names ..........   2-12
         2.5.3  Determining Symbol Values .....................   2-13
         2.5.3.1   Using Symbols in the Operator Field.........   2-14
         2.5.3.2   Using Symbols in the Operand Field..........   2-14
         2.6  Temporary Labels Within Source Code..............   2-15
         2.7  Label Addresses .................................   2-17

                                                                   iii

 







           2.7.1   Label Addresses, Optimization, and Code
                   Alignment......................................   2-18
           2.7.2   Label Addresses and Automatic Data Alignment
                   ...............................................   2-19
           2.8  Terms and Expressions............................    2-22
           2.9  Unary Operators for Terms and Expressions........    2-25
           2.9.1   Radix Control Operators .......................   2-26
           2.9.2   Numeric Complement Operator ...................   2-27
           2.10 Binary Operators.................................    2-28
           2.10.1  Arithmetic Shift Operator .....................   2-29
           2.10.2  Logical AND Operator ..........................   2-29
           2.10.3  Logical Inclusive OR Operator .................   2-29
           2.10.4  Logical Exclusive OR Operator .................   2-29
           2.11 Direct Assignment Statements.....................    2-30
           2.12 Current Location Counter.........................    2-31

        3  MACRO-64 Lexical Operator

           3.1  Processing with Lexical Operators................     3-1
           3.2  Lexical Operator Syntax..........................     3-1
           3.3  Numeric Symbols and Lexical String Symbols.......     3-4
           3.4  Lexical Substitution Operator....................     3-4
           3.5  Lexical Escape Operator..........................     3-5
           3.6  Using Lexical Operators..........................     3-7
           3.7  Lexical Operators................................    3-11

                %EDIT............................................    3-12

                %ELEMENT.........................................    3-14

                %EXTRACT.........................................    3-15

                %INTEGER.........................................    3-16

                %LENGTH..........................................    3-17

                %LOCATE..........................................    3-18

                %REPEAT..........................................    3-19

                %STRING..........................................    3-20

                %TIME............................................    3-21

                %TYPE............................................    3-22

        iv

 







        4  Macro Arguments

           4.1  Using Macro Arguments............................     4-2
           4.2  Using Default Values.............................     4-3
           4.3  Using Keyword Arguments..........................     4-3
           4.4  Using String Arguments...........................     4-5
           4.5  Argument Concatenation...........................     4-9
           4.6  Passing Numeric Values of Symbols................     4-9
           4.7  Using Created Temporary Labels...................    4-10

        5  MACRO-64 Assembler Directives

           5.1  Program Sections (Psects)........................     5-1
           5.2  Automatic Data Alignment.........................     5-3
           5.3  Directives.......................................     5-4

                .ADDRESS.........................................     5-9

                .ALIGN...........................................    5-10

                .ASCIC...........................................    5-13

                .ASCID...........................................    5-14

                .ASCII...........................................    5-16

                .ASCIZ...........................................    5-17

                .BASE............................................    5-18

                .BEGIN_EXACT.....................................    5-22

                .BLKx............................................    5-24

                .BYTE............................................    5-27

                .CODE_ADDRESS....................................    5-28

                .D_FLOATING......................................    5-29

                .DISABLE.........................................    5-31

                .ELSE............................................    5-32

                .ENABLE..........................................    5-34

                .END.............................................    5-44

                .ENDC............................................    5-46

                .ENDM............................................    5-47

                .ENDR............................................    5-48

                .END_EXACT.......................................    5-49

                .ERROR...........................................    5-50

                .EVEN............................................    5-51

                .EXTERNAL........................................    5-52

                .F_FLOATING......................................    5-53

                .G_FLOATING......................................    5-55

                                                                        v

 







                .IDENT...........................................    5-56

                .IF..............................................    5-57

                .IF_x............................................    5-63

                .IIF.............................................    5-67

                .INCLUDE.........................................    5-69

                .INSTRUCTION.....................................    5-70

                .IRP.............................................    5-72

                .IRPC............................................    5-75

                .LIBRARY.........................................    5-78

                .LINKAGE_PAIR....................................    5-80

                .LIST............................................    5-82

                .LOCAL_CODE_ADDRESS..............................    5-83

                .LOCAL_LINKAGE_PAIR..............................    5-84

                .LOCAL_PROCEDURE_DESCRIPTOR......................    5-85

                .LONG............................................    5-87

                .MACRO...........................................    5-88

                .MCALL...........................................    5-92

                .MDELETE.........................................    5-93

                .MEXIT...........................................    5-94

                .NARG............................................    5-97

                .NCHR............................................    5-99

                .NLIST...........................................   5-101

                .NOSHOW..........................................   5-102

                .OCTA............................................   5-103

                .ODD.............................................   5-105

                .PACKED..........................................   5-106

                .PAGE............................................   5-107

                .PRINT...........................................   5-108

                .PROCEDURE_DESCRIPTOR............................   5-109

                .PSECT...........................................   5-111

                .QUAD............................................   5-118

                .REPEAT..........................................   5-119

                .RESTORE_PSECT...................................   5-122

                .SAVE_PSECT......................................   5-124

                .S_FLOATING......................................   5-125

                .SHOW............................................   5-126

                .SIGNED_BYTE.....................................   5-129

        vi

 







                .SIGNED_WORD.....................................   5-130

                .SUBTITLE........................................   5-131

                .T_FLOATING......................................   5-132

                .TITLE...........................................   5-133

                .WARN............................................   5-135

                .WEAK............................................   5-136

                .WORD............................................   5-138

        6  MACRO-64 Supplied Macros

           6.1  MACRO-64 Supplied Library........................     6-1
           6.2  Routines and Lexical Scope.......................     6-2
           6.2.1   Routines and Program Sections .................    6-2
           6.3  Using Macros to Control Program Sections.........     6-3
           6.3.1   Defining Program Sections .....................    6-3
           6.3.2   Using Macro Specific Symbols ..................    6-4
           6.3.3   Defining Procedure Type .......................    6-5
           6.3.4   Using Macros in Prologue Sections .............    6-5
           6.3.5   Using Macros in Epilogue Sections .............    6-6
           6.4  Programming Examples Using Supplied Macros.......     6-6
           6.5  Using the $CALL Macro............................     6-8
           6.5.1   Using $CALL in Source Code ....................    6-9
           6.6  Programming Considerations.......................    6-11
           6.6.1   Making Multiple Calls From the Same Routine ...   6-11
           6.6.2   Non-Standard Linkage ..........................   6-11
           6.6.3   Routine Restrictions ..........................   6-11
           6.7  Macro Descriptions...............................    6-12
           6.7.1   Syntax Rules ..................................   6-12

                $BEGIN_EPILOGUE..................................    6-13

                $CALL............................................    6-15

                $CODE_SECTION  ...................................   6-22

                $DATA_SECTION....................................    6-23

                $END_EPILOGUE....................................    6-24

                $END_PROLOGUE....................................    6-26

                $END_ROUTINE.....................................    6-27

                $LINKAGE_PAIR....................................    6-28

                $LINKAGE_SECTION.................................    6-30

                $OPDEF...........................................    6-31

                .PACKED..........................................    6-37

                $PROCEDURE_DESCRIPTOR............................    6-40

                                                                      vii

 







                $RETURN..........................................    6-41

                $ROUTINE.........................................    6-42

        A  MACRO-64 Alpha AXP Architecture Quick Reference

           A.1  Register Usage Conventions.......................     A-3
           A.2  Instruction Operand Notation.....................     A-4
           A.3  Instruction Qualifier Notation...................     A-5
           A.4  F-P Control Register (FPCR) Format...............     A-5
           A.5  Decodable Pseudo-Operations......................     A-7
           A.6  Common Architecture Opcodes in Numerical Order...     A-9
           A.7  OpenVMS PALcode Instruction Summary..............    A-16
           A.8  PALcode Opcodes in Numerical Order...............    A-20
           A.9  Common Architecture Instructions.................    A-23

        B  Programming with MACRO-64

           B.1  OpenVMS Calling Standard.........................     B-1
           B.2  Accessing Memory with Base Registers.............     B-2
           B.3  Data Structures..................................     B-6
           B.3.1   Procedure Descriptor ..........................    B-6
           B.3.2   Signature Block ...............................    B-7
           B.3.3   Linkage Pair ..................................    B-7
           B.4  Types of Routines................................     B-9
           B.4.1   Routine Capabilities ..........................   B-10
           B.4.2   Entry Prologue and Exit Epilogue Sequences ....   B-11
           B.5  Example Program..................................    B-12
           B.6  Establishing Self-Addressability.................    B-13
           B.7  Optimization and Automatic Alignment.............    B-15
           B.7.1   Automatic Data Alignment ......................   B-15
           B.7.1.1   Controlling Data Alignment..................    B-16
           B.7.1.2   Directives for Automatic Data Alignment.....    B-16
           B.7.2   Automatic Code Label Alignment ................   B-18
           B.7.3   Scheduling Optimization .......................   B-18
           B.7.4   Peephole Optimization .........................   B-18
           B.7.5   Using MACRO-64 for Performance ................   B-19
           B.7.6   Viewing Optimization Results ..................   B-20







        viii

 







        C  Using LSE with MACRO-64

           C.1  Invoking LSE.....................................     C-1
           C.2  Running Diagnostics..............................     C-1

        D  Differences from VAX MACRO

           D.1  Assembler Features in MACRO-64...................     D-1
           D.2  VAX MACRO Features Not Present in MACRO-64.......     D-6

        E  Error Messages

        Index


        Examples

           3-1     Lexical Processing Without the Escape
                   Operator.......................................    3-6

           3-2     Lexical Processing With Escape Operator .......    3-6

           3-3     Using Lexical Operators .......................    3-7

           3-4     Source Statements After Macro Expansion .......   3-10

           6-1     Program Using Supplied Macros .................    6-6

           6-2     Program Using $CALL ...........................   6-10

           B-1     Routine Without Linkage Pairs .................    B-8

           B-2     Routine With Linkage Pairs ....................    B-9

           B-3     Establishing a Base Address ...................   B-14

           B-4     Enabling and Disabling Data Alignment .........   B-16

        Figures

           A-1     Data Structures ...............................    A-1

           A-2     Instruction Formats ...........................    A-2


                                                                       ix

 







        Tables

           2-1     Using Tab Stops in Statement Fields ...........    2-2

           2-2     Special Characters Used in MACRO-64
                   Statements.....................................    2-7

           2-3     Summary of Unary Operators ....................   2-25

           2-4     Summary of Binary Operators ...................   2-28

           3-1     Summary of MACRO-64 Lexicals ..................   3-11

           3-2     %TYPE Attributes ..............................   3-22

           5-1     Summary of General Assembler Directives .......    5-4

           5-2     Summary of Macro Directives ...................    5-7

           5-3     .ENABLE and .DISABLE Symbolic Arguments .......   5-34

           5-4     Condition Tests for Conditional Assembly
                   Directives.....................................   5-58

           5-5     Program Section Attributes ....................  5-112

           5-6     Default Program Section Attributes ............  5-115

           5-7     .SHOW and .NOSHOW Symbolic Arguments ..........  5-126

           6-1     ARGS Arguments ................................   6-17

           A-1     Register Usage Conventions for OpenVMS AXP ....    A-3

           A-2     Instruction Operand Notation ..................    A-4

           A-3     Instruction Qualifier Notation ................    A-5

           A-4     F-P Control Register (FPCR) Format ............    A-5

           A-5     Decodable Pseudo-Operations ...................    A-7

           A-6     Common Architecture Opcodes in Numerical
                   Order..........................................    A-9

           A-7     OpenVMS Unprivileged PALcode Instructions .....   A-16

           A-8     OpenVMS Privileged PALcode Instructions .......   A-17

           A-9     PALcode Opcodes in Numerical Order ............   A-20

           A-10    Common Architecture Instructions ..............   A-23

           B-1     Frame Attributes ..............................   B-11

           B-2     Directives Using Automatic Alignment ..........   B-16

        x

 












        _________________________________________________________________

                                                                  Preface



              This manual describes the MACRO-64 assembly language.

        Intended Audience

              This manual is intended for all programmers writing MACRO-
              64 programs. Before reading this manual, you should be
              familiar with assembly language programming, the Alpha AXP
              architecture and instruction set, and the operating system
              in use on your AXP system.

        Document Structure

              This manual contains the following chapters and appendices:

              o  Chapter 1 introduces the features of the MACRO-64
                 language.

              o  Chapter 2 describes the format of the MACRO-64 source
                 statements.

              o  Chapter 3 describes the MACRO-64 lexical operators. It
                 also discusses differences and similarities between the
                 VAX MACRO string operators and those of MACRO-64.

              o  Chapter 4 describes the arguments used with macros.

              o  Chapter 5 describes the MACRO-64 general assembler
                 directives and the directives used in defining and
                 expanding macros.

              o  Chapter 6 describes macros provided with the (MACRO-64)
                 Assembler.

              o  Appendix A provides a quick reference to the Alpha AXP
                 architecture as it relates to the MACRO-64 programming
                 language. For more information, refer to the Alpha
                 Architecture Handbook.

                                                                       xi

 







              o  Appendix B provides information on how to program more
                 effectively using the MACRO-64 assembler.

              o  Appendix C explains how to invoke the LSE editor with
                 the MACRO-64 language.

              o  Appendix D describes the differences between VAX MACRO
                 and MACRO-64 features.

              o  Appendix E describes the error messages produced by the
                 MACRO-64 assembler.

        Related Manuals

              For more information on MACRO-64, see the following manuals
              in this documentation set:

              o  MACRO-64 Assembler for OpenVMS AXP Systems Installation
                 Guide

              o  MACRO-64 Assembler for OpenVMS AXP Systems Release Notes

              For more information on the Alpha AXP architecture, see the
              following:

              o  Alpha Architecture Reference Manual

              o  Alpha Architecture Handbook

              o  Alpha AXP Achitecture Quick Reference Guide

              o  OpenVMS Calling Standard

        Conventions

              In this manual, every use of Alpha VMS means the OpenVMS
              AXP operating system, every use of VAX VMS means the
              OpenVMS VAX operating system, and every use of VMS means
              both the OpenVMS AXP operating system and the OpenVMS VAX
              operating system.

              The following conventions are used in this manual:

              Ctrl/x           A sequence such as Ctrl/x indicates that
                               you must hold down the key labeled Ctrl
                               while you press another key or a pointing
                               device button.

        xii

 








              PF1 x            A sequence such as PF1 x indicates that
                               you must first press and release the
                               key labeled PF1, then press and release
                               another key or a pointing device button.

              <Return>         In examples, a key name enclosed in a
                               box indicates that you press a key on
                               the keyboard. (In text, a key name is not
                               enclosed in a box.)

               . . .           A horizontal ellipsis in examples
                               indicates one of the following
                               possibilities:

                               o  Additional optional arguments in a
                                  statement have been omitted.

                               o  The preceding item or items can be
                                  repeated one or more times.

                               o  Additional parameters, values, or other
                                  information can be entered.

                               A vertical ellipsis indicates the omission
                  .            of items from a code example or command
                  .            format; the items are omitted because
                  .            they are not important to the topic being
                               discussed.

              ( )              In format descriptions, parentheses
                               indicate that, if you choose more than
                               one option, you must enclose the choices
                               in parentheses.

              [ ]              In format descriptions, brackets indicate
                               optional elements. You can choose one,
                               none, or all of the options. (Brackets
                               are not optional, however, in the
                               syntax of a directory name in a VMS
                               file specification, or in the syntax of
                               a substring specification in an assignment
                               statement.)

              { }              In format descriptions, braces surround
                               a required choice of options; you must
                               choose one of the options listed.

                                                                     xiii

 








              boldface text    Boldface text represents the introduction
                               of a new term or the name of an argument,
                               an attribute, or a reason.

                               Boldface text is also used to show user
                               input in online versions of the manual.

              italic text      Italic text emphasizes important
                               information, indicates variables, and
                               indicates complete titles of manuals.
                               Italic text also represents information
                               that can vary in system messages (for
                               example, Internal error number), command
                               lines (for example, /PRODUCER=name), and
                               command parameters in text.

              UPPERCASE TEXT   Uppercase text indicates a command, the
                               name of a routine, the name of a file, or
                               the abbreviation for a system privilege.

              -                A hyphen in code examples indicates that
                               additional arguments to the request are
                               provided on the line that follows.

              numbers          All numbers in text are assumed to
                               be decimal, unless otherwise noted.
                               Nondecimal radixes-binary, octal, or
                               hexadecimal-are explicitly indicated.

              mouse            The term mouse refers to any pointing
                               device, such as a mouse, a puck, or a
                               stylus.

              MB1, MB2, MB3    MB1 indicates the left mouse button, MB2
                               indicates the middle mouse button, and
                               MB3 indicates the right mouse button. (The
                               buttons can be redefined by the user.)

              PB1, PB2, PB3,   PB1, PB2, PB3, and PB4 indicate buttons on
              PB4              the puck.

              SB, SB           SB and SB indicate buttons on the stylus.

              VMS, OpenVMS,    The terms VMS, OpenVMS, and OpenVMS AXP
              OpenVMS AXP      refer to the same operating system.

              MACRO-64         MACRO-64 refers to MACRO-64 Assembler for
                               OpenVMS AXP Systems.

        xiv

 










                                                                        1
        _________________________________________________________________

                                                             Introduction


              MACRO-64 Assembler for OpenVMS AXP Systems is an assembly
              language for programming Alpha AXP computers. Source
              programs written in MACRO-64 are translated into object (or
              binary) code by the MACRO-64 assembler, which produces an
              object module and, optionally, a listing file. The features
              of the language are introduced in this chapter, as well as
              instructions to invoke the assembler.

        1.1 Language Features

              MACRO-64 source programs consist of a sequence of source
              statements. These source statements may be any of the
              following:

              o  Alpha AXP native-mode instructions

              o  Direct assignment statements

              o  Assembler directives

        1.1.1 Alpha AXP Native Mode Instructions

              Instructions manipulate data. They perform such functions
              as addition, data conversion, and transfer of control.
              Instructions are usually followed in the source statement
              by operands, which can be any kind of data needed for the
              operation of the instruction. For a brief description
              of the Alpha instruction set, see Appendix A. For a more
              detailed description of the Alpha native mode instruction
              set, see the Alpha Architecture Reference Manual or the
              Alpha Architecture Handbook.





                                                                      1-1

 



        Introduction
        1.1 Language Features


        1.1.2 Direct Assignment Statements

              Direct assignment statements equate symbols to values.
              For more information on direct assignment statements, see
              Section 2.11.

        1.1.3 Assembler Directives

              Directives guide the assembly process and provide tools for
              using the instructions. For more information on assembler
              directives, see Chapter 5.

              There are two classes of assembler directives: general
              assembler directives and macro directives.

        1.1.3.1 General Assembler Directives

              General assembler directives can be used to perform the
              following operations:

              o  Store data or reserve memory for data storage

              o  Control the alignment of parts of the program in memory

              o  Specify the methods of accessing the sections of memory
                 in which the program will be stored

              o  Specify a procedure in the program

              o  Specify the way in which symbols will be referenced

              o  Specify that a part of the program is to be assembled
                 only under certain conditions

              o  Display informational and diagnostic messages

              o  Control the assembler options that are used to interpret
                 the source program

        1.1.3.2 Macro Directives

              Macro directives are used to define macros and repeat
              blocks. They allow you to repeat identical or similar
              sequences of source statements throughout a program without
              rewriting those sequences. Use of macros and repeat blocks
              helps minimize programmer errors and speeds the debugging
              process.

        1-2

 



                                                             Introduction
                                 1.2 Invoking MACRO-64 on OpenVMS Systems


        1.2 Invoking MACRO-64 on OpenVMS Systems

              To invoke MACRO-64, use the following MACRO command with
              the /ALPHA_AXP command line qualifier:

              MACRO/ALPHA_AXP  file-spec[, . . . ]

              Note that you must specify the /ALPHA_AXP command line
              qualifier before any other command line parameters,
              qualifiers, or file specifications.

              file-spec[, . . . ]

              If you do not specify a file type for an input file, the
              assembler uses the default file type of .M64.

              You can specify one or more source files to be assembled.
              To assemble files individually, separate the file
              specifications with commas. To concatenate and assemble
              the files as a single input file, separate the file
              specifications with plus signs (+).

              Command line qualifiers control special assembler options.
              Assembler options can apply to the entire MACRO/ALPHA_AXP
              command line, or to the individual file being assembled.
              When the qualifier follows the MACRO/ALPHA_AXP command,
              it applies to all files listed. For more information on
              command line qualifiers, see Section 1.2.1.

        1.2.1 Command Line Qualifiers

              This section describes the command qualifiers used with the
              MACRO/ALPHA_AXP command.

              /[NO]ALIGNMENT=option

              Controls the alignment of code and data. Valid options are:

              ___________________________________________________________
              Option____Function_________________________________________

              code      Alignment of certain branch target labels.

              data______Natural_alignment_of_data_items._________________

              If you omit the qualifier from the command line, the
              default option is /NOALIGNMENT=(code, data). If more than

                                                                      1-3

 



        Introduction
        1.2 Invoking MACRO-64 on OpenVMS Systems


              one option is specified, the options must be enclosed in
              parentheses and separated by a comma.

              /[NO]DEBUG[=(options)]

              Specifies DEBUG support. Valid options are:

              ___________________________________________________________
              Option____Function_________________________________________

              symbol    Generates debug symbol information.

              traceback Generates traceback information.

              all       Generates all above debug information.

              none______Generates_no_debug_information.__________________

              The default qualifier is /NODEBUG. The default when /DEBUG
              is specified with no keywords is /DEBUG=all.

              /[NO]DIAGNOSTIC[=file-spec]

              Controls whether diagnostics are created and stored in
              the specified optional file. If a file specification is
              not supplied, the assembler creates a diagnostic file
              using the same name as the source file. For example,
              if you use a source file named XXX.M64, the assembler
              creates a diagnostic file named XXX.DIA. You can use the
              the diagnostic file with other Digital layered products
              including, but not limited to, the Language-Sensitive
              Editor (LSE).

              The default qualifier is /NODIAGNOSTIC.

              /ENVIRONMENT=[NO]FLOAT

              Controls whether the assembler generates floating-point
              instructions when optimizing code and performing code-label
              alignment.

              Currently, the only floating-point instruction generated by
              the assembler during optimization and alignment processing
              is FNOP, the floating-point no-operation instruction.
              If you specify /ENVIRONMENT=NOFLOAT, the assembler does
              not generate any floating-point instructions as part of
              optimization and alignment processing. Floating-point

        1-4

 



                                                             Introduction
                                 1.2 Invoking MACRO-64 on OpenVMS Systems


              instructions that you specify in your source program are
              unaffected.

              /LIBRARY

              Searches macro libraries in the following order:

              1. The library designated by the /LIBRARY qualifier.

              2. The .LIBRARY directives.

              3. The MACRO64.MLB library. The assembler searches for the
                 MACRO64.MLB macro library in the following locations:
                 MACRO64$LIBRARY, ALPHA$LIBRARY, and finally SYS$LIBRARY.

              4. The STARLET.MLB library. The assembler searches for
                 the the STARLET.MLB macro library in the following
                 locations: MACRO64$LIBRARY, ALPHA$LIBRARY, and finally
                 SYS$LIBRARY.

              In addition, you can place the macro library definitions
              in the listing file by using the command line qualifier
              /SHOW=LIBRARY.

              /[NO]LIST[=file-spec]

              Controls whether a listing is created and optionally
              provides an output file specification for the listing file.
              Do not use wildcard characters in this file specification.

              If you issue the MACRO/ALPHA_AXP command interactively,
              /NOLIST is the default. The assembler sends output to the
              current output device rather than to a listing file. If you
              execute the MACRO/ALPHA_AXP command in a batch job, /LIST
              is the default.

              If you do not specify a file specification, the assembler
              creates a listing file using the same name as the source
              file. For example, if you use a source file named XXX.M64,
              the assembler creates a listing file named XXX.LIS.





                                                                      1-5

 



        Introduction
        1.2 Invoking MACRO-64 on OpenVMS Systems


              /[NO]MACHINE_CODE

              Produces a binary machine code listing after the source
              text if a listing file is requested. The default is
              /NOMACHINE_CODE.

              /NAMES=case_option


              Specifies the alphabetic casing of identifiers in source
              code statements. Valid options are:

              ___________________________________________________________
              Option____Function_________________________________________

              upper_    Converts all identifiers to upper alphabetic
              case      case.

              lower_    Converts all identifiers to lower alphabetic
              case      case.

              as_is     Causes all identifiers to remain in the case used
              __________in_source_statements.____________________________

              If you use the /NAMES option in a command line, you must
              supply a case_option. If you omit the qualifier from the
              command line, the default option is /NAMES=upper_case.

              /[NO]OBJECT[=file-spec]

              Controls whether an object file is created and optionally
              provides a file specification. Do not use wildcard
              characters in this file specification.

              If you do not specify a file specification, the assembler
              creates an object file using the same name as the source
              file. For example, if you use a source file named XXX.M64,
              the assembler creates an object file named XXX.OBJ.

              The default qualifier is /OBJECT.

              /[NO]OPTIMIZE[=(option-list)]



        1-6

 



                                                             Introduction
                                 1.2 Invoking MACRO-64 on OpenVMS Systems


              Specifies optional assembler optimizations. Valid items in
              the option-list are:

              ___________________________________________________________
              Option____Function_________________________________________

              schedule  Specifies instruction scheduling.

              peephole__Specifies_peepholing.____________________________

              Specifying /OPTIMIZE with no options is the same as
              specifying /OPTIMIZE=(peephole,schedule).

              The default qualifier is /NOOPTIMIZE. See Section B.7 for
              information on optimizations.

              /[NO]SHOW=(item,...)

              Modifies the output listing file. This qualifier is
              meaningful only when /LIST is specified. Valid items are:

              ___________________________________________________________
              Option___________Function__________________________________

              expansions       Shows macro expansions.

              conditionals     Shows sections of code conditionally
                               skipped.

              include          Shows all .INCLUDE files.

              library__________Shows_macro_library_modules.______________

              The default item is /SHOW=conditionals.

              /[NO]WARNINGS=(option-list)

              Controls the severity level of messages and diagnostics.
              Valid options are:

              ___________________________________________________________
              Option______Function_______________________________________

              warnings    Display/suppress warnings.

              informationaDisplay/suppress informationals.

              all         Display/suppress warnings and informational.

              none________Display/suppress_nothing.______________________

                                                                      1-7

 



        Introduction
        1.2 Invoking MACRO-64 on OpenVMS Systems


              The default
              qualifier is /WARNINGS=(warnings,informationals). If more
              than one option is specified, options must be enclosed in
              parentheses separated by a comma.









































        1-8

 










                                                                        2
        _________________________________________________________________

                                 Components of MACRO-64 Source Statements


              A source program consists of a sequence of source
              statements that the assembler interprets and processes, one
              at a time, generating object code or performing a specific
              assembly-time process. A source statement can occupy one
              source line or can extend onto several source lines.

              This chapter describes the format of the source statement
              and the following components:

              o  Character set

              o  Numbers

              o  Symbols

              o  Local labels

              o  Terms and expressions

              o  Unary and binary operators

              o  Direct assignment statements

              o  Current location counter

        2.1 Source Statement Format

              MACRO-64 source statements can have a maximum of four
              fields, as follows:

              o  Label field-Symbolically defines a location in a
                 program.

              o  Operator field-Specifies the action to be performed
                 by the statement; can be an instruction, an assembler
                 directive, or a macro call.

              o  Operand field-Contains the instruction operands or the
                 assembler directive arguments or the macro arguments.

                                                                      2-1

 



        Components of MACRO-64 Source Statements
        2.1 Source Statement Format


              o  Comment field-Contains a comment that explains the
                 meaning of the statement; does not affect program
                 execution.

              Although statement fields can be separated by either a
              space or a tab stop, Digital recommends that you format
              statements with the Tab key to insure consistency and
              clarity. See Table 2-1.

              Table_2-1_Using_Tab_Stops_in_Statement_Fields______________

                         Column in
                         Which
                         Field
              Field______Begins_____Tab_Stops_to_Reach_Column____________

              Label      1          0

              Operator   9          1

              Operand    17         2

              Comment____41_________5____________________________________

              The following example shows a typical source statement.

              EXP:    .BLKL   50                     ; Table stores expected values

              Rules for Coding Source Statements

              The following rules apply for coding source statements:

              o  You can continue a single statement on several lines
                 by using a hyphen (-) as the last nonblank character
                 before the comment field, or at the end of line (when
                 there is no comment).

              o  In most cases, a statement can be continued at any
                 point. If a symbol name is continued and the first
                 character on the second line is a tab or a blank,
                 the symbol name is terminated at that character. For
                 information on using symbols, see Section 2.5.

              o  Blank lines are legal, but they have no significance
                 in the source program except that they terminate a
                 continued line.

              The following sections describe each of the statement
              fields in detail.

        2-2

 



                                 Components of MACRO-64 Source Statements
                                              2.1 Source Statement Format


        2.1.1 Label Field

              A label is a user-defined symbol that identifies a location
              in the program. The symbol is assigned a value equal to
              the location counter where the label occurs. The following
              rules apply when coding source statements with labels:

              o  If a statement contains a label, the label must be in
                 the first field on the line.

              o  The user-defined symbol name can be up to 31 characters
                 long and can contain any alphanumeric character, as well
                 as the underscore (_), dollar sign ($),  and period (.)
                 characters.

              o  If a label extends past column 7, Digital recommends
                 you place it on a line by itself so that the following
                 operator field can start in column 9 of the next line.

              o  A label is terminated by a colon (:) or a double colon
                 (::).

              In the following source statement, EXP: is the label field.

              EXP:    .BLKL   50                     ; Table stores expected values

              See Section 2.5.2 for a description of the rules for
              forming user-defined symbol names.

              There are three types of labels:

              o  Global labels-Can be referenced by other object modules
                 and are defined using a double colon (::).

              o  Local labels-Can be referenced only within the current
                 module and are defined using a single colon (:).

              o  Temporary labels-Can be referenced only within the
                 bounds of either two local labels, two global labels,
                 two psects, or within the bounds of a temporary
                 label scope, as defined by .ENABLE LOCAL_BLOCK and
                 .DISABLE LOCAL_BLOCK. Temporary labels are defined
                 using one to five digits, followed by a dollar sign
                 and a single colon ($:). See Section 2.6 for further
                 information.

                                                                      2-3

 



        Components of MACRO-64 Source Statements
        2.1 Source Statement Format


              EXP:    .BLKL   50                     ; EXP is a local label used to
                                                     ; identify a 50-word block of storage
              DATA::  .BLKW   25                     ; DATA is a global label used to
                                                     ; identify a 25-word block of storage
              10$:    .BLKW    5                     ; 10$ is a temporary label used to
                                                     ; identify a five word block of
                                                     ; storage.

        2.1.2 Operator Field

              The operator field specifies the action to be performed by
              the statement. This field can contain an instruction, an
              assembler directive, or a macro call. If the operator is:

              o  An instruction, MACRO-64 generates the binary code for
                 that instruction in the object module. The instructions
                 are listed in Appendix A.

              o  A directive, MACRO-64 performs certain control actions
                 or processing operations during source program assembly.
                 The assembler directives are described in Chapter 5.

              o  A macro call, MACRO-64 expands the macro. Macro calls
                 are described in Chapter 4 and in Chapter 5 (.MACRO
                 directive). Macros supplied with MACRO-64 are described
                 in Chapter 6.

              Use either a space or a tab stop to terminate the operator
              field; however, Digital recommends you use the tab stop to
              terminate the operator field.

              In the following source statement, .BLKL is the operator
              field.

              EXP:    .BLKL   50                     ; Table stores expected values

        2.1.3 Operand Field

              The operand field can contain operands for instructions or
              arguments for either assembler directives or macro calls.

              Operands for instructions identify the memory locations or
              the registers that are used by the machine operation. The
              operand field for a specific instruction must contain the
              number and type of operands required by that instruction.

              Arguments for a directive must meet the format requirements
              of that directive. Chapter 5 describes the directives and
              the format of their arguments.

        2-4

 



                                 Components of MACRO-64 Source Statements
                                              2.1 Source Statement Format


              Operands for a macro must meet the requirements specified
              in the macro definition. See the description of the .MACRO
              directive in Chapter 5.

              Use a comma (,) to separate operands for instructions
              and directives. (See Section 2.8 for a discussion of
              expressions.)

              The semicolon that starts the comment field terminates the
              operand field. If a line does not have a comment field, the
              operand field is terminated by the end of the line.

              In the following source statement example, 50 is the
              operand field supplied to the operand field, .BLKL.

              EXP:    .BLKL   50                     ; Table stores expected values

        2.1.4 Comment Field

              The comment field contains text that explains the function
              of the statement. You can use comments to describe
              algorithms, reasons for selecting particular methods,
              and parameters passed to routines. Comments do not affect
              assembly processing or program execution.

              The comment field must be preceded by a semicolon (;) and
              can contain any printable ASCII character. It is terminated
              by the end of the line.

              A comment can appear on a line by itself. If a comment does
              not fit on one line, it can be continued on the next, but
              the continuation must be preceded by another semicolon.

              In the following source statement example, "Table stores
              expected values", is the comment field. Note that the
              comment field begins with a semicolon.

              EXP:    .BLKL   50                     ; Table stores expected values

        2.2 Character Set

              When coding source statements, you need to be aware of
              what characters are acceptable to the assembler, and how
              the assembler interprets them. The following numbers and
              characters are accepted by the assembler.

              o  The letters of the alphabet, A to Z, uppercase and
                 lowercase. By default, the assembler converts all

                                                                      2-5

 



        Components of MACRO-64 Source Statements
        2.2 Character Set


                 lowercase letters to uppercase. This means it considers
                 lowercase letters equivalent to uppercase letters.

                 The assembler can operate in a case-sensitive mode.
                 In case sensitive mode, the assembler does not convert
                 lowercase letters to uppercase letters. On OpenVMS and
                 OpenVMS AXP systems, case sensitive mode can be selected
                 from the command line with the /NAMES=as_is qualifier.

              o  The digits 0 to 9.

              o  The special characters listed in Table 2-2.

































        2-6

 



                                 Components of MACRO-64 Source Statements
                                                        2.2 Character Set


              Table_2-2_Special_Characters_Used_in_MACRO-64_Statements___

                         Character
              ___CharacteName________Function____________________________

                 _       Underscore  Character in symbol names.

                 $       Dollar      Character in symbol names.
                         sign

                 .       Period      Character in symbol names, current
                                     location counter, and decimal point.

                 :       Colon       Local label terminator.

                 ::      Double      Global label terminator.
                         colon

                 =       Equal sign  Local direct assignment operator and
                                     macro keyword argument terminator.

                 ==      Double      Global direct assignment operator.
                         equal sign

                         Tab         Field terminator.

                         Space       Field terminator.

                 #       Number      Literal value indicator.
                         sign

                 @       At sign     Arithmetic shift operator.

                 ,       Comma       Field, operand, and item separator.

                 ;       Semicolon   Comment field indicator.

                 +       Plus sign   Unary plus operator, and arithmetic
                                     addition operator.

                 -       Minus sign  Unary minus operator, arithmetic
                         or          subtraction operator, and line
                         hyphen      continuation indicator.

                 *       Asterisk    Arithmetic multiplication operator.

                 /       Slash       Arithmetic division operator.

                 &       Ampersand   Logical AND operator.

                 !       Exclamation Logical inclusive OR operator point.
                         point

                                                 (continued on next page)

                                                                      2-7

 



        Components of MACRO-64 Source Statements
        2.2 Character Set


              Table 2-2 (Cont.) Special Characters Used in MACRO-64
              __________________Statements_______________________________

                         Character
              ___CharacteName________Function____________________________

                 \       Backslash   Logical exclusive OR and numeric
                                     conversion indicator in macro
                                     arguments.

                 ^       Circumflex  Unary operators and macro argument
                                     delimiter.

                 ( )     Parentheses Displacement and register field
                                     delimiter in an instruction operand.
                                     Argument delimiter to a lexical
                                     operator.

                 <>      Angle       Argument or expression grouping
                         brackets    delimiters.

                 ?       Question    Created local label indicator in
                         mark        macro arguments.

                 '       Apostrophe  Macro argument concatenation
                                     indicator.

                 "       Double      Quoted literal delimiter.
                         quote

                 %       Percent     Delimits the beginning of a lexical
                         sign        operator.

                 (space) Space or    Separates source statement fields.
                         tab         Spaces within expressions are
                 (tab)               otherwise ignored.

                 ,       Comma       Separates symbolic arguments
                                     within the operand field. Multiple
                                     expressions in the operand field
              _______________________must_be_separated_by_commas.________

        2.3 Numbers

              Numbers can be integers or floating-point numbers. The
              following sections describe these types of numbers.

        2-8

 



                                 Components of MACRO-64 Source Statements
                                                              2.3 Numbers


        2.3.1 Integers

              Integers can be used in any expression, including
              expressions in operands and in direct assignment
              statements. For information on expressions, see
              Section 2.8.

              Format

              snn

              s
              An optional sign: plus sign (+) for positive numbers (the
              default), or minus sign (-) for negative numbers.

              nn
              A string of numeric characters that is legal for the
              specified radix.

              MACRO-64 interprets all integers in the source program as
              decimal unless the number is preceded by a radix control
              operator. For more information on radix control operators,
              see Section 2.9.1.

              Integers must be in the range of -263 to +263-1  for signed

              data or in the range of 0 to 264-1  for unsigned data.

              Negative numbers must be preceded by a minus sign; MACRO-
              64 translates such numbers into two's complement form. In
              positive numbers, the plus sign is optional.

        2.3.2 Floating-Point Numbers

              A floating-point number can be used in the .DOUBLE, .FLOAT,
              .F_FLOATING, .D_FLOATING, .G_FLOATING, .S_FLOATING, and
              .T_FLOATING directives. For more information on directives,
              see Chapter 5. A floating-point number cannot be used in
              an expression or with a unary or binary operator except the
              unary plus and unary minus. For information on unary and
              binary operators, Section 2.9 and Section 2.10.

              A floating-point number can be specified with or without an
              exponent.

                                                                      2-9

 



        Components of MACRO-64 Source Statements
        2.3 Numbers


              Format

              Floating-point number without exponent:

              snn
              snn.nn
              snn.

              Floating-point number with exponent:

              snnEsnn
              snn.nnEsnn
              snn.Esnn

              s
              An optional sign.

              nn
              A string of decimal digits in the range of 0 to 9.

              The decimal point can appear anywhere to the right of the
              first digit. Note that a floating-point number cannot start
              with a decimal point because MACRO-64 will treat the number
              as a user-defined symbol. For information on user-defined
              symbols, see Section 2.5.2.

        2.4 Quoted Literals

              A quoted literal is a string of characters enclosed in
              double quotes (" "). Use the following guidelines when
              specifying characters in a quoted literal:

              o  Any character except null, carriage return, and form
                 feed can appear within the string.

              o  To include a double quote or backslash in a string, you
                 must precede it with a backslash (\).

              o  To specify an arbitrary character, you can specify
                 "\xhh", where each h represents a single hexadecimal
                 digit. For example, the string:

                 "AB\\CD\"EF\x47"

                 contains the following characters:

                 AB\CD"EFG

              Also note that the assembler does not convert the case of
              alphabetic characters within a quoted literal.

        2-10

 



                                 Components of MACRO-64 Source Statements
                                                      2.4 Quoted Literals


              Quoted literals can be continued over several lines. Use
              the hyphen (-) as the line continuation character and
              delimit the string with double quotes. For example:

              .ASCII "Strings are delimited with double-quotes."
              .ASCII "The backslash is an escape character."
              .ASCII "Use two backslashes (\\) to represent the back-slash itself."
              .ASCII "Hexidecimal escape sequences use lower or upper X: \x00 or \X00"
              .ASCII "Precede a double quote with a backslash (\") to embed the quote."
              .ASCII "Strings can be continued onto multiple lines -
              just as any other line."

        2.5 Symbols

              You use symbols in MACRO-64 source statements to represent
              an instruction, directive, register name, or value. Three
              types of symbols can be used in MACRO-64 source programs:
              permanent symbols, user-defined symbols, and macro names.

        2.5.1 Permanent Symbols

              Permanent symbols consist of instruction mnemonics, MACRO-
              64 directives, and register names. You do not need to
              define directives before you use them in the operator field
              of an MACRO-64 source statement. Also, you do not need
              to define instruction mnemonics and register names before
              using them in the instruction statements.

              You can express the 32 general registers and the 32
              floating point registers of the Alpha AXP processor in a
              source program as follows:

              ___________________________________________________________
              Register
              Name____Description________________________________________

              R0      General register 0.

              R1      General register 1.

              .       .

              .       .

              .       .

                                                                     2-11

 



        Components of MACRO-64 Source Statements
        2.5 Symbols

              ___________________________________________________________
              Register
              Name____Description________________________________________

              R29 or  General register 29 or frame pointer. If you use
              FP      R29 as a framer pointer, Digital recommends you use
                      the name FP. If you use R29 as a general register,
                      Digital recommends you use the name R29.

              R30 or  General register 30 or stack pointer. If you use
              SP      R30 as a stack pointer, the name SP is recommended;
                      if you use R30 as a general register, the name R30
                      is recommended.

              R31     General register 31.

              F0      Floating point register 0.

              .       .

              .       .

              .       .

              F31_____Floating_point_register_31.________________________

              Registers are reserved names which cannot be used or
              redefined in any context.

        2.5.2 User-Defined Symbols and Macro Names

              You can use symbols to define labels, or you can equate
              them to a specific value by a direct assignment statement.
              (See Section 2.11.) These symbols can also be used in
              expressions. For more information on expressions, see
              Section 2.8.

              Use the following rules to create user-defined symbols:

              o  Use alphanumeric characters, underscores (_), dollar
                 signs ($), and periods (.).  Any other character
                 terminates the symbol.

              o  The first character of a symbol cannot be a number.

              o  The symbol must be no more than 31 characters long and
                 must be unique.

              o  The symbol must not be a register name.

        2-12

 



                                 Components of MACRO-64 Source Statements
                                                              2.5 Symbols


              o  The symbol cannot be one of the following conditional or
                 macro directives:

                 .ELSE            .ENDC            .ENDM

                 .ENDR            .IF              .IF_FALSE (.IFF)

                 .IF_TRUE (.IFT)  .IF_TRUE_FALSE   .IIF
                                  (.IFTF)

                 .INCLUDE         .IRP             .IRPC

                 .LIBRARY         .MACRO           .MCALL

                 .MDELETE         .MEXIT           .NARG

                 .NCHAR           .REPEAT

              In addition, by Digital convention:

              o  The dollar sign ($) is reserved for names defined by
                 Digital. This convention ensures that a user-defined
                 name (that does not have a dollar sign) will not
                 conflict with a Digital-defined name (that does have
                 a dollar sign).

              o  Do not use the period (.) in any global symbol name
                 because many languages, such as FORTRAN, do not allow
                 periods in symbol names.

              Macro names follow the same rules and conventions as
              user-defined symbols. See the description of the .MACRO
              directive in Chapter 5 for more information on macro names.
              User-defined symbols and macro names do not conflict; that
              is, the same name can be used for a user-defined symbol and
              a macro.

        2.5.3 Determining Symbol Values

              The value of a symbol depends on its use in the program.
              MACRO-64 uses a different method to determine the values of
              symbols in the operator field than it uses to determine the
              values of symbols in the operand field.


                                                                     2-13

 



        Components of MACRO-64 Source Statements
        2.5 Symbols


        2.5.3.1 Using Symbols in the Operator Field

              A symbol in the operator field can be either a permanent
              symbol or a macro name. MACRO-64 searches for a symbol
              definition in the following order:

              1. Register names:

                    R0-R31
                    FP
                    SP
                    F0-F31

              2. Macro and conditional directives:

                 .ELSE       .ENDC             .ENDM

                 .ENDR       .IF               .IF_FALSE (.IFF)

                 .IF_TRUE    .IF_TRUE_FALSE    .IIF
                 (.IFT)      (.IFTF)

                 .INCLUDE    .IRP              .IRPC

                 .LIBRARY    .MACRO            .MCALL

                 .MDELETE    .MEXIT            .NARG

                 .NCHAR      .REPEAT

              3. Previously defined macro names

              4. Permanent symbols (instructions and other directives)

              This search order allows most permanent symbols, except
              registers, conditional directives and macro directives, to
              be redefined as macro names. If a symbol in the operator
              field is not defined as a macro or a permanent symbol, the
              assembler displays an error message.

        2.5.3.2 Using Symbols in the Operand Field

              A symbol in the operand field must be either a user-defined
              numeric symbol, a label, or a register name.

              User-defined numeric symbols and labels can be either local
              (internal) symbols or global (external) symbols. Whether
              numeric symbols and labels are local or global depends on
              their use in the source program.

              A local numeric symbol or label can be referenced only
              in the module in which it is defined. If local numeric
              symbols or labels with the same names are defined in
              different modules, the symbols and labels are completely

        2-14

 



                                 Components of MACRO-64 Source Statements
                                                              2.5 Symbols


              independent. The definition of a global numeric symbol or
              label, however, can be referenced from any module in the
              program.

              MACRO-64 treats all user-defined numeric symbols and labels
              as local unless you explicitly declare them to be global by
              doing one of the following:

              o  Use the double colon (::) in defining a label. For more
                 information on labels, see Section 2.1.1.

              o  Use the double equal sign (==) in a direct assignment
                 statement. For more information on direct assignment
                 statements, see Section 2.11.

              o  Use the .WEAK directive. For more information on the
                 .WEAK directive, see .WEAK.

              User-defined lexical string symbols can only be used with
              the lexical string operators. For more information on
              lexical string operators, see Chapter 3. You can define
              a macro using the same name as a previously defined local
              numeric symbol, global numeric symbol, or a lexical string
              symbol. However, you cannot define a lexical string symbol
              and a numeric symbol using the same name.

              In addition, you cannot use the same name for both a local
              and global numeric symbol. Nor can you use the same symbol
              name for both a numeric symbol (local or global) and a
              label (local or global).

        2.6 Temporary Labels Within Source Code

              Use temporary labels to identify addresses within a block
              of source code.

              Format

              nnnnn$:

              nnnnn
              A decimal integer in the range of 1 to 65535.

              In most cases, you can use temporary labels in the same way
              you use other labels that you define; however, there are
              some differences:

              o  Temporary labels cannot be referenced outside the block
                 of source code in which they are declared.

                                                                     2-15

 



        Components of MACRO-64 Source Statements
        2.6 Temporary Labels Within Source Code


              o  Temporary labels can be redeclared in another block of
                 source code.

              o  Temporary labels that occur within a psect with the
                 MIX or NOMIX attribute, do not appear in the debugger
                 symbol table and thus cannot be accessed by the symbolic
                 debugger. For more information on psects, see Chapter 5.

              o  Temporary labels cannot be used in the .END or
                 .PROCEDURE_DESCRIPTOR directives. For more information
                 on the .END directive, see Chapter 5.

              By convention, temporary labels are positioned like
              statement labels: left-justified in the source text.
              Although temporary labels can appear in the program in
              any order, by convention, the temporary labels in any block
              of source code should be in increasing numeric order.

              Temporary labels are useful as branch addresses when
              you use the address only within the block. You can use
              temporary labels to distinguish between addresses that are
              referenced only in a small block of code and addresses that
              are referenced elsewhere in the module. A disadvantage of
              temporary labels is that their numeric names do not provide
              any indication of their purpose. Consequently, you should
              not use temporary labels to label sequences of statements
              that are logically unrelated; user-defined symbols should
              be used instead.

              Digital recommends that users create temporary labels
              only in the range of 0$ to 29999$ because the assembler
              automatically creates temporary labels in the range of
              30000$ to 65535$ for use in macros. For more information on
              temporary labels, see Section 4.7.

              The temporary label block in which a temporary label is
              valid is delimited by the following statements:

              o  A user-defined label: global or local.

              o  A .PSECT directive. For more information on the .PSECT
                 directive, see Chapter 5.

                 An example showing the correct and incorrect use of
                 temporary labels follows:

        2-16

 



                                 Components of MACRO-64 Source Statements
                                  2.6 Temporary Labels Within Source Code


                 A:    ADDQ R1, R2, R3
                       BEQ R3, 2$         ; correct use
                       MULQ R2, R3, R4
                 2$:   ADDQ R1, R4, R5    ; definition of temporary label
                 B:    BNE R5, 2$         ; illegal
                 C:    SUBQ R2, R4, R6

                 In this example, 2$ is a temporary label, defined in
                 the block between A: and B:. The forward reference in
                 the second instruction is properly resolved. The line
                 labeled B: also references 2$, but the label B has
                 already closed the range. The temporary label 2$ can
                 be used later in the program, but its definition must
                 appear within the same block as the label.

              o  The .ENABLE and .DISABLE directives, which can extend a
                 local label block beyond user-defined labels and .PSECT
                 directives. For more information on the .ENABLE and
                 .DISABLE directives, see Chapter 5.

              A temporary label block is usually delimited by two user-
              defined labels. However, the .ENABLE LOCAL_BLOCK directive
              starts a local block that is terminated by one of the
              following:

              o  A second .ENABLE LOCAL_BLOCK directive

              o  A .DISABLE LOCAL_BLOCK directive followed by a user-
                 defined label or a .PSECT directive

              Temporary labels can be preserved with the context
              of the program section in which they are defined
              for future reference. For more information on the
              .SAVE_PSECT [LOCAL_BLOCK] and .RESTORE_PSECT directives,
              see Chapter 5.

        2.7 Label Addresses

              In the absence of optimization and automatic data
              alignment, label addresses are defined to be the psect and
              offset of the current location counter (see Section 2.11)
              at the point where the label is defined. When either
              optimization or automatic data alignment are enabled, the
              following additional considerations apply. See Section B.7
              for information on optimizations and automatic alignment.

                                                                     2-17

 



        Components of MACRO-64 Source Statements
        2.7 Label Addresses


        2.7.1 Label Addresses, Optimization, and Code Alignment

              Optimization and code alignment can affect the addresses
              assigned to labels defined in psects that have the EXE
              and NOMIX attributes. Optimization and code alignment are
              disabled by default, and can be enabled with the /OPTIMIZE
              and /ALIGNMENT command-line qualifiers (see Section 1.2.1)
              and the .ENABLE directive (see Section 5.1) . In general,
              the assembler assigns the psect and offset of the current
              location counter prior to optimization or alignment of
              code labels. However, the assembler adjusts references
              to labels in branch instructions to the address of the
              label after optimization and code alignment processing. The
              assembler does not adjust references to labels where the
              label reference occurs in an expression with more than one
              term. The following example illustrates this.

                      .psect CODE, exe, nomix
                      BSR     R0, 10$                 ; R0 -> 10$ (post-optimization)
              10$:    LDA     R1, 20$-10$(R0)         ; R1 -> 20$ (pre-optimization)
                      JMP     (R1)
                      [...]
              20$:

              In the example above, the assembler adjusts the target
              address of the BSR instruction to be the location of 10$
              after optimization and code alignment have taken place.
              Thus, the branch to 10$ functions as expected. However,
              when processing the LDA instruction, the assembler computes
              the offset between 20$ and 10$ prior to optimization and
              code alignment. Thus, the address of 20$ that is stored in
              R1 is the address prior to optimization and code alignment.
              Depending on the sequence of instructions between 10$ and
              20$, the address before optimization and code alignment
              may differ from the address after optimization and code
              alignment and the JMP instruction may not transfer control
              to the expected address.

              Note also that the assembler only performs post-
              optimization adjustment of label addresses when the label
              is the only term in the expression. For example:




        2-18

 



                                 Components of MACRO-64 Source Statements
                                                     2.7 Label Addresses


                      .psect CODE, exe, nomix
                      .base R27,LINKAGE
                      LDQ     R26, ROUTINE1_ADDR
                      JSR     R26, (R26)
                      LDQ     R26, ROUTINE2_ADDR
                      JSR     R26, (R26)
                      RET     R28
                      NOP
                      NOP

              ROUTINE1:
                      RET     (R26)
              ROUTINE2:
                      RET     (R26)

                      .psect LINKAGE, noexe
              LINKAGE:
              ROUTINE1_ADDR:
                      .address ROUTINE1
              ROUTINE2_ADDR:
                      .address ROUTINE2+0

              In the example above, the assembler adjusts the address
              stored with the .ADDRESS ROUTINE1 directive to the address
              of label ROUTINE1 after optimization and code alignment.
              However, since the expression in the .ADDRESS ROUTINE2+0
              directive is not a single term, the assembler adds the
              offset 0 and the address of ROUTINE2 prior to optimization
              and code alignment and stores the result. Since the address
              stored is the address prior to optimization and code
              alignment, the second JSR instruction may not transfer
              control to the address that is expected.

        2.7.2 Label Addresses and Automatic Data Alignment

              Automatic data alignment can affect the addresses
              assigned to labels in psects that have the NOEXE or MIX
              attributes. Automatic data alignment is enabled with
              the .ENABLE ALIGN_DATA directive or the /ALIGNMENT=data
              command line option. For more information on automatic
              alignment, see Section 5.2. For more information on the
              .ENABLE directive, see Section 5.3.



                                                                     2-19

 



        Components of MACRO-64 Source Statements
        2.7 Label Addresses


              A label that occurs in a statment with a data storage
              directive is assigned the psect and offset of the storage
              allocated by the data storage directive. If the data
              storage directive requires automatic alignment, the address
              is assigned to the label after automatic alignment.

              The same is true of labels that occur in statements by
              themselves and that are followed by a data directive in
              a subsequent statement. However, if a label occurs in
              a statement by itself and is followed by an assembler
              directive that is not a data storage directive, a macro
              directive, or a conditional directive, the label is
              assigned the psect and offset of the current location
              counter prior to any automatic alignment.

              Note that the assembler only assigns addresses to labels
              after alignment under the conditions described above
              and only with automatic alignment. If you place a label
              before a .ALIGN directive that manually aligns the current
              location counter, the assembler assigns the address of
              the label prior to performing the manual alignment. The
              following example illustrates the interaction of label
              address assignment and automatic data alignment:

                    .enable align_data
                    .psect data,noexe
                    .byte   1             ; The byte is stored in psect data at offset 0
              A:    .print "Not aligned"  ; Any non-macro, non-conditional statement,
                                          ; including this .PRINT directive prevents
                     ; A from being automatically aligned -- A is
                                          ; assigned offset 1
              B:                          ; B is automatically aligned to offset 4
              C:    .long   2             ; C is automatically aligned to offset 4
              D:    .align 0              ; The .ALIGN global directive prevents D from being
                                          ;  automatically aligned -- D is assigned offset 8
              E:    .octa 3               ; E is automatically aligned to offset 16

              Automatic data alignment and label-address assignment
              can be an important consideration when calculating the
              difference between two labels. For example, consider the
              following macro, which stores a string preceded by a word
              that contains the string's length:



        2-20

 



                                 Components of MACRO-64 Source Statements
                                                     2.7 Label Addresses


                      .macro VARYING_STRING STRING ?L1, ?L2
                              .word L2-L1
                          L1: .ASCII "STRING"
                          L2:
                      .ENDM VARYING_STRING

              If an invocation of the VARYING_STRING macro is followed by
              a data storage directive that requires automatic alignment,
              the VARYING_STRING macro will not store the correct string
              length. For example:

                      .psect DATA, noexe, octa
                      .enable align_data
                      VARYING_STRING <Time for something sweet!> ; 25 bytes
              F:      .octa 4

              In this example, the intention is to make the L2 label
              generated by the VARYING_STRING macro be assigned the
              offset 27, 2 for the .WORD directive, plus 25 for the
              .ASCII directive. Instead, it is assigned the offset
              32 along with the label F because the .OCTA directive
              requires automatic alignment to offset 32. Therefore,
              the string length is incorrectly stored as 30 rather 25.
              To make this macro work as desired, you must include,
              in the macro definition, a macro directive that is not a
              data storage, macro, or conditional directive after the
              generated label L2. As shown below, .ALIGN 0 is a good
              choice as it reflects the idea that the preceding label is
              not aligned.

               .macro VARYING_STRING STRING ?L1, ?L2
                    .word L2-L1
                   L1: .ASCII "STRING"
                   L2: .align 0
               .ENDM VARYING_STRING

              With this change, the generated label L2 is assigned
              the offset 27 before the assembler performs automatic
              data alignment for the .OCTA directive. As a result,
              the VARYING_STRING macro works as desired and stores the
              correct string length of 25.




                                                                     2-21

 



        Components of MACRO-64 Source Statements
        2.8 Terms and Expressions


        2.8 Terms and Expressions

              A term can be any of the following:

              o  A number.

              o  A numeric symbol.

              o  A label.

              o  The current location counter. For more information on
                 the current location counter, see Section 2.12.

              o  Any of the previously noted items preceded by a unary
                 operator.

              For more information on unary operators, see Section 2.9.

              MACRO-64 evaluates terms as quadword (8-byte) values. The
              current location counter (.) has the value of the location
              counter at the start of the current operand.

              MACRO-64 considers unary operators part of a term and thus,
              performs the action indicated by a unary operator before it
              performs the action indicated by a binary operator.

              Expressions are combinations of terms joined by binary
              operators and evaluated as quadword (8-byte) values. For
              more information on binary operators, see Section 2.10.
              MACRO-64 evaluates expressions from left to right with
              no operator precedence rules. However, angle brackets
              (<>) can be used to change the order of evaluation. Any
              part of an expression that is enclosed in angle brackets
              is first evaluated to a single value, which is then used
              in evaluating the complete expression. For example, the
              expressions A*B+C and A*<B+C> are different. In the first
              case, A and B are multiplied and then C added to the
              product. In the second case, B and C are added and the
              sum is multiplied by A. Angle brackets can also be used
              to apply a unary operator to an entire expression, such as
              -<A+B>.

              Expressions fall into four categories: relocatable,
              absolute, external (global), and complex. You can determine
              the type of expression by the following rules:

              o  An expression is relocatable if its value is fixed
                 relative to the start of the program section in which

        2-22

 



                                 Components of MACRO-64 Source Statements
                                                2.8 Terms and Expressions


                 it appears. The current location counter is relocatable
                 in a relocatable program section.

              o  An expression is absolute if its value is an assembly-
                 time constant. An expression whose terms are all
                 numbers is absolute. An expression that consists of a
                 relocatable term minus another relocatable term from
                 the same program section is absolute, because such an
                 expression reduces to an assembly-time constant.

              o  An expression is external if it is not complex, and it
                 contains one or more symbols that are not defined in the
                 current module.

              o  An expression is complex if it contains a relocatable or
                 external term or sub-expression that is operated upon by
                 an operator other than the plus sign (+) or the minus
                 sign (-). An expression is also complex if it contains
                 more than one term or sub-expression that is relocatable
                 or external. An exception to this rule is the difference
                 between two relocatable sub-expressions or terms where
                 both relocatable values occur in the same psect. In this
                 case, the expression is absolute.

              Complex expressions are constrained to use the following
              form:

              FORMAT

              term operator term

              term
              Term is a relocatable or external sub-expression.

              operator
              Operator is any of the MACRO-64 operators described in
              Section 2.10.

              Neither term can itself be a complex subexpression. If
              you specify a complex expression that does not match the
              correct form, the assembler issues a diagnostic error
              message indicating that the expression is too complex.
              Note also that the assembler does not attempt to reorder
              expressions to make your expressions match the correct
              form. For example, the following expression is too complex:

               .external E1, E2
               .quad E1+5+E2+6  ; too complex

                                                                     2-23

 



        Components of MACRO-64 Source Statements
        2.8 Terms and Expressions


              Because the assembler has no precedence rules, it attempts
              to evaluate the above expression as <<<E1+5>+E2>+6>. Since
              <<E1+5>+E2> is itself a complex term, <<<E1+5>+E2>+6> does
              not match the above form and is too complex. However, you
              can regroup the expression using angle brackets (<>) to
              match the required form as follows:

               .external E1, E2
               .quad <E1+5>+<E2+6>  ; legal complex expression

              In this case, both <E1+5> and <E2+6> are simple, external
              terms. Since none of the terms are complex, the expression
              matches the correct form and the assembler accepts the
              complex expression.

              Any type of expression can be used in most MACRO-64
              statements, but restrictions are placed on expressions
              used in the following contexts:

              o  .BASE directive.

              o  .BLKx storage allocation directives.

              o  .IF conditional assembly block directives.

              o  .REPEAT repeat block directives.

              o  Direct assignment statements.

              o  Lexical string operator arguments. For more information
                 on direct assignment statements, see Section 2.11.

              See Chapter 5 for descriptions of the directives listed in
              the preceding list.

              Expressions used in these contexts can contain only symbols
              or labels that have been previously defined in the current
              module.

              The .BASE directive accepts expressions that contain
              external symbols previously declared with the .EXTERNAL
              directive. The other contexts previously described cannot
              accept expressions that contain external symbols. Symbols
              defined later in the current module cannot be used in any
              of these contexts.

              Expressions in the .IF conditional directives, .REPEAT
              conditional directives, and lexical string operator
              arguments are relocatable. However, expressions in the
              .BLKx directives must be absolute.

        2-24

 



                                 Components of MACRO-64 Source Statements
                                                2.8 Terms and Expressions


              Note that expressions cannot contain floating-point
              numbers. The floating-point data storage directives
              accept constant values. They do not accept floating-point
              expressions. For more information on the floating-point
              data storage directives, see Chapter 5.

              The following example shows the use of expressions:

              A = 2*100                 ; 2*100 is an absolute expression
                      .BLKB   A+50      ; A+50 is an absolute expression and
                                        ;   contains no undefined symbols
              LAB:    .BLKW   A         ; LAB is relocatable
              HALF = LAB+<A/2>          ; LAB+<A/2> is a relocatable
                                        ;   expression and contains no
                                        ;   undefined symbols
              LAB2:   .BLKB   LAB2-LAB  ; LAB2-LAB is an absolute expression
                                        ;   and contains no undefined symbols

        2.9 Unary Operators for Terms and Expressions

              A unary operator modifies a term or an expression and
              indicates the action to be performed on that term or
              expression. Expressions modified by unary operators must
              be enclosed in angle brackets. You can use unary operators
              to indicate whether a term or expression is positive
              or negative. If unary plus or minus is not specified,
              the default value is plus. In addition, unary operators
              perform radix conversion and numeric control operations, as
              described in the following sections. Table 2-3 summarizes
              the unary operators.

              Table_2-3_Summary_of_Unary_Operators_______________________

              Unary   Operator
              OperatorName________Example___Operation____________________

              +       Plus sign   +A        Results in the positive value
                                            of A.

              -       Minus sign  -A        Results in the negative
                                            (two's complement) value
                                            of A.

                                                 (continued on next page)

                                                                     2-25

 



        Components of MACRO-64 Source Statements
        2.9 Unary Operators for Terms and Expressions


              Table_2-3_(Cont.)_Summary_of_Unary_Operators_______________

              Unary   Operator
              OperatorName________Example___Operation____________________

              \       Value of    \symbol   Indicates that the value
                      Escape                of the symbol should be
                                            used. In a string literal,
                                            indicates an escape sequence.
                                            For example:
                                            "Bob\X0A"

              ^A or   ASCII       ^A/ABCD/  Specifies an ASCII constant.
              ^a

              ^B or   Binary      ^B11000111Specifies that 11000111 is a
              ^b                            binary number.

              ^D or   Decimal     ^D127     Specifies that 127 is a
              ^d                            decimal number.

              ^O or   Octal       ^O34      Specifies that 34 is an octal
              ^o                            number.

              ^X or   Hexadecimal ^XFCF9    Specifies that FCF9 is a
              ^x                            hexadecimal number.

              ^C or   Complement  ^C24      Produces the one's complement
              ^c____________________________value_of_24_(decimal)._______

        2.9.1 Radix Control Operators

              Radix control operators determine the radix of a term or
              expression. MACRO-64 accepts terms or expressions in four
              different radixes: binary, decimal, octal, and hexadecimal.
              The default radix is decimal.

              Formats

              ^Bnn ^Dnn ^Onn ^Xnn

              nn
              A string of characters that is legal in the specified
              radix. The following are the legal characters for each
              radix:

        2-26

 



                                 Components of MACRO-64 Source Statements
                            2.9 Unary Operators for Terms and Expressions

              ___________________________________________________________
              Format__Radix_Name__Legal_Characters_______________________

              ^Bnn    Binary      0 and 1

              ^Dnn    Decimal     0 to 9

              ^Onn    Octal       0 to 7

              ^Xnn____Hexadecimal_0_to_9_and_A_to_F______________________

              Radix control operators can be included in the source
              program anywhere a numeric value is legal. A radix control
              operator affects only the term immediately following it,
              causing that term to be evaluated in the specified radix.

              For example:

              .WORD   ^B00001101              ; Binary radix
              .WORD   ^D123                   ; Decimal radix (default)
              .WORD   ^O47                    ; Octal radix

              Do not place spaces or tabs between the circumflex (^), the
              radix specifier (B, D, O, or X), or the numeric value.

        2.9.2 Numeric Complement Operator

              The complement operator (^C) produces the one's complement
              of the specified value.

              Format

              ^Cterm

              term
              Any term or expression. If an expression is specified, it
              must be enclosed in angle brackets.

              MACRO-64 evaluates the term or expression as an 8-byte
              value before complementing it.

              For example:

              .LONG      ^C^XFF      ; Produces FFFFFF00 (hex)
              .LONG      ^C25        ; Produces complement of
                                     ;   25 (dec) which is
                                     ;   FFFFFFE6 (hex)

                                                                     2-27

 



        Components of MACRO-64 Source Statements
        2.10 Binary Operators


        2.10 Binary Operators

              In contrast to unary operators, binary operators specify
              actions to be performed on two terms or expressions.
              Expressions can be enclosed in angle brackets to specify
              the order of evaluation. Table 2-4 summarizes the binary
              operators.

              Table_2-4_Summary_of_Binary_Operators______________________

                 Binary Operator
              ___OperatoName__________Example_Operation__________________

                 +      Plus sign     A+B     Addition

                 -      Minus sign    A-B     Subtraction

                 *      Asterisk      A*B     Multiplication

                 /      Slash         A/B     Division

                 @      At sign       A@B     Arithmetic shift

                 &      Ampersand     A&B     Logical AND (product)

                 !      Exclamation   A!B     Logical OR (sum)
                        point

              ___\______Backslash_____A\B_____Logical_XOR_(difference)___

              All binary operators have equal priority. Terms or
              expressions can be grouped for evaluation by enclosing
              them in angle brackets. The enclosed terms and expressions
              are evaluated first, and remaining operations are performed
              from left to right. For example:

              .LONG      1+2*3      ; Equals 9
              .LONG      1+<2*3>    ; Equals 7

              Note that a 64-bit result is returned from all binary
              operations. If you use the 64-bit result in a context
              requiring less than 64 bits, only the lower order bits
              of the result are used. If the truncation causes a loss
              of significance in a data storage directive, the assembler
              displays an error message.

              The following sections describe the arithmetic shift,
              logical AND, logical inclusive OR, and logical exclusive
              OR operators.

        2-28

 



                                 Components of MACRO-64 Source Statements
                                                    2.10 Binary Operators


        2.10.1 Arithmetic Shift Operator

              Use the arithmetic shift operator (@) to perform left
              and right arithmetic shifts of arithmetic quantities. The
              first argument is shifted left or right by the number of
              bit positions that you specify in the second argument.
              If the second argument is positive, the first argument is
              shifted left and the low-order bits are set to zero. If the
              second argument is negative, the first argument is shifted
              right and the high-order bits are set to the value of the
              original high-order bit (the sign bit). For example:

                      .LONG   ^B101@4              ; Yields 1010000 (binary)
                      .LONG   1@2                  ; Yields 100 (binary)
              A = 4
                      .LONG   1@A                  ; Yields 10000 (binary)
                      .LONG   ^X1234@-A            ; Yields 123(hex)

        2.10.2 Logical AND Operator

              The logical AND operator (&) takes the logical AND of two
              operands. For example:

              A = ^B1010
              B = ^B1100
                      .LONG   A&B             ; Yields 1000 (binary)

        2.10.3 Logical Inclusive OR Operator

              The logical inclusive OR operator (!) takes the logical
              inclusive OR of two operands. For example:

              A = ^B1010
              B = ^B1100
                      .LONG   A!B             ; Yields 1110 (binary)

        2.10.4 Logical Exclusive OR Operator

              The logical exclusive OR operator (\) takes the logical
              exclusive OR of two arguments. For example:

              A = ^B1010
              B = ^B1100
                      .LONG   A\B             ; Yields 0110 (binary)

                                                                     2-29

 



        Components of MACRO-64 Source Statements
        2.11 Direct Assignment Statements


        2.11 Direct Assignment Statements

              A direct assignment statement equates a symbol to a
              specific value. Unlike a symbol that you use as a label,
              you can redefine a symbol defined with a direct assignment
              statement as many times as you want.

              Formats

              symbol=expression

              symbol==expression

              symbol=quoted-literal

              symbol
              A user-defined symbol.

              expression
              An expression that does not contain any undefined symbols
              or forward references. For more information on terms and
              expressions, see Section 2.8. The result must be either
              an absolute or relocatable value, whose value can be
              determined at the current point in the assembly. This form
              defines a numeric symbol.

              The format with a single equal sign (=) defines a local
              symbol, and the format with a double equal sign (==)
              defines a global symbol. For more information about local
              and global symbols, see Section 2.5.3.

              The following three syntactic rules apply to direct
              assignment statements:

              o  An equal sign (=) or double equal sign (==)  must
                 separate the symbol from the expression that defines
                 its value. Spaces preceding or following the direct
                 assignment operators have no significance in the
                 resulting value.

              o  Only one symbol can be defined in a single direct
                 assignment statement.

              o  A direct assignment statement can be followed only by a
                 comment field.

        2-30

 



                                 Components of MACRO-64 Source Statements
                                        2.11 Direct Assignment Statements


              For best results, Digital recommends you place the symbol
              in a direct assignment statement in the label field. For
              example:

              A == 1                  ; The symbol 'A' is globally
                                      ;   equated to the value 1

              B = A@5                 ; The symbol 'B' is equated
                                      ;   to 1@5 or 32(dec)

              C = 127*10              ; The symbol 'C' is equated
                                      ;   to 1270(dec)

              D = ^X100/^X10          ; The symbol 'D' is equated
                                      ;   to 10(hex)

              quoted-literal
              A literal within double quotes. This form defines a lexical
              string symbol. Lexical string symbols can only be used with
              lexical string operators.

              For more information on lexical string operators, see
              Chapter 3.

        2.12 Current Location Counter

              The current location counter is a counter kept by an
              assembler to determine the address assigned to an
              instruction or constant that is being assembled. The
              symbol for the current location counter, the period (.),
              represents the address of the current byte. MACRO-64 sets
              the current location counter to zero at the beginning
              of the assembly and at the beginning of each new program
              section.

              Every MACRO-64 source statement that allocates memory in
              the object module increments the value of the current
              location counter by the number of bytes allocated. For
              example, the directive, .LONG 0, increments the current
              location counter by 4. However, with the exception of the
              special form described below, a direct assignment statement
              does not increase the current location counter because no
              memory is allocated.


                                                                     2-31

 



        Components of MACRO-64 Source Statements
        2.12 Current Location Counter


              The current location counter can be explicitly set by
              a special form of the direct assignment statement. The
              location counter can be either incremented or decremented.
              This method of setting the location counter is often useful
              when defining data structures. Data storage areas should
              not be reserved by explicitly setting the location counter;
              use the .BLKx directives. For more information on the .BLK
              directive, see Chapter 5.

              Format

              .=expression

              expression
              An expression that does not contain any undefined or
              external symbols. For more information on expressions,
              see Section 2.8.

              In a relocatable program section, the expression must be
              relocatable; that is, the expression must be relative to
              an address in the current program section. It also may be
              relative to the current location counter. For example:

              . = .+40        ; Moves location counter forward

              When a program section that you defined in the current
              module is continued, the current location counter is set
              to the last value of the current location counter in that
              program section.

              In a program section with the EXE and NOMIX attributes:

              o  The location counter cannot be changed.

              o  If optimization is enabled, the location counter
                 represents the location prior to optimization. For more
                 information on optimization, see Section 2.7.1.








        2-32

 










                                                                        3
        _________________________________________________________________

                                                MACRO-64 Lexical Operator


              This chapter describes the MACRO-64 lexical operators.

        3.1 Processing with Lexical Operators

              Lexical operator processing is performed on all source
              lines and macro expansion lines prior to any other
              assembler processing. Thus, macro invocations, assembler
              directives, and instructions are subject to lexical
              operator processing prior to normal assembler processing.

              Lexical operators are recognized and processed within
              string literals. Lexical operator processing is suppressed
              during macro registration in order that lexical operator
              evaluation may occur during macro expansion. Lexical
              operator evaluation is also suppressed for a range of
              text that is conditionally excluded with one of the .IF
              directives. In addition, lexical operator processing is not
              performed within a comment.

        3.2 Lexical Operator Syntax

              You invoke a lexical string operator with a percent sign
              followed by the lexical operator name, a left parentheses,
              a list of arguments separated by commas, and a right
              parentheses. The following example illustrates the lexical
              operator syntax:

              .print "%EDIT(<Fred>,<upcase>)"

              Spaces are allowed between syntax elements in the general
              lexical operator syntax. For example, the following syntax,
              including spaces, is allowed.

              .print "%EDIT ( <Fred> , <upcase> )"


                                                                      3-1

 



        MACRO-64 Lexical Operator
        3.2 Lexical Operator Syntax


              Spaces are also allowed between the opening and closing
              percent signs in a lexical substitution operator. See
              Section 3.4 for information on lexical substitution
              operators.

              .print "% lexical_symbol_name %"

              Spaces are not allowed between the pair of percent signs
              indicating a lexical escape operator. See Section 3.5 for
              information on lexical escape operators.

              Lexical operator arguments can be specified in the same way
              as macro arguments:

              o  A numeric symbol name preceded by a backslash (\). This
                 construct results in the decimal value of the numeric
                 symbol, as shown in the following example:

                 \N

              o  Any string of characters surrounded by left and right
                 angle brackets, as shown in the following example:

                 <Foo bar thud>

                 You can nest angle brackets (<>). See the following
                 example:

                 <<X+7>*17>

              o  Any string of characters surrounded by a delimiter
                 specified after a caret character (^). You cannot nest
                 delimiters. See the following example:

                 ^%Foo bar thud%

              o  Any undelimited string of characters not separated by a
                 space, tab, form feed, comma, equal sign, semicolon, or
                 end of line. See the following example:

                 A+B+C

              In addition to the formats allowed for a macro argument,
              lexical operator arguments may also be specified as
              follows:

              o  An undelimited string of characters may also contain
                 a string of characters enclosed within left and right
                 parenthesis. The characters between the left and right
                 parenthesis may contain space, tab, or comma delimiters.
                 See the following example:

        3-2

 



                                                MACRO-64 Lexical Operator
                                              3.2 Lexical Operator Syntax


                 16( R27 )

              o  You can use a lexical operator as an argument to another
                 lexical operator as shown in the following example:

                 %EXTRACT( %LOCATE($,X), %LENGTH(X) - %LOCATE($,X) ,X)

              Except for the %TYPE lexical operator, a string symbol name
              supplied as a lexical operator argument is replaced with
              the value of the string symbol.

              Each lexical operator accepts a given number of arguments
              and each argument has a specific type. There are three
              different types of arguments: string, integer, and name.

              o  A string argument can be any arbitrary sequence of
                 characters.

              o  An integer argument must be an absolute or relocatable
                 expression that can be resolved at that point in the
                 assembly. A relocatable expression represents a psect
                 and an offset within that psect. If you specify a
                 relocatable expression for an integer argument, the
                 assembler uses only the value of the offset within
                 the psect. The offset value is determined before
                 optimization and code alignment, but after data
                 alignment.

              o  The name argument type is used only by the %TYPE lexical
                 operator. The %TYPE lexical operator accepts the name
                 of a numeric symbol, string symbol, label, psect, or
                 a permanent symbol as its argument. Unlike the other
                 lexical operators, if a string symbol name is specified
                 as an argument to %TYPE, the value of the string symbol
                 is not substituted for its name. Instead, information
                 about the name is returned.

              If you omit a string argument, the default is the empty
              string. An empty string is a string with no characters.
              If you omit an integer argument or specify an illegal
              expression, the default value is zero. The assembler does
              not issue diagnostic messages for illegal expressions used
              as aguments to lexical operators. If you omit the name
              argument or specify an illegal name to the %TYPE lexical
              operator, %TYPE returns a zero value.

                                                                      3-3

 



        MACRO-64 Lexical Operator
        3.3 Numeric Symbols and Lexical String Symbols


        3.3 Numeric Symbols and Lexical String Symbols

              Lexical string symbols are similar in concept and syntax
              to numeric symbols. MACRO-64 supports numeric symbols using
              the following syntax:

              numeric_symbol_name = numeric_expression

              MACRO-64 supports lexical string symbols using the
              following syntax:

              string_symbol_name = "any string of characters"

              The assembler differentiates between numeric symbol
              assignment and lexical string symbol assignment as follows:

              o  In a lexical string symbol assignment, a quoted string
                 literal must appear after the equal sign.

              o  A lexical string symbol value is specified by the quoted
                 string literal.

              Note that the quotes are not included in the value of the
              lexical string symbol. You cannot use the same name for a
              lexical string symbol, numeric symbol or label.

              Like numeric symbols, lexical string symbols are assembly
              time variables. Once you have assigned a string value to a
              lexical string symbol, you can reassign a different value
              to the symbol later in the assembly.

              You can use lexical string symbols as arguments to lexical
              operators. In particular, you can use a lexical string
              symbol as an argument to the lexical substitution operator
              (%) or the %STRING lexical operator to substitute the
              value of the lexical string symbol at any point in the text
              of your program.

        3.4 Lexical Substitution Operator

              You can use the lexical substitution operator at any point
              in your program to cause the assembler to substitute the
              value of a lexical string symbol for the name of the
              symbol. The lexical substitution operator is the percent
              sign (%). Place the lexical substitution operator to the
              left and right of the name of the lexical string symbol
              that you wish to subsitute, as follows:

        3-4

 



                                                MACRO-64 Lexical Operator
                                        3.4 Lexical Substitution Operator


              %lexsym_name%

              For example:

                   HORSES    = "All the king's horses"
                   MEN       = "all the king's men"
                   .print "%HORSES% and %MEN%"

              The above example defines two lexical string symbols:
              HORSES and MEN. The third statement displays a message
              at assembly time. The text of the message specifies that
              the value of the HORSES and MEN lexical string symbols
              be subsituted as indicated. After lexical processing, the
              third statement appears as:

                   .print "All the king's horses and all the king's men"

        3.5 Lexical Escape Operator

              It is possible to defer the processing of a lexical string
              operator by using the lexical escape operator, which is the
              percent sign (%). Since all lexical string operators begin
              with a percent sign, the effect of placing two percent
              signs before the name of the lexical string operator defers
              the evaluation of the lexical string operator. If you want
              to defer processing of a lexical substitution operator,
              place two percent signs to the left and two percent signs
              to the right of the lexical string symbol name.

              This can be useful when you want the evaluation of a
              lexical string operator that you have used in a default
              macro argument to occur during macro expansion, rather than
              during macro definition. Lexical operator processing is
              suppressed during macro registration. Therefore, lexical
              operator processing is automatically deferred within the
              body of a macro. However, the .MACRO directive line that
              begins the macro definition is subject to normal lexical
              operator processing. Sometimes you may need to use the
              value of a lexical string symbol as the default for a macro
              argument, but you need to use the value of the lexical
              string symbol that is current when the macro expands, not
              when the macro is defined. Example 3-1 shows an example of
              this, though not using an escape operator:


                                                                      3-5

 



        MACRO-64 Lexical Operator
        3.5 Lexical Escape Operator


              Example 3-1 Lexical Processing Without the Escape Operator

                  CODE_PSECT_NAME = "CODE1"
                  .macro CODE_PSECT PSECT_NAME=%string(CODE_PSECT_NAME)
                   .psect PSECT_NAME
                  .endm CODE_PSECT
                  CODE_PSECT
                  CODE_PSECT_NAME = "CODE2"
                  CODE_PSECT

              Example 3-1 does not process correctly for the following
              reasons:

              o  The lexical operator in the .MACRO directive line is
                 processed when the macro is defined, not when the macro
                 expands.

              o  The CODE_PSECT macro always defaults to setting
                 the psect to the CODE1 psect because the default
                 for the PSECT_NAME  argument will be set to CODE1,
                 not %string(CODE_PSECT_NAME). This is because
                 %string(CODE_PSECT_NAME) is evaluated when the CODE_
                 PSECT macro is defined, not when it expands.

              Example 3-2 is similar to Example 3-1 except it uses the
              lexical escape operator:

              Example 3-2 Lexical Processing With Escape Operator

                  CODE_PSECT_NAME = "CODE1"
                  .macro CODE_PSECT PSECT_NAME=%%string(CODE_PSECT_NAME)
                 .psect PSECT_NAME
                  .endm CODE_PSECT
                  CODE_PSECT
                  CODE_PSECT_NAME = "CODE2"
                  CODE_PSECT

              Example 3-2 processes correctly for the following reasons:

              o  Lexical operator processing of %%string(CODE_PSECT_NAME)
                 is deferred when the CODE_PSECT macro is defined. The
                 default value for the PSECT_NAME argument is stored as
                 %string(CODE_PSECT_NAME).

              o  During macro expansion, %string(CODE_PSECT_NAME)
                 is evaluated, resulting in the current value of the
                 CODE_PSECT_NAME lexical string symbol as desired.

        3-6

 



                                                MACRO-64 Lexical Operator
                                              3.6 Using Lexical Operators


        3.6 Using Lexical Operators

              This section contains a programming example showing source
              statements using lexical operators and the same statements
              after macro expansion and lexical operator processing.

              Example 3-3 Using Lexical Operators

                      ; Macro to load a general or floating register
                      .macro LOAD REG LOCATION

                          ; If the location doesn't specify a base register,
                          ; load relative to the procedure descriptor PD off
                          ; of R27.
                          .if lt, %locate(<(>, LOCATION), %length(LOCATION)
                              ; base register specified
                              LOC = "LOCATION"
                          .else
                              ; base register not specified
                              LOC = "LOCATION-PD(R27)"
                          .endc

                          ; Use LDQ if a general register is specified
                          .if ne, <%type(REG) & MACRO64$TYPE_GENREG>
                              LDQ   REG,%string(LOC)

                                                 (continued on next page)


















                                                                      3-7

 



        MACRO-64 Lexical Operator
        3.6 Using Lexical Operators


              Example 3-3 (Cont.) Using Lexical Operators

                          .else
                              ; Use LDx if a floating register is specified
                              .if ne <%type(REG) & MACRO64$TYPE_FLTREG>
                                  ; Use the appropriate LDx floating load
                                  ; depending on the first letter of the
                                  ; location to load.
                                  FTYPES = "FGST"
                                  .if ge, %locate(%extract(0,1,LOC),FTYPES), -
                                      %length(FTYPES)
                                      .error -
                       "Unknown floating data type: %extract(0,1,LOC)"
                                      .mexit
                                  .endc
                                  LD%extract(0,1,LOCATION) REG,%string(LOC)
                              .else
                                  .error -
                       "First argument must be a general or floating register"
                              .endc
                          .endc
                      .endm LOAD
                      .psect D,noexe
              pd:     .procedure_descriptor my_routine,my_entry
                      ; Fill in procedure descriptor details...
              BUILD_TIME:
                      .asciz       "%time()"
              K:      .quad        %repeat(9,<42,>)42
              GPI:    .g_floating  3.14159
              CIRCLE: .address     FAC_CIRCLE
              TX      = 0
              TY      = 8
              TRADIUS = 16
                      .psect X,exe
              MY_ENTRY:
                      LOAD  R1,K
                      LOAD  R2,CIRCLE
                      LOAD  F13,TRADIUS(R2)
                      LOAD  F11,GPI
                      LOAD  F10,K
                      LOAD  K

                                                 (continued on next page)


        3-8

 



                                                MACRO-64 Lexical Operator
                                              3.6 Using Lexical Operators


              Example 3-3 (Cont.) Using Lexical Operators












































                                                                      3-9

 



        MACRO-64 Lexical Operator
        3.6 Using Lexical Operators


              Example 3-4 Source Statements After Macro Expansion

                      .psect D,noexe
              pd:     .procedure_descriptor my_routine,my_entry
                      ; Fill in procedure descriptor details...
              BUILD_TIME:
                      .asciz       " 9-JUL-1992 17:56:20"
              K:      .quad        42,42,42,42,42,42,42,42,42,42
              GPI:    .g_floating  3.14159
              CIRCLE: .address     FAC_CIRCLE
              TX      = 0
              TY      = 8
              TRADIUS = 16
                      .psect X,exe
              MY_ENTRY:
                      LDQ   R1,K-PD(R27)
                      LDQ   R2,CIRCLE-PD(R27)
                      LDT   F13,TRADIUS(R2)
                      LDG F11,GPI-PD(R27)
                      .error "Unknown floating data type: K"
                      .error "First argument must be a general or floating register"
























        3-10

 



                                                MACRO-64 Lexical Operator
                                                    3.7 Lexical Operators


        3.7 Lexical Operators

              This section describes the MACRO-64 lexical operators,
              their return values, and their arguments. Table 3-1 lists
              the lexicals and gives a brief summary of their function. A
              decimal return value results in the decimal digits of the
              numeric value being substituted for the lexical operator.

              Table_3-1_Summary_of_MACRO-64_Lexicals_____________________

                        Return
              Lexical___Type______Function_______________________________

              %EDIT     String    Lexical operator for editing text
                                  strings.

              %ELEMENT  String    Lexical operator for extracting an
                                  element from a list of elements.

              %EXTRACT  String    Lexical operator for extracting a
                                  range of characters from a string of
                                  characters.

              %INTEGER  Decimal   Lexical operator to convert the value
                                  of an expression to a decimal value.

              %LENGTH   Decimal   Lexical operator for determining the
                                  length of a string.

              %LOCATE   Decimal   Lexical operator for locating a string
                                  of text within a another string of
                                  text.

              %REPEAT   String    Lexical operator for repeating a
                                  specified string x number of times.

              %STRING   String    Lexical operator for obtaining the
                                  value of a lexical string symbol.

              %TIME     String    Lexical operator for obtaining the date
                                  and time of the assembly unit.

              %TYPE     Decimal   Lexical operator for obtaining
              ____________________information_about_a_name.______________

                                                                     3-11

 



        MACRO-64 Lexical Operators
        %EDIT


        _________________________________________________________________

        %EDIT

              Lexical operator for editing text strings.

        Format

              %EDIT  (string1,string2)

        Arguments

              string1
              The first argument, of type string, specifies the string to
              be edited.

              string2
              The second argument, of type string, specifies a list of
              edits to perform, separated by commas.

        Description

              %EDIT is modeled after the OpenVMS DCL F$EDIT lexical
              function. It is used to perform one or more edits on a
              specified string. %EDIT processes the string of arguments
              from left to right. %EDIT gives precedence to the last
              argument. %EDIT gives precedence to uppercase over
              lowercase.

              The list of edits may contain any combination of the
              following elements:

              ___________________________________________________________
              Element_____Function_______________________________________

              COLLAPSE    Removes all tabs and spaces.

              COMPRESS    Replaces multiple tabs and spaces with a single
                          space.

              LOWERCASE   Changes uppercase characters to lowercase.

              TRIM        Removes leading and trailing spaces and tabs.

              UPCASE______Changes_lowercase_characters_to_uppercase._____

        3-12

 



                                               MACRO-64 Lexical Operators
                                                                    %EDIT



        Examples

                 Example 1

                     .PRINT "%EDIT(< Fred Smith >, <TRIM,COLLAPSE,UPCASE>)"

                 After lexical processing, the statement apears as the
                 following:

                     .PRINT "FREDSMITH"

                 Example 2

                     .PRINT "%EDIT(<AbCdEfG>,<upcase,lowercase>)
                     .PRINT "%EDIT(<AbCdEfG>,<lowercase,upcase>)

                 The first source statement produces the string "abcdefg"
                 and the second source statement produces the string
                 "ABCDEFG". Each of the edits in the edit list is
                 performed in sequence, left to right.
























                                                                     3-13

 



        MACRO-64 Lexical Operators
        %ELEMENT


        _________________________________________________________________

        %ELEMENT

              Lexical operator for extracting elements from a list of
              elements.

        Format

              %ELEMENT  (integer,string1,string2)

        Arguments

              integer
              The first argument, of type integer, is the element number
              to extract. The first element is number zero.

              string1
              The second argument, of type string, is the delimiter or
              delimiters that separate elements.

              string2
              The third argument, of type string, is the list of
              elements.

        Description

              %ELEMENT is modeled after OpenVMS DCL's F$ELEMENT lexical
              function. It is used to extract one element from a string
              of elements. Note that unlike F$ELEMENT, you may specify
              multiple delimiters. The result is the specified string
              element. If the specified element number is greater than
              the number of elements in the list, the delimiter argument
              is returned.

        Examples

                     .PRINT "%ELEMENT (2, <+-*/>, JOE+FRED-
        TOM*BILL/ERIC)"

              After lexical processing, the statement appears as:

                     .PRINT "TOM"


        3-14

 



                                               MACRO-64 Lexical Operators
                                                                 %EXTRACT


        _________________________________________________________________

        %EXTRACT

              Lexical operator for extracting a range of characters from
              a string of characters.

        Format

              %EXTRACT  (integer1,integer2,string)

        Arguments

              integer1
              The first argument, of type integer, is the offset at which
              to begin the extraction. The first character is at offset
              zero.

              integer2
              The second argument, of type integer, is the number of
              characters to extract.

              string
              The third argument, of type string, is the string from
              which to extract the characters.

        Description

              %EXTRACT is modeled after VAX MACRO's %EXTRACT macro string
              operator and OpenVMS DCL's F$EXTRACT lexical function.
              %EXTRACT is used to extract a specified range of characters
              from a string.

        Examples

                     .PRINT "%EXTRACT(3,4,ABCDEFGHIJKLMNOP)"

              After lexical processing, the statement appears as:

                     .PRINT "DEFG"





                                                                     3-15

 



        MACRO-64 Lexical Operators
        %INTEGER


        _________________________________________________________________

        %INTEGER

              Lexical operator for converting the value of an expression
              to a decimal value.

        Format

              %INTEGER  (integer)

        Arguments

              integer
              The single argument, of type integer, is the expression to
              be converted.

        Description

              %INTEGER is modeled after OpenVMS DCL's F$INTEGER lexical
              function. It is used to convert the value of an expression
              to a decimal value. The result is its decimal value.
              %INTEGER can also be used convert a relocatable expression
              to an absolute value.

        Examples

                     .PRINT "%INTEGER (<<X+7>*17>)

              After lexical processing, if X has the value 3, the
              statement would appear as:

                     .PRINT "170"












        3-16

 



                                               MACRO-64 Lexical Operators
                                                                  %LENGTH


        _________________________________________________________________

        %LENGTH

              Lexical operator for determining the length of a string.

        Format

              %LENGTH  (string)

        Arguments

              string
              The single argument, of type string, is the string from
              which the length is to be computed.

        Description

              %LENGTH is modeled after VAX MACRO's %LENGTH macro string
              operator and OpenVMS DCL's F$LENGTH lexical function.
              %LENGTH is used to determine the length of a string. The
              result is the length of the string expressed as a decimal
              number.

        Examples

                     .PRINT "%LENGTH(<The quick brown fox>)"

              After lexical processing, the statement appears as:

                     .PRINT "19"














                                                                     3-17

 



        MACRO-64 Lexical Operators
        %LOCATE


        _________________________________________________________________

        %LOCATE

              Lexical operator for locating a string of text within
              another string of text.

        Format

              %LOCATE  (string1,string2)

        Arguments

              string1
              The first argument, of type string, is the string for which
              %LOCATE searches.

              string2
              The second argument, of type string, is the string in which
              the search is performed.

        Description

              %LOCATE is modeled after VAX MACRO's %LOCATE macro string
              operator and OpenVMS DCL's F$LOCATE lexical function.
              %LOCATE is used to locate one string within another.
              The value returned is the decimal offset to the first
              occurrence of the first string within the second string.
              The offset to the first character is zero. If the first
              string cannot be found within the second string, the length
              of the second string is returned.

        Examples

                     .PRINT "%LOCATE (DEF,ABCDEFGHIJKLMNOP)"

              After lexical processing, the statement appears as:

                     .PRINT "3"






        3-18

 



                                               MACRO-64 Lexical Operators
                                                                  %REPEAT


        _________________________________________________________________

        %REPEAT

              Lexical operator for repeating a specified string a
              specified number of times.

        Format

              %REPEAT  (integer,string)

        Arguments

              integer
              The first argument, of type integer, is the number of times
              to repeat the string. If you specify a negative value, the
              string is repeated zero times.

              string
              The second argument, of type string, is the string to be
              repeated.

        Description

              %REPEAT is used to repeat the specified string a specified
              number of times.

        Examples

                     .PRINT "Never, %REPEAT (3, <ever, >)touch that button!"

              After lexical processing, the statement appears as:

                     .PRINT "Never, ever, ever, ever, touch that button!"











                                                                     3-19

 



        MACRO-64 Lexical Operators
        %STRING


        _________________________________________________________________

        %STRING

              Lexical operator for obtaining the value of a lexical
              string symbol.

        Format

              %STRING  (string)

        Arguments

              string
              The single argument is of type string. If the argument
              is the name of lexical string symbol, the value of the
              lexical string symbol is returned. Otherwise, the argument
              is returned unchanged.

        Description

              %STRING is modeled after OpenVMS DCL's F$STRING lexical
              function. %STRING is generally used to obtain the value of
              a lexical string symbol, but it can be used with any string
              argument.

              The lexical substitution operator described in Section 3.4
              performs a similar function.

        Examples

                     FOO = "All the king's horses"
                     .PRINT "%STRING(FOO)"

              After lexical processing, the statement appears as:

                     .PRINT "All the king's horses"








        3-20

 



                                               MACRO-64 Lexical Operators
                                                                    %TIME


        _________________________________________________________________

        %TIME

              Lexical operator for obtaining the date and time of the
              assembly unit.

        Format

              %TIME  ()

        Description

              %TIME is modeled after OpenVMS DCL's F$TIME lexical
              function. %TIME is used to obtain the time and date of
              the assembly unit. There are no arguments. The result is a
              string specifying the date and time of the assembly unit.

        Examples

                     .PRINT "%TIME()"

              After lexical processing, the statement appears as:

                     .PRINT " 8-OCT-1991 13:17:57"




















                                                                     3-21

 



        MACRO-64 Lexical Operators
        %TYPE


        _________________________________________________________________

        %TYPE

              Lexical operator for obtaining information about a name.

        Format

              %TYPE  (name)

        Arguments

              name
              The single argument is of type name. Information is
              returned about the name specified in the argument.

        Description

              %TYPE is modeled after OpenVMS DCL's F$TYPE lexical
              function. %TYPE is used to obtain information about a
              name. The value returned is a numeric value with certain
              bit positions, either zero or one, depending on whether
              the specified name has the corresponding attribute. As
              described elsewhere, he decimal digits of the numeric
              value are substituted for the %TYPE lexical operator.
              Table 3-2 shows the symbolic names that are predefined
              for each attribute:

              Table_3-2_%TYPE_Attributes_________________________________

              Symbolic_Name______________Attribute_______________________

              MACRO64$TYPE_SYMBOL        Name is a numeric symbol name.

              MACRO64$TYPE_PROC_DESC     Name is a procedure descriptor
                                         name.

              MACRO64$TYPE_LABEL         Name is a label.

              MACRO64$TYPE_EXTERN        Name is an external name.

              MACRO64$TYPE_WEAK          Name is a weak name.

              MACRO64$TYPE_PSECT         Name is a psect.

              MACRO64$TYPE_MACRO         Name is a macro name.

                                                 (continued on next page)

        3-22

 



                                               MACRO-64 Lexical Operators
                                                                    %TYPE


              Table_3-2_(Cont.)_%TYPE_Attributes_________________________

              Symbolic_Name______________Attribute_______________________

              MACRO64$TYPE_STRING        Name is a lexical string symbol
                                         name.

              MACRO64$TYPE_OPCODE        Name is an opcode.

              MACRO64$TYPE_DIR           Name is a directive.

              MACRO64$TYPE_GENREG        Name is a general register.

              MACRO64$TYPE_FLTREG________Name_is_a_floating_register.____

              A given name may have zero, one, or several attributes.

        Examples

                     .macro IS_GR ARG
                       .IF equal, %TYPE(ARG) & <MACRO64$TYPE_GENREG>
                        .PRINT "ARG is not a general register"
                       .ENDC
                     .endm IS_GR
                     IS_GR F11

              Initially, the first line of the IS_GR macro expands as the
              following:

                     .IF equal, <%TYPE(F11) & MACRO64$TYPE_GENREG>

              After lexical processing, the statement appears as:

                     .IF equal, <8192 & MACRO64$TYPE_GENREG>

              In this example, 8192 is the attribute value for a floating
              point register. This value could change in subsequent
              releases. Use only the predefined attribute masks described
              in Table 3-2. Since the attribute for a general register
              MACRO64$TYPE_GENREG is 4096, the expression evaluates as
              zero.

                     <8192 & MACRO64$TYPE_GENREG>


                                                                     3-23

 










                                                                        4
        _________________________________________________________________

                                                          Macro Arguments


              By using macros, you can use a single source statement to
              insert a sequence of source statements into a program.

              A macro definition contains the source statements of the
              macro. The macro definition may have formal arguments.
              These formal arguments can be used throughout the sequence
              of source statements within the definition. When the macro
              is called, the formal arguments are replaced by the actual
              arguments within the macro call.

              The macro call is a single source statement consisting of
              the macro name, optionally followed by arguments. When the
              macro is called, the assembler replaces the line containing
              the macro call with the source statements in the macro
              definition. The assembler replaces any occurrences of
              formal arguments in the macro definition with the actual
              arguments specified in the macro call. This process is
              called the macro expansion.

              By default, macro expansions are not printed in the
              assembly listing. To print the macro expansions, you must
              specify the /SHOW=expansions qualifier and argument in the
              command line. Note that the examples of macro expansions
              used in this chapter are listed as they would appear using
              the /SHOW=expansions argument and qualifier.

              Use .SHOW with a symbolic argument of EXPANSIONS in
              the source text of a program to specify the listing of
              expansions.

              MACRO-64 provides specific directives for controlling
              macro execution. For information on these directives, see
              Table 5-2.

              The remainder of this chapter describes macro arguments and
              created temporary labels.

                                                                      4-1

 



        Macro Arguments
        4.1 Using Macro Arguments


        4.1 Using Macro Arguments

              Macros have two types of arguments: actual and formal.
              Actual arguments are the text given in the macro call after
              the name of the macro. Formal arguments are specified by
              name in the macro definition; that is, after the macro name
              in the .MACRO directive. Actual arguments in macro calls
              and formal arguments in macro definitions can be separated
              by commas (,), tabs, or spaces.

              The number of actual arguments in the macro call can be
              less than or equal to the number of formal arguments in
              the macro definition. If the number of actual arguments is
              greater than the number of formal arguments, the assembler
              displays an error message.

              Formal and actual arguments normally maintain a strict
              positional relationship. That is, the first actual argument
              in a macro call replaces all occurrences of the first
              formal argument in the macro definition. This strict
              positional relationship can be overridden by the use of
              keyword arguments. For more information on using keyword
              arguments, see Section 4.3.

              An example of a macro definition using formal arguments
              follows:

              .MACRO  STORE  ARG1,ARG2,ARG3
              .LONG   ARG1                     ; ARG1 is first argument
              .WORD   ARG3                     ; ARG3 is third argument
              .BYTE   ARG2                     ; ARG2 is second argument
              .ENDM   STORE

              The following two examples show possible calls and
              expansions of the macro previously defined:

              STORE   3,2,1                    ; Macro call
              .LONG   3                        ; 3 is first argument
              .WORD   1                        ; 1 is third argument
              .BYTE   2                        ; 2 is second argument

              STORE   X,X-Y,Z                  ; Macro call
              .LONG   X                        ; X is first argument
              .WORD   Z                        ; Z is third argument
              .BYTE   X-Y                      ; X-Y is second argument

        4-2

 



                                                          Macro Arguments
                                                 4.2 Using Default Values


        4.2 Using Default Values

              Default values are values that are defined in the macro
              definition. They are used when no value for a formal
              argument is specified in the macro call.

              Default values are specified in the .MACRO directive as
              follows:

              formal-argument-name = default-value

              An example of a macro definition specifying default values
              follows:

              .MACRO  STORE   ARG1=12,ARG2=0,ARG3=1000
              .LONG   ARG1
              .WORD   ARG3
              .BYTE   ARG2
              .ENDM   STORE

              The following three examples show possible calls and
              expansions of the macro defined previously:

              STORE                   ; No arguments supplied
              .LONG   12
              .WORD   1000
              .BYTE   0

              STORE   ,5,X            ; Last two arguments supplied
              .LONG   12
              .WORD   X
              .BYTE   5

              STORE   1               ; First argument supplied
              .LONG   1
              .WORD   1000
              .BYTE   0

        4.3 Using Keyword Arguments

              Keyword arguments allow a macro call to specify the
              arguments in any order. In this case, the macro call must
              specify the same formal argument names that appear in the
              macro definition. Keyword arguments are useful when a macro
              definition has more formal arguments than necessary in the
              call.

                                                                      4-3

 



        Macro Arguments
        4.3 Using Keyword Arguments


              In any one macro call, it is good practice to specify the
              arguments as either all positional arguments or all keyword
              arguments. For example, the following macro definition
              specifies three arguments:

              .MACRO  STORE   ARG1,ARG2,ARG3
              .LONG   ARG1
              .WORD   ARG3
              .BYTE   ARG2
              .ENDM   STORE

              The following macro call specifies keyword arguments:

              STORE   ARG3=27+5/4,ARG2=5,ARG1=SYMBL
              .LONG   SYMBL
              .WORD   27+5/4
              .BYTE   5

              Because the keywords are specified in the macro call, the
              arguments in the macro call need not be given in the order
              they were listed in the macro definition.

              Positional and keyword arguments may be mixed. Usually,
              positional arguments are placed before keyword arguments:

              .MACRO  STORE   ARG1,ARG2,ARG3=27+5/4
              .LONG   ARG1
              .BYTE   ARG2
              .WORD   27+5/4
              .ENDM   STORE

                ________________________ Note ________________________

                Keyword arguments are not counted when positional
                arguments are parsed. This means that when positional
                and keyword arguments are used in the same macro,
                one argument can be specified twice. The last value
                specified for the argument is used.

                ______________________________________________________





        4-4

 



                                                          Macro Arguments
                                               4.4 Using String Arguments


        4.4 Using String Arguments

              If an actual argument is a string containing characters
              that the assembler interprets as separators (such as a
              tab, space, or comma), the string must be enclosed by
              delimiters. String delimiters for macro arguments are
              usually paired angle brackets (<>). A quoted literal
              enclosed in double quotes ("") is also a valid string
              argument.

              The assembler also interprets any character
              (except A, B, C, D, O, or X) after an initial circumflex
              (^) as a delimiter. Note that ^B, ^D, ^O, and ^X are used
              as radix control operators rather than argument delimiters.
              ^A is used as the ASCII operator and ^C is used as the
              complement operator. To pass an angle bracket as part of a
              string, you can use the circumflex form of the delimiter.

              The following are examples of delimited macro arguments:

              <HAVE THE SUPPLIES RUN OUT?>
              <LAB:    CLR     R4>

              "A quoted literal is taken as a single parameter value."

              ^%ARGUMENT IS <LAST,FIRST> FOR CALL%
              ^?EXPRESSION IS <5+3>*<4+2>?

              In the last two examples, the initial circumflex indicates
              that the percent sign (%) and question mark (?)  are the
              delimiters. Note that only the left-hand delimiter is
              preceded by a circumflex.

              The assembler interprets a string argument enclosed by
              delimiters as one actual argument and associates it with
              one formal argument. If a string argument that contains
              separator characters is not enclosed by delimiters, the
              assembler interprets it as successive actual arguments and
              associates it with successive formal arguments.

              For example, the following macro definition has one formal
              argument:

              .MACRO DOUBLE_ASCII STRNG
              .ASCII  "STRNG"
              .ASCII  "STRNG"
              .ENDM   DOUBLE_ASCII

                                                                      4-5

 



        Macro Arguments
        4.4 Using String Arguments


              The following two macro calls demonstrate actual arguments
              with and without delimiters:

              DOUBLE_ASCII <A B C D E>
              .ASCII  "A B C D E"
              .ASCII  "A B C D E"

              DOUBLE_ASCII  A B C D E
              %MACRO64-E-TOOMNYARGS, Too many arguments in macro call

              Note that the assembler interprets the second macro call as
              having five actual arguments instead of one actual argument
              with spaces.

              When a macro is called, the assembler removes normal
              delimiters around a string before associating it with the
              formal arguments. However, a quoted literal within double
              quotes is treated as a single token and retains its double
              quote delimiters.

              If a string contains a semicolon (;), the string must be
              enclosed by delimiters, otherwise the semicolon will mark
              the start of the comment field. Further, if the string
              contains a semicolon, you cannot continue the line unless
              the string is a quoted literal.

              Macro invocations can be nested, that is, a macro
              definition can contain a call to another macro. If, within
              a macro definition, another macro is called and is passed
              a string argument, you must delimit the argument so that
              the entire string is passed to the second macro as one
              argument.

              The following macro definition contains a call to the
              DOUBLE_ASCII macro defined earlier:

                      .MACRO   CNTDA LAB1,LAB2,STR_ARG
              LAB1:   .BYTE    LAB2-LAB1-1            ; Length of 2*string
                      DOUBLE_ASCII   <STR_ARG>        ; Call DOUBLE_ASCII macro
              LAB2:
                      .ENDM    CNTDA

              Note that the argument in the call to DOUBLE_ASCII is
              enclosed in angle brackets even though it does not contain
              any separator characters. The argument is thus delimited
              because it is a formal argument in the definition of the
              macro CNTDA and will be replaced with an actual argument
              that may contain separator characters.

        4-6

 



                                                          Macro Arguments
                                               4.4 Using String Arguments


              The following example calls the macro CNTDA, which in turn
              calls the macro DOUBLE_ASCII:

              CNTDA  ST,FIN,<LEARN YOUR ABC'S>
              ST:     .BYTE   FIN-ST-1
                      DOUBLE_ASCII <LEARN YOUR ABC'S>
                      .ASCII  "LEARN YOUR ABC'S"
                      .ASCII  "LEARN YOUR ABC'S"
              FIN:

              In addition to nested macro invocations, you can
              also nest macro definitions. That is, you can define
              one macro within another. In this example, the
              INNER_MACRO_DEF macro is not defined until the
              OUTER_MACRO_DEF macro is invoked and expanded:

                      .macro OUTER_MACRO_DEF
                          .macro INNER_MACRO_DEF
                              ...
                          .endm INNER_MACRO_DEF
                      .endm OUTER_MACRO_DEF

              You can use this capability to define a macro that
              redefines itself:

                      .macro SETUP
                          A = 75
                          B = 92
                          C = 87
                          D = 0
                          E = -12
                          F = 42
                          .macro SETUP
                              ; Setup is done - do nothing
                          .endm SETUP
                      .endm SETUP

              In this example, the SETUP macro defines a number of
              assembly constants. After the SETUP macro has been expanded
              once, its work is done. Subsequent expansions of the setup
              macro need not take any action. Therefore, the SETUP macro
              redefines itself to a macro whose expansion includes only
              a comment statement. As described elsewhere, when you
              redefine a macro, the original version of the macro is
              automatically deleted. If that macro is currently expanding
              (as would be the case with the SETUP macro above), the new
              definition is immediately associated with the macro name.

                                                                      4-7

 



        Macro Arguments
        4.4 Using String Arguments


              However, the old definition is retained until all pending
              expansions complete normally. When all pending expansions
              complete, the old version of the macro is deleted. Thus,
              the SETUP macro may be invoked any number of times in the
              assembly unit. Since the first expansion redefines itself,
              the expansion of the SETUP macro has no effect other than
              the first time it is invoked.

              Another way to pass string arguments in nested macros is to
              enclose the macro argument in nested delimiters.

                ________________________ NOTE ________________________

                Each time you use the delimited argument in a macro
                call, the assembler removes the outermost pair of
                delimiters before associating it with the formal
                argument. This method is not recommended because it
                requires that you know how deeply a macro is nested.

                ______________________________________________________

              The following macro definition also contains a call to the
              DOUBLE_ASCII macro:

                     .MACRO  CNTDA2 LAB1,LAB2,STR_ARG
              LAB1:  .BYTE   LAB2-LAB1-1             ; Length of 2*string
                     DOUBLE_ASCII  STR_ARG           ; Call DOUBLE_ASCII macro
              LAB2:
                     .ENDM   CNTDA2

              Note that the argument in the call to DOUBLE_ASCII is not
              enclosed in angle brackets.

              The following example calls the macro CNTDA2:

                     CNTDA2 BEG,TERM,<<MIND YOUR P'S AND Q'S>>
              BEG:   .BYTE   TERM-BEG-1              ; Length of 2*string
                     DOUBLE_ASCII  <MIND YOUR P'S AND Q'S> ; Call DOUBLE_ASCII macro
                     .ASCII  "MIND YOUR P'S AND Q'S"
                     .ASCII  "MIND YOUR P'S AND Q'S"
              TERM:

              Note that even though the call to DOUBLE_ASCII in the macro
              definition is not enclosed in delimiters, the call in the
              expansion is enclosed because the call to CNTDA2 contains
              nested delimiters around the string argument.

        4-8

 



                                                          Macro Arguments
                                               4.5 Argument Concatenation


        4.5 Argument Concatenation

              The argument concatenation operator, the apostrophe ('),
              concatenates a macro argument with constant text or another
              argument. Apostrophes can either precede or follow a formal
              argument name in the macro source.

              If an apostrophe precedes the argument name, the text
              before the apostrophe is concatenated with the actual
              argument when the macro is expanded. For example, if ARG1
              is a formal argument associated with the actual argument
              TEST, then ABCDE'ARG1 is expanded to ABCDETEST.

              If an apostrophe follows the formal argument name, the
              actual argument is concatenated with the text that follows
              the apostrophe when the macro is expanded. The apostrophe
              itself does not appear in the macro expansion.

              To concatenate two arguments, separate the two formal
              arguments with two successive apostrophes. Two apostrophes
              are needed because each concatenation operation discards an
              apostrophe from the expansion.

              An example of a macro definition that uses concatenation
              follows:

                      .MACRO CONCAT   A,B
              A''B:   .WORD 0
                      .ENDM CONCAT

              Note that two successive apostrophes are used when
              concatenating the two formal arguments A and B.

              An example of a macro call and expansion follows:

                      CONCAT  X,Y
              XY:     .WORD 0

        4.6 Passing Numeric Values of Symbols

              When a symbol is specified as an actual argument, the name
              of the symbol, not the numeric value of the symbol, is
              passed to the macro. The value of the symbol can be passed
              by inserting a backslash (\) before the symbol in the macro
              call. The assembler passes the characters representing the
              decimal value of the symbol to the macro. For example, if
              the symbol COUNT has a value of 2 and the actual argument

                                                                      4-9

 



        Macro Arguments
        4.6 Passing Numeric Values of Symbols


              specified is \COUNT, the assembler passes the string 2 to
              the macro; it does not pass the name of the symbol, COUNT.

              Passing numeric values of symbols is especially useful with
              the apostrophe (') concatenation operator for creating new
              symbols.

              An example of a macro definition for passing numeric values
              of symbols follows:

                      .MACRO WORD n
              WORD'n: .WORD n
                      .ENDM WORD

              The following example shows a possible call and expansion
              of the macro previously defined:

                     X = 1       ; Start counting at 1
                     WORD \X
              WORD1: .WORD 1

        4.7 Using Created Temporary Labels

              Temporary labels are often very useful in macros. Although
              you can create a macro definition that specifies temporary
              labels within it, these temporary labels might be
              duplicated elsewhere in the temporary label block, possibly
              causing errors. However, the assembler can create temporary
              labels in the macro expansion that will not conflict with
              other temporary labels. These labels are called created
              temporary labels.

              Created temporary labels range from 30000$ to 65535$.
              Each time the assembler creates a new temporary label,
              it increments the numeric part of the label name by 1.
              Consequently, no user-defined temporary labels should be in
              the range of 30000$ to 65535$.

              A created temporary label is specified by a question mark
              (?) in front of the formal argument name. When the macro
              is expanded, the assembler creates a new temporary label
              if the corresponding actual argument is blank. If the
              corresponding actual argument is specified, the assembler
              substitutes the actual argument for the formal argument.

        4-10

 



                                                          Macro Arguments
                                       4.7 Using Created Temporary Labels


              The following example is a macro definition specifying a
              created temporary label:

                      .MACRO  POSITIVE        ARG1,?L1
                      BGE     ARG1,L1
                      NEGQ    ARG1,ARG1
              L1:    .ENDM    POSITIVE

              The following three calls and expansions of the macro
              defined previously show both created temporary labels and a
              user-defined temporary label:

                      POSITIVE  R0
                      BGE     R0,30000$
                      NEGQ    R0,R0
              30000$:

                      POSITIVE  R5
                      BGE     R5,30001$
                      NEGQ    R5,R5
              30001$:

                      POSITIVE  R7,10$
                      BGE     R7,10$
                      NEGQ    R7,R7
              10$:

              For more information on temporary labels, see Section 2.6.

















                                                                     4-11

 










                                                                        5
        _________________________________________________________________

                                            MACRO-64 Assembler Directives


              MACRO-64 directives enable you to control certain
              aspects of the assembly process. This chapter describes
              the MACRO-64 assembler directives. It describes the
              various functional categories of directives, as well as
              a detailed description of each directive. It also discusses
              the effects of automatic data alignment on assembler
              directives.

        5.1 Program Sections (Psects)

              MACRO-64 allows you to divide your program into sections
              called psects using the .PSECT directive. Psects are useful
              for organizing your program, and for low-level control over
              the linking process. More importantly, each psect falls
              into one of the following three categories:

              o  CODE psects can contain only instructions. It contains
                 no data. Psects in this category have the EXE and NOMIX
                 psect attributes.

              o  DATA psects can contain only data. It contains no
                 instructions. Psects in this category have the NOEXE
                 and NOMIX attributes.

              o  MIXED psects can contain instructions or data, or
                 both. Psects in this category have the MIX attribute.
                 In addition, they may have either the EXE or NOEXE
                 attribute.

              MACRO-64 categorizes psects because:

              o  There is a significant performance compromise associated
                 with mixing instructions and data in the same program
                 section within the Alpha AXP architecture. This is
                 because the Alpha AXP architecture typically maintains
                 separate memory caches for instructions and data.

                                                                      5-1

 



        MACRO-64 Assembler Directives
        5.1 Program Sections (Psects)


              o  If you mix instructions and data, it is likely that
                 instructions will migrate into the data cache and that
                 data will migrate into the instruction cache. While this
                 situation still yields correct results, the benefits
                 of the instruction and data caches are diminished.
                 Placing data in the instruction stream can also have
                 detrimental effects on the instruction pipeline and the
                 multiple instruction-issue capabilities that most Alpha
                 AXP systems employ.

              Since a code psect can contain only instructions and cannot
              contain arbitrary data, instructions you place in a CODE
              psect can be analyzed by the assembler optimizer and by
              the symbolic debugger. Since a mixed psect can contain
              arbitrary data as well as instructions, instructions you
              place in a mixed psect are not analyzed by the assembler
              optimizer or by the symbolic debugger. Instead, the
              assembler internally converts instructions in a mixed psect
              to an equivalent data representation.

              Because of the compromises associated with mixed psects, by
              default the assembler creates psects with the NOMIX psect
              attribute. If you need to place data in a psect that has
              the EXE attribute, or if you need to place instructions in
              a psect that has the NOEXE attribute, you must also specify
              the MIX attribute in the psect's definition. Note that
              unlike the other psect attributs, the MIX psect attribute
              is an assembly-time attribute. The MIX psect attribute does
              not appear in the psect definitions in your object module
              and it does not affect the linking process.

              All assembler directives and instructions can be used
              within mixed psects. While many assembler directives can
              be used within both code and data psects, data storage
              directives cannot be used in code psects and instructions
              and instruction storage directives cannot be used in
              data psects. If you place instructions or instruction
              storage directives in a data psect, or if you place data
              storage directives in a code psect, the assembler issues a
              diagnostic message. Section 5.3 indicates the applicibilty
              of each directive within code and data psects.




        5-2

 



                                            MACRO-64 Assembler Directives
                                            5.1 Program Sections (Psects)


              In summary, code psects may contain only storage for
              instructions and storage created by instruction directives.
              Data psects may contain only storage created by data
              directives. Mixed psects may contain either storage for
              instructions or data or both. There are no restrictions
              on the use of data directives in a mixed psect. However,
              the assembler converts instructions you place in a mixed
              psect to a data representation. Therefore, instructions in
              a mixed psect are not analyzed as instructions by either
              the assembler optimizer or the symbolic debugger. For more
              infomation on the .PSECT directive, see Section 5.3.

        5.2 Automatic Data Alignment

              The assembler can optionally align your data on natural
              boundaries. While disabled by default, this feature is
              enabled with the /ALIGNMENT=data command line qualifier
              or the .ENABLE ALIGN_DATA directive (see Section 1.2 and
              Section 5.3. A natural boundary is an address that is
              evenly divisibly by the size of the scalar data type being
              accessed. The MACRO-64 automatic data alignment feature can
              automatically align word, longword, quadword, and octaword
              data to a natural boundary. Accessing data on a natural
              boundary can be significantly faster than an unaligned
              access. For more information on accessing data on aligned
              and unaligned boundaries, refer to the Alpha Architecture
              Reference Manual.

              When the MACRO-64 automatic data alignment feature is
              enabled, the assembler automatically aligns all data
              storage directives to a natural boundary. To acheive
              alignment, the assembler pads with zero bytes as necessary
              prior to allocating the storage for the data directive.
              Labels that occur before the data storage directive
              are defined to be the address of the data storage after
              alignment. For more information, see Section 2.7.1. The
              directive descriptions in Section 5.3 indicate those data
              storage directives that are affected by automatic data
              alignment.






                                                                      5-3

 



        MACRO-64 Assembler Directives
        5.3 Directives


        5.3 Directives

              The general assembler directives provide facilities for
              performing eleven types of functions. Table 5-1 lists these
              types of functions and their directives. Some directives
              are only applicable within data psects (psects with the
              NOEXE and NOMIX attributes). Other directives are only
              applicable within code psects (psects with the EXE and
              NOMIX attributes). All directives are applicable within
              psects which contain either data and code, or both (psects
              with the MIX attribute). For information on the MIX
              assembly-time psect and any associated restrictions, see
              the description of the .PSECT directive in this chapter.

              Table 5-1 shows how each directive can be applied within
              data or code psects.

              Table_5-1_Summary_of_General_Assembler_Directives__________

              Category____________Directives[1]_________Psect_Application

              Listing control     .TITLE                All
              directives          .SUBTITLE (.SBTTL)
                                  .IDENT
                                  .LIST
                                  .NLIST
                                  .SHOW
                                  .NOSHOW
                                  .PAGE

              Message display     .PRINT                All
              directives          .WARN
                                  .ERROR

              Assembler option    .ENABLE (.ENABL)      All
              directives          .DISABLE (.DSABL)

              [1]The_alternate_form,_if_any,_is_given_in_parentheses.____

                                                 (continued on next page)





        5-4

 



                                            MACRO-64 Assembler Directives
                                                           5.3 Directives


              Table_5-1_(Cont.)_Summary_of_General_Assembler_Directives__

              Category____________Directives[1]_________Psect_Application

              Data storage        .BYTE                 NOEXE (or MIX)
              directives          .WORD
                                  .SIGNED_BYTE
                                  .SIGNED_WORD
                                  .LONG
                                  .ADDRESS
                                  .CODE_ADDRESS
                                  .LOCAL_CODE_ADDRESS
                                  .OCTA
                                  .QUAD
                                  .ASCII
                                  .ASCIC
                                  .ASCID
                                  .ASCIZ
                                  .F_FLOATING (.FLOAT)
                                  .D_FLOATING
                                  (.DOUBLE)
                                  .G_FLOATING
                                  .S_FLOATING
                                  .T_FLOATING

                                  .INSTRUCTION          EXE (or MIX)

              Location control    .ALIGN                All
              directives          .BEGIN_EXACT
                                  .END_EXACT

              [1]The_alternate_form,_if_any,_is_given_in_parentheses.____

                                                 (continued on next page)











                                                                      5-5

 



        MACRO-64 Assembler Directives
        5.3 Directives


              Table_5-1_(Cont.)_Summary_of_General_Assembler_Directives__

              Category____________Directives[1]_________Psect_Application

                                                        NOEXE (or MIX)
                                  .EVEN
                                  .ODD
                                  .BLKA
                                  .BLKB
                                  .BLKD
                                  .BLKF
                                  .BLKG
                                  .BLKL
                                  .BLKO
                                  .BLKQ
                                  .BLKS
                                  .BLKT
                                  .BLKW

              Program sectioning  .PSECT                All
              directives          .SAVE_PSECT (.SAVE)
                                  .RESTORE_PSECT
                                  (.RESTORE)

              Symbol control      .EXTERNAL (.EXTRN)    All
              directives          .WEAK

              Conditional         .IF                   All
              assembly block      .IF_FALSE (.IFF)
              directives          .ENDC
                                  .ELSE
                                  .IF_TRUE (.IFT)
                                  .IF_TRUE_FALSE
                                  (.IFTF)
                                  .IIF

              Source inclusion    .INCLUDE              All

              [1]The_alternate_form,_if_any,_is_given_in_parentheses.____

                                                 (continued on next page)




        5-6

 



                                            MACRO-64 Assembler Directives
                                                           5.3 Directives


              Table_5-1_(Cont.)_Summary_of_General_Assembler_Directives__

              Category____________Directives[1]_________Psect_Application

              Linkage control     .BASE                 All
                                  .END                  All
                                  .LINKAGE_PAIR         NOEXE (or MIX)
                                  .LOCAL_LINKAGE_PAIR   NOEXE (or MIX)
                                  .PROCEDURE_
                                  DESCRIPTOR
                                  .LOCAL_PROCEDURE_
              [1]The_alternate_form,SifIany,_is_given_in_parentheses.____

              ___________________________________________________________

              The macro directives provide facilities for performing five
              categories of functions. Table 5-2 lists these categories
              and their associated directives. See Chapter 4 for detailed
              information on macro arguments and string operators.

              Table_5-2_Summary_of_Macro_Directives______________________

                                                   Application in EXE
              Category_________Directives[1]_______or_NOEXE_Psects_______

              Macro            .MACRO              All
              definition       .ENDM
              directives       .LIBRARY
                               .MCALL

              Macro deletion   .MDELETE            All
              directive

              Macro exit       .MEXIT              All
              directive

              Repeat block     .REPEAT (.REPT)     All
              directives       .IRP
                               .IRPC
                               .ENDR

              Counting         .NARG               All
              directive        .NCHR
              [1]The_alternate_form,_if_any,_is_given_in_parentheses.____

              ___________________________________________________________

              The remainder of this chapter describes both the general
              assembler directives and the macro directives, showing
              their formats and giving examples of their use. For ease

                                                                      5-7

 



        MACRO-64 Assembler Directives
        5.3 Directives


              of reference, the directives are presented in alphabetical
              order.











































        5-8

 



                                                     Assembler Directives
                                                                 .ADDRESS


        _________________________________________________________________

        .ADDRESS

              Address storage directive

        Format

              .ADDRESS  address-list

        Parameters

              address-list
              A list of symbols or expressions, separated by commas (,),
              which MACRO-64 interprets as addresses.

        Description

              .ADDRESS stores successive quadwords (8 bytes) containing
              addresses in the object module. Digital recommends that you
              use .ADDRESS rather than .QUAD for storing address data to
              provide additional information to the linker.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current (64-bit) boundary before allocating
                 storage.

              o  You can define a 32-bit address item using macros and
                 the .LONG directive. For example:

                 .macro address_32 item
                     .long item
                 .endm address_32

        Examples

                .ADDRESS A,B,C


                                                                      5-9

 



        Assembler Directives
        .ALIGN


        _________________________________________________________________

        .ALIGN

              Location counter alignment directive

        Format

              .ALIGN  integer [,fill-specifier]

              .ALIGN  keyword [,fill-specifier]

        Parameters

              integer
              An integer in the range 0 to 9. The location counter is
              aligned at an address that is the value of 2 raised to the
              power of the integer.

              keyword
              One of five keywords that specify the alignment boundary.
              The location counter is aligned to an address that is the
              next multiple of the following values:

              ___________________________________________________________
              Keyword___Size_(in_Bytes)__________________________________

              BYTE      20= 1

              WORD      21= 2

              LONG      22= 4

              QUAD      23= 8

              OCTA      24= 16
              ___________________________________________________________

              [,fill-specifier]
              Any expression that resolves to an assembly time integer
              value containing no forward references. The filling is done
              per byte, regardless of the alignment.

        Description

              .ALIGN aligns the location counter to the boundary
              specified by either an integer or a keyword.

        5-10

 



                                                     Assembler Directives
                                                                   .ALIGN



        Notes

              o  If .ALIGN is specified in a psect with the EXE and NOMIX
                 attributes, the fill specifier is ignored. The assembler
                 aligns the psect to the requested boundary padding with
                 NOP or FNOP instructions.

              o  If .ALIGN is specified in a psect that does not have
                 the EXE attribute and a fill_specifier is specified,
                 the assembler aligns the psect to the requested boundary
                 padding, with byte locations using the fill-specifier as
                 the initial value for the generated byte padding.

              o  If the fill specifier expression encounters a value
                 that is too large to fit in a boundary specified by
                 the keyword, the data is truncated and an informational
                 message is displayed.

              o  The alignment that you specify in .ALIGN cannot exceed
                 the alignment of the program section in which the
                 alignment is attempted (see the description of .PSECT).
                 For example, if you are using the BYTE program section
                 alignment and you specify .ALIGN with a word or larger
                 alignment, the assembler displays an error message.

        Examples

                 Example 1

                   .PSECT A,QUAD  ; Begin at quadword
                B::.BYTE 4        ; Data is byte
                   .ALIGN QUAD    ; Next data is
                C::.WORD 6        ; also quadword aligned

                 Example 2

                   .PSECT A,EXE,NOMIX,OCTA
                L1::TRAPB:        ; offset 0
                   .ALIGN OCTA    ; NOP padding bytes 4..15
                    TRAPB:         ; offset 16




                                                                     5-11

 



        Assembler Directives
        .ALIGN


                 Example 3

                   .PSECT A,NOEXE,NOMIX,OCTA
                L1:.WORD 5        ; byte offset 0..1
                   .ALIGN QUAD,2  ; fill specifier initial value
                                  ; of 2 for bytes 2..7
                   .WORD 6        ; byte offsets 8..9






































        5-12

 



                                                     Assembler Directives
                                                                   .ASCIC


        _________________________________________________________________

        .ASCIC

              Counted ASCII string storage directive

        Format

              .ASCIC  quoted-literal

        Parameters

              quoted-literal
              An ASCII string delimited with double quotes.

        Description

              .ASCIC performs the same function as .ASCII, except that
              .ASCIC inserts a count byte before the string data. The
              count byte contains the length of the string in bytes. The
              length given includes any bytes of non-printable characters
              specified using the backslash (\) operator, but excludes
              the count byte. See Section 2.4 for a description of how to
              specify quoted literals.

              .ASCIC is useful in copying text because the count
              indicates the length of the text to be copied.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                .ASCIC "MY STRING"  ; In the listing, this becomes:
                                    ; .BYTE 9
                                    ; .ASCII \MY STRING\


                                                                     5-13

 



        Assembler Directives
        .ASCID


        _________________________________________________________________

        .ASCID

              String-descriptor ASCII string storage directive

        Format

              .ASCID  quoted-literal

        Parameters

              quoted-literal
              A ASCII string delimited with double quotes. For more
              information on how to specify quoted literals, see
              Section 2.4.

        Description

              .ASCID performs the same function as the .ASCII directive,
              except that .ASCID inserts a string descriptor before
              the string data. The descriptor format is identical to
              that defined for OpenVMS AXP and OpenVMS VAX. The string
              descriptor has the following format:

                        +---------------+------------+
                        |  Information  |   Length   |
                        +---------------+------------+
                        |          Pointer           |
                        +----------------------------+

        Notes

              o  The string-length field is two bytes in size.

              o  Descriptor information (2 bytes) is always set to
                 ^X010E.

              o  Position-independent 32-bit pointer to the string (4
                 bytes). String descriptors are used in calling certain
                 system routines.

              o  If natural alignment is enabled (using .ENABLE ALIGN_
                 DATA), the descriptor is quadword aligned. This allows
                 you to access the entire descriptor (2 data words and a
                 longword address) on a quadword alignment.

        5-14

 



                                                     Assembler Directives
                                                                   .ASCID


              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                 Example 1

                .DESCR1:   .ASCID "ARGUMENT FOR CALL"     ; String descriptor

                 Example 2

                .DESCR2:   .ASCID "SECOND ARGUMENT"       ; Another string descriptor




























                                                                     5-15

 



        Assembler Directives
        .ASCII


        _________________________________________________________________

        .ASCII

              ASCII string storage directive

        Format

              .ASCII  quoted-literal

        Parameters

              quoted-literal
              An ASCII string delimited with double quotes.

        Description

              .ASCII stores the ASCII value of each character in the
              ASCII string or the value of each byte expression in the
              next available byte. See Section 2.4 for a description of
              how to specify quoted literals.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                .ASCII "MY STRING"










        5-16

 



                                                     Assembler Directives
                                                                   .ASCIZ


        _________________________________________________________________

        .ASCIZ

              Zero-terminated ASCII string storage directive

        Format

              .ASCIZ  quoted-literal

        Parameters

              quoted-literal
              An ASCII string delimited with double quotes.

        Description

              .ASCIZ performs the same function as .ASCII, except that
              .ASCIZ appends a null byte as the final character of the
              string. When a list or text string is created with an
              .ASCIZ directive, you need only perform a search for the
              null character in the last byte to determine the end of the
              string. See Section 2.4 for a description of how to specify
              quoted literals.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                .ASCIZ "MY STRING"    ; Equivalent to
                                      ; .ASCII "MY STRING \x00"






                                                                     5-17

 



        Assembler Directives
        .BASE


        _________________________________________________________________

        .BASE

              Base register directive

        Format

              .BASE  Rn [,base_expression]

        Parameters

              Rn
              One of the base registers, R0 through R30, FP, and SP.

              base_expression
              The base address, which is optional, and can be one of the
              following:

              o  An absolute expression

              o  A relocatable expression

              o  An external expression

              An expression must not contain forward references or
              implicit external symbols. An implicitly defined external
              symbol is a symbol that the assembler defaults to an
              external symbol. This occurs when the assembler encounters
              references to a symbol, but does not encounter a definition
              for the symbol or an .EXTERNAL directive that declares the
              symbol.

        Description

              The .BASE directive is used to inform the assembler that
              a specified base register contains a specified base
              address. Later in your program, the assembler allows you
              to implicitly reference the specified base register. When
              the assembler knows which base addresses are stored in one
              or more base registers, it can convert an expression to an
              offset from one of the base registers previously specified
              in a .BASE directive. .BASE provides a convenient and more
              readable short hand for accessing memory and constant
              values using base registers. .BASE also makes it easier
              for you to change your register assignments if you later
              modify your code.

        5-18

 



                                                     Assembler Directives
                                                                    .BASE


              The base expression is optional. If the base expression
              is specified, this base address value is assumed by the
              assembler to be in the specified register, Rn. If the base
              expression is omitted, the contents of the specified base
              register, Rn, is considered undefined until a new base
              expression is associated with the base register.

              R31 is defined to always contain zero, according to the
              architecture definition. Therefore, R31 is known to be
              a predefined base register containing zero. For every
              assembly, the assembler assumes the following statement:

                  .BASE R31, 0

              Because the contents of R31 cannot change, you cannot
              specify a base address for R31.

              You can use the .BASE directive to implicitly reference
              base registers. You can also automatically compute offsets
              from a base address known to be in a register to a base
              address you use in an instruction argument.

              Most of the memory format Alpha AXP instructions are
              defined such that one of their arguments must have a base
              register and an offset. If the assembler encounters only
              an expression with no base register, the assembler attempts
              to find a base register that contains a base address or
              constant within a 16-bit signed offset of the value of the
              expression. If it finds such a base register, the assembler
              computes an offset that when added to the value of the
              base register, results in a value equal to the expression
              specified in the instruction argument.













                                                                     5-19

 



        Assembler Directives
        .BASE



        Examples

                 Example 1

                .EXTERNAL COMM_AREA       1
                .BASE R1, COMM_AREA       2
                CURR_LINE       = COMM_AREA + 0
                CURR_COLUMN     = COMM_AREA + 4
                CURR_MODE       = COMM_AREA + 8
                LDA     R4, 17                  ; LDA R4, 17(R31)  3
                LDL     R2, CURR_LINE           ; LDL R2, 0(R1)    4
                LDL     R3, CURR_COLUMN         ; LDL R3, 4(R1)
                STL     R4, CURR_MODE           ; STL R4, 8(R1)

                 1  This statement declares an external symbol,
                    COMM_AREA. COMM_AREA is a global symbol that
                    represents the base address of a three-longword
                    communication area that is used by different routines
                    in the program.

                 2  This statement informs the assembler that base
                    register R1 contains the base address, COMM_AREA,
                    of this communication area. The next three statements
                    define variables within the communication area.

                 3  The first instruction shows how you can load
                    registers with constant values in the range -32768 to
                    +32767 by implicitly using R31 as the base register.

                 4  The last three statements show how the .BASE
                    directive allows you to implicitly reference base
                    registers and automatically compute offsets. In each
                    of these instructions, the second argument is defined
                    to require an offset and a base register.

                    Since no base register is specified, the assembler
                    attempts to imply the base register and compute the
                    offset based upon information given in previous .BASE
                    directives.

                    In the last three instructions, the address argument
                    is within -327678 to +32767 of the base address
                    known to be in R1 (i.e., COMM_AREA). Therefore, R1
                    is selected as the base register. The assembler also
                    computes the correct offset from the base address
                    known to be in R1 to the address specified in the
                    instruction argument.

        5-20

 



                                                     Assembler Directives
                                                                    .BASE


                 Example 2

                 The assembler performs a sequential search through the
                 list of possible base registers, R0 through R31. It uses
                 the first definition possible if multiple base registers
                 are valid. For example:

                     .BASE R5, 300
                     :
                     LDQ  R10, 100

                 The assembler outputs the LDQ instruction as follows:

                     LDQ  R10, -200(R5)

                 Both R31 and R5 are defined as base registers that can
                 be used in constructing the instruction argument. R31
                 always contains zero. In this example, R5 is also known
                 to contain the constant 300. The assembler uses the
                 first base register, starting at R0 and progressing
                 to R31, which provides a known value within -32768
                 to +32767 of the specified argument value. Since the
                 assembler considers R5 before it considers R31, R5 is
                 used rather than R31.





















                                                                     5-21

 



        Assembler Directives
        .BEGIN_EXACT


        _________________________________________________________________

        .BEGIN_EXACT

              Exact instruction block directive

        Format

              .BEGIN_EXACT

        Description

              An exact instruction block suppresses code optimizations
              (SCHEDULE, PEEPHOLE, ALIGN_CODE, and ALIGN_DATA).
              regardless if these optimizations are enabled for the
              assembly unit. Unlike .ENABLE and .DISABLE, which can be
              used to enable or disable specific optimizations for the
              entire assembly unit, .BEGIN_EXACT and .END_EXACT allow
              you to suppress optimization for a specified range of
              instructions. Instructions outside the specified range
              remain subject to any optimizations you have enabled.

        Notes

              o  This directive cannot appear in a psect with the NOEXE
                 and NOMIX attributes.

              o  Although this directive is accepted by the assembler
                 in a psect with the MIX attribute, it has no effect in
                 these psects since no code optimizations are in affect
                 for MIX psects.

              o  .BEGIN_EXACT must be paired with a matching .END_EXACT
                 to close the exact instruction block.

              o  .BEGIN_EXACT and .END_EXACT instruction blocks can be
                 nested. The outermost level of the .BEGIN_EXACT and
                 matching .END_EXACT directives delimit the actual
                 exact instruction block from which code optimizations
                 are suppressed. Nesting .BEGIN_EXACT and .END_EXACT
                 instruction blocks can be useful in macro definitions
                 where the macro expansion requires an exact instruction
                 sequence. Nested .BEGIN_EXACT and .END_EXACT instruction
                 blocks allow a macro to be invoked both from within and
                 without the exact instruction block.

        5-22

 



                                                     Assembler Directives
                                                             .BEGIN_EXACT



        Examples

              The following example shows an instruction sequence prior
              to optimization:

                     addf f7, f8, f9     ; 1
                     addf f2, f3, f4     ; 2
                     addl r5, r6, r7     ; 3
                     addl r8, r9, r10    ; 4

              The assembler optimizes the previous example to a sequence
              similar to the following instruction sequence:

                             :
                     addf f7, f8, f9     ; 1
                     addl r5, r6, r7     ; 3
                     addf f2, f3, f4     ; 2
                     addl r8, r9, r10    ; 4
                             :

              If you choose to suppress optimization in the previous
              example, enclose the four instructions with the
              .BEGIN_EXACT and .END_EXACT directives, as shown in the
              following example:

                     .BEGIN_EXACT
                     addf f7, f8, f9     ; 1
                     addf f2, f3, f4     ; 2
                     addl r5, r6, r7     ; 3
                     addl r8, r9, r10    ; 4
                     .END_EXACT













                                                                     5-23

 



        Assembler Directives
        .BLKx


        _________________________________________________________________

        .BLKx

              Block storage allocation directives

        Format

              .BLKA  [expression]

              .BLKB  [expression]

              .BLKD  [expression]

              .BLKF  [expression]

              .BLKG  [expression]

              .BLKL  [expression]

              .BLKO  [expression]

              .BLKQ  [expression]

              .BLKS  [expression]

              .BLKT  [expression]

              .BLKW  [expression]

        Parameters

              expression
              An integer expression specifying the amount of storage
              to be allocated. All the symbols in the expression must
              be defined at the current point in the assembly and
              the expression must be an absolute expression. If the
              expression is omitted, a default value of 1 is assumed.

        Description

              MACRO-64 has the following 11 block storage directives:

              ___________________________________________________________
              DirectiveReserves_Storage_for:______Bytes_Allocated________

              .BLKA    Addresses (quadwords)      8 * value of expression

              .BLKB    Byte data                  Value of expression

        5-24

 



                                                     Assembler Directives
                                                                    .BLKx

              ___________________________________________________________
              DirectiveReserves_Storage_for:______Bytes_Allocated________

              .BLKD    Double-precision           8 * value of expression
                       floating-point data
                       (quadwords)

              .BLKF    Single-precision           4 * value of expression
                       floating-point data
                       (longwords)

              .BLKG    G_floating data            8 * value of expression
                       (quadwords)

              .BLKL    Longword data              4 * value of expression

              .BLKO    Octaword data              16 * value of
                                                  expression

              .BLKQ    Quadword data              8 * value of expression

              .BLKS    S_floating data            4 * value of expression
                       (longwords)

              .BLKT    T_floating data            8 * value of expression
                       (quadwords)

              .BLKW____Word_data__________________2_*_value_of_expression

              Each directive reserves storage for a different data type.
              The value of the expression determines the number of data
              items for which MACRO-64 reserves storage. For example,
              .BLKL 4 reserves storage for 4 longwords of data and .BLKB
              2 reserves storage for 2 bytes of data. The total number
              of bytes reserved is equal to the length of the data type
              times the value of the expression.

        Notes

              o  If automatic data alignment is enabled, the .BLKx
                 directives align the current location counter to one
                 of the alignments listed in the following table:




                                                                     5-25

 



        Assembler Directives
        .BLKx

                 ________________________________________________________
                 DirectivAlignment_______________________________________

                 .BLKA   Quadword (64-bit) boundary

                 .BLKB   None

                 .BLKD   Quadword (64-bit) boundary

                 .BLKF   Longword (32-bit) boundary

                 .BLKG   Quadword (64-bit) boundary

                 .BLKL   Longword (32-bit) boundary

                 .BLKO   Octaword (128-bit) boundary

                 .BLKQ   Quadword (64-bit) boundary

                 .BLKS   Longword (32-bit) boundary

                 .BLKT   Quadword (64-bit) boundary

                 .BLKW___Word_(16-bit)_boundary__________________________

              o  These directives can only be used within psects having
                 either the NOEXE or MIX attributes. For more information
                 on psects, see Section 5.1.

        Examples

                    .PSECT A,NOEXE
                B:: .BLKW  10             ; 10 words (20 bytes) of storage
                    .BLKQ   5             ; 5 quadwords (40 bytes) of storage

                    .BLKW                 ; 1 word (2 bytes) of storage










        5-26

 



                                                     Assembler Directives
                                                                    .BYTE


        _________________________________________________________________

        .BYTE

              Byte storage directive

        Format

              .BYTE  expression-list

        Parameters

              expression-list
              One or more expressions separated by commas. Each
              expression is first evaluated as a quadword expression;
              then the value of the expression is truncated to fit in a
              byte. The value of each expression should be in the range 0
              to 255 for unsigned data or in the range -128 to +127 for
              signed data.

        Description

              .BYTE generates successive bytes of binary data in the
              object module.

        Notes

              o  The assembler displays a warning message if the
                 expression is outside the range -128 to -255.

              o  The assembler will truncate the most significant bits of
                 an integer or external value that is too large to store
                 in eight bits.

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

        Examples

                A:      .BYTE   5       ; Stores 5 in a byte




                                                                     5-27

 



        Assembler Directives
        .CODE_ADDRESS


        _________________________________________________________________

        .CODE_ADDRESS

              Code address storage directive

        Format

              .CODE_ADDRESS  name-list

        Parameters

              name-list
              A list of symbols separated by commas. These symbols
              should reference either a procedure descriptor name,
              such as a routine name, or an externally defined procedure
              descriptor.

        Description

              .CODE_ADDRESS causes the code addresses of the specified
              identifiers to be placed at the current psect and current
              location counter. The specified identifier should reference
              a procedure descriptor defined in the image.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword
                 (64-bit) boundary before allocating storage.

        Examples

                .CODE_ADDRESS A







        5-28

 



                                                     Assembler Directives
                                                              .D_FLOATING


        _________________________________________________________________

        .D_FLOATING
        .DOUBLE

              Floating-point storage directive

        Format

              .D_FLOATING  floating-point-number-list

              .DOUBLE  floating-point-number-list

        Parameters

              floating-point-number-list
              A comma-separated list of floating-point constants. The
              constants cannot contain any operators except unary plus
              or unary minus. For more information on floating-point
              numbers, see Section 2.3.2.

        Description

              .D_FLOATING evaluates the specified floating-point
              constants and stores the results in the object module.
              .D_FLOATING generates 64-bit, double-precision, floating-
              point data (1 bit of sign, 8 bits of exponent, and 55 bits
              of fraction). See the description of .F_FLOATING for
              information on storing single-precision floating-point
              numbers and the descriptions of .G_FLOATING, .S_FLOATING,
              and .T_FLOATING for descriptions of other floating-point
              constants.

        Notes

              o  Double-precision floating-point numbers are always
                 rounded.

              o  The alternate form of .D_FLOATING is .DOUBLE.

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword
                 (64-bit) boundary before allocating storage.

                                                                     5-29

 



        Assembler Directives
        .D_FLOATING


              o  The Alpha AXP architecture supports only conversion
                 operations for the D floating-point data type.

        Examples

                .D_FLOATING  3.1E+02







































        5-30

 



                                                     Assembler Directives
                                                                 .DISABLE


        _________________________________________________________________

        .DISABLE
        .DSABL

              Disable assembler functions directive

        Format

              .DISABLE  argument-list

              .DSABL  argument-list

        Parameters

              argument-list
              One or more of the symbolic arguments listed in Table 5-3
              under the description of .ENABLE. You can use either the
              long or the short form of the symbolic arguments. If
              you specify multiple arguments, separate them by commas,
              spaces, or tabs.

        Description

              .DISABLE disables the specified assembler function. See the
              description of .ENABLE for more information.

              The alternate form of .DISABLE is .DSABL.

















                                                                     5-31

 



        Assembler Directives
        .ELSE


        _________________________________________________________________

        .ELSE

              Conditional assembly block directive

        Format

              .ELSE

        Description

              A conditional assembly block is a series of source
              statements that is assembled only if a certain condition
              is met. .IF starts the conditional block and .ENDC ends
              the conditional block; each .IF must have a corresponding
              .ENDC. The .IF directive contains a condition test and
              one or two arguments. The condition test specified is
              applied to the arguments. If the test is met, all MACRO-
              64 statements between .IF and .ELSE are assembled. If the
              test is not met, the statements between .ELSE and .ENDC are
              assembled.

              Conditional blocks can be nested; that is, a conditional
              block can be inside another conditional block. In this
              case, the statements in the inner conditional block are
              assembled only if the condition is met for both the outer
              and inner block. For more information, see the description
              of the .IF directive.

        Notes

              o  You cannot use the .ELSE directive in the same
                 conditional block as the .IF_x directive.

              o  The .ELSE directive is similar to the .IF_FALSE
                 directive. However, you can only use .ELSE once within a
                 conditional block. .IF_FALSE can be used any number of
                 times in a conditional block.






        5-32

 



                                                     Assembler Directives
                                                                    .ELSE



        Examples

              An example of a conditional assembly directive is:

                .IF EQUAL  ALPHA+1        ; Assemble block if ALPHA+1=0.
                  .
                  .
                .ELSE                     ; Assemble when .IF=false.
                  .
                  .
                .ENDC

































                                                                     5-33

 



        Assembler Directives
        .ENABLE


        _________________________________________________________________

        .ENABLE
        .ENABL

              Enable assmebler functions directive

        Format

              .ENABLE  argument-list

              .ENABL  argument-list

        Parameters

              argument-list
              One or more of the symbolic arguments listed in Table 5-3 .
              You can use either the long form or the short form of the
              symbolic arguments.

              If you specify multiple arguments, separate them with
              commas, spaces, or tabs.

              Table_5-3_.ENABLE_and_.DISABLE_Symbolic_Arguments__________

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

                                                 (continued on next page)















        5-34

 



                                                     Assembler Directives
                                                                  .ENABLE


              Table_5-3_(Cont.)_.ENABLE_and_.DISABLE_Symbolic_Arguments__

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

              ALIGN_CODE           DisabledThe code alignment option
                                           aligns certain branch target
                                           labels. The ALIGN_CODE
                                           option is disabled for the
                                           assembly unit if any one of
                                           the following is true:

                                           o  /NOALIGNMENT=code is
                                              specified on the command
                                              line.

                                           o  .DISABLE ALIGN_CODE is
                                              specified in the source
                                              program.

                                           o  The /ALIGNMENT=code option
                                              is defaulted.

                                           See Section B.7 for
                                           information on optimizations
                                           and automatic alignment.

                                                 (continued on next page)
















                                                                     5-35

 



        Assembler Directives
        .ENABLE


              Table_5-3_(Cont.)_.ENABLE_and_.DISABLE_Symbolic_Arguments__

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

              ALIGN_DATA           DisabledWhen ALIGN_DATA is disabled,
                                           the data storage directives
                                           put each succeeding item on
                                           the next byte boundary.

                                           When ALIGN_DATA is enabled,
                                           the data storage directives
                                           put each succeeding item on
                                           natural boundaries (such as
                                           words on word boundaries,
                                           longwords on longword
                                           boundaries) adding pad bytes
                                           as necessary.

                                           Accessing data on anything
                                           other than natural boundaries
                                           usually incurs a significant
                                           performance penalty.

                                           You can enable or disable
                                           the ALIGN_DATA option for
                                           specific ranges within your
                                           program. For more information
                                           on automatic data alignment,
                                           see Section 5.2. Also, see
                                           Section B.7 for information
                                           on optimizations and automatic
                                           alignment.

                                                 (continued on next page)









        5-36

 



                                                     Assembler Directives
                                                                  .ENABLE


              Table_5-3_(Cont.)_.ENABLE_and_.DISABLE_Symbolic_Arguments__

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

              FLOAT                Enabled Controls whether the assembler
                                           generates floating-point
                                           instructions when optimizing
                                           code and performing code-label
                                           alignment.

                                           Currently, the only floating-
                                           point instruction generated
                                           by the assembler during
                                           optimization and alignment
                                           processing is FNOP, the
                                           floating-point no-operation
                                           instruction. If you specify
                                           .DISABLE FLOAT, the assembler
                                           does not generate any
                                           floating-point instructions
                                           as part of optimization and
                                           alignment processing.

                                           The initial value of this
                                           option is specified by the
                                           /ENVIRONMENT=[NO]FLOAT command
                                           line option. The last value
                                           of the FLOAT option at the end
                                           of assembly determines whether
                                           FLOAT is enabled or DISABLED.

                                                 (continued on next page)











                                                                     5-37

 



        Assembler Directives
        .ENABLE


              Table_5-3_(Cont.)_.ENABLE_and_.DISABLE_Symbolic_Arguments__

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

              GLOBAL        GBL    Enabled When GLOBAL is enabled, the
                                           assembler implicitly treats
                                           any undefined symbol as an
                                           external reference defined
                                           in another module. If the
                                           GLOBAL option is disabled,
                                           the assembler issues a
                                           warning and implicitly treats
                                           the undefined symbol as an
                                           external reference assumed to
                                           be defined in another module.
                                           The last value of the GLOBAL
                                           option at the end of assembly
                                           determines whether the GLOBAL
                                           option is enabled or disabled.

                                                 (continued on next page)






















        5-38

 



                                                     Assembler Directives
                                                                  .ENABLE


              Table_5-3_(Cont.)_.ENABLE_and_.DISABLE_Symbolic_Arguments__

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

              LOCAL_BLOCK   LSB    DisabledUsed to override the default
                                           assembler behavior to define
                                           a temporary label block. (A
                                           temporary label is of the
                                           form n$ where n represents
                                           a number.) A temporary label
                                           block is usually delimited
                                           by two user defined local or
                                           global labels. However, the
                                           .ENABLE LOCAL_BLOCK directive
                                           defines the start of a block
                                           that is terminated by one of
                                           the following:

                                           o  A second .ENABLE LOCAL_
                                              BLOCK directive.

                                           o  A .DISABLE LOCAL_BLOCK
                                              directive followed by
                                              a user-defined local or
                                              global label, or a .PSECT
                                              directive.

                                                 (continued on next page)















                                                                     5-39

 



        Assembler Directives
        .ENABLE


              Table_5-3_(Cont.)_.ENABLE_and_.DISABLE_Symbolic_Arguments__

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

              PEEPHOLE             DisabledPeephole optimization reduces
                                           the strength of certain
                                           instructions and eliminates
                                           instructions where possible.
                                           The PEEPHOLE option is
                                           disabled for the assembly unit
                                           if any one of the following is
                                           true:

                                           o  /NOOPTIMIZE=PEEPHOLE is
                                              specified on the command
                                              line.

                                           o  .DISABLE PEEPHOLE is
                                              specified in the source
                                              program.

                                           o  The PEEPHOLE option is
                                              defaulted.

                                           See Section B.7 for
                                           information on optimizations
                                           and automatic alignment.

                                                 (continued on next page)














        5-40

 



                                                     Assembler Directives
                                                                  .ENABLE


              Table_5-3_(Cont.)_.ENABLE_and_.DISABLE_Symbolic_Arguments__

                                   Default
                            Short
              Long_Form_____Form___ConditioFunction______________________

              SCHEDULE             DisabledInstruction scheduling
                                           optimization reorders
                                           instructions to more optimally
                                           utilize the instruction
                                           pipeline. The SCHEDULE
                                           option is disabled for the
                                           assembly unit if any one of
                                           the following is true:

                                           o  /NOOPTIMIZE=SCHEDULE is
                                              specified on the command
                                              line.

                                           o  .DISABLE SCHEDULE is
                                              specified in the source
                                              program.

                                           o  The SCHEDULE option is
                                              defaulted.

                                           See Section B.7 for
                                           information on optimizations
              _____________________________and_automatic_alignment.______

        Description

              .ENABLE enables the specified assembly function. .ENABLE
              and its negative form, .DISABLE, control the following
              assembler functions:

              o  Creating local label blocks

              o  Specifying that undefined symbol references are external
                 references

              o  Enabling or disabling specific optimizations for the
                 assembly unit


                                                                     5-41

 



        Assembler Directives
        .ENABLE


              You can enable one or more specific optimization options
              with either the .ENABLE directive, or the /OPTIMIZE
              command-line qualifier, or both. For more information on
              command line qualifiers, see Section 1.2. See Section B.7
              for information on optimizations. If you explicitly
              disable one or more specific optimization options with the
              .DISABLE directive, those optimization options are disabled
              regardless of the command-line options you specify.

        Notes

                 The alternate form of .ENABLE is .ENABL.

        Examples

                 Example 1

                 The following example shows the ALIGN_DATA option:

                .PSECT A, NOEXE
                .ENABLE ALIGN_DATA  ; Align on natural
                                    ; natural boundaries
                A: .BYTE 1          ;
                B: .QUAD 1000       ; B is allocated at
                                    ; a natural boundary -
                                    ; specifically at A + 7
                .DISABLE ALIGN_DATA ;
                C: .BYTE 2          ;
                D: .QUAD 1001       ; D is allocated at
                                    ; an unaligned boundary -
                                    ; specifically C + 1

                 Example 2

                 The following example shows the GLOBAL option disabled:

                .DISABLE GLOBAL
                .ADDRESS X         ; Assembler issues a warning
                .END






        5-42

 



                                                     Assembler Directives
                                                                  .ENABLE


                 Example 3

                 The following example shows the LOCAL_BLOCK option
                 enabled:

                      .ENABLE LOCAL_BLOCK

                      .PSECT A,NOEXE
                A1::
                5$:   .PROCEDURE_DESCRIPTOR PROC_1   ; Temporary label 5$
                      .blkb 32
                A2::
                      .address 5$                    ; By default the declaration
                                                     ; of A2 would have ended the
                                                     ; temporary label block and
                                                     ; made this reference to 5$
                                                     ; illegal.  However, this default
                                                     ; behavior has been overridden
                                                     ; by the use of .ENABLE LOCAL_BLOCK.

                      .DISABLE LOCAL_BLOCK
                      .END

                 Example 4

                 The following example shows an unoptimized and optimized
                 list of instructions with the SCHEDULE and PEEPHOLE
                 options enabled:

                .ENABLE PEEPHOLE,SCHEDULE
                .psect A,EXE,QUAD     ; unoptimized
                TRAPB
                A::ADDF F1,F2,F3
                   ADDF F4,F5,F6
                   ADDL R1,R2,R3
                   ADDL R4,R5,R6

                 This example shows the optimized list of instructions:

                .ENABLE PEEPHOLE,SCHEDULE
                .psect A,EXE,QUAD     ; optimized
                A::ADDF F1,F2,F3
                   ADDL R1,R2,R3
                   ADDF F4,F5,F6
                   ADDL R4,R5,R6

                                                                     5-43

 



        Assembler Directives
        .END


        _________________________________________________________________

        .END

              Assembly termination directive

        Format

              .END  [label]

        Parameters

              label
              The procedure descriptor name that specifies the routine
              (called the transfer address) where program execution
              begins. This argument is optional.

        Description

              .END terminates the source program. No additional text
              should occur beyond this point in the current source file,
              or in any additional source files specified in the command
              line for this assembly. If any additional text does occur,
              the assembler ignores it. The additional text does not
              appear in the listing file nor does it affect the object
              file.

        Notes

              o  When an executable image consisting of several object
                 modules is linked, only one object module should
                 be terminated by an .END directive that specifies a
                 transfer address. All other object modules should be
                 terminated by .END directives that do not specify a
                 transfer address. If an executable image contains either
                 no transfer address or more than one transfer address,
                 the linker displays an error message.

              o  For more information, see the .PROCEDURE_DESCRIPTOR
                 directive.





        5-44

 



                                                     Assembler Directives
                                                                     .END



        Examples

                  .
                  .
                  .
                .PROCEDURE_DESCRIPTOR TRANSFER1,code_address_T1
                  .
                  .
                  .
                .END TRANSFER1        ; TRANSFER1 is module transfer address


































                                                                     5-45

 



        Assembler Directives
        .ENDC


        _________________________________________________________________

        .ENDC

              End conditional directive

        Format

              .ENDC

        Description

              .ENDC terminates the conditional range started by the .IF
              directive. See the description of .IF for more information
              and examples.






























        5-46

 



                                                     Assembler Directives
                                                                    .ENDM


        _________________________________________________________________

        .ENDM

              End macro definition directive

        Format

              .ENDM  [macro-name]

        Parameters

              macro-name
              The name of the macro whose definition is to be terminated.
              The macro name is optional; if specified, it must match the
              name defined in the matching .MACRO directive. The macro
              name should be specified so that the assembler can detect
              any improperly nested macro definitions.

        Description

              .ENDM terminates the macro definition. See the description
              of .MACRO for an example of the use of an .ENDM directive.

        Notes

                 If .ENDM is encountered outside a macro definition, the
                 assembler displays an error message.

















                                                                     5-47

 



        Assembler Directives
        .ENDR


        _________________________________________________________________

        .ENDR

              End repeat range directive

        Format

              .ENDR

        Description

              .ENDR indicates the end of a repeat range. It must be the
              final statement of every repeat block. A repeat block
              consists of any range of text beginning with the .IRP,
              .IRPC, or .REPEAT directive. For more information, see the
              description for the .IRP, .IRPC, or .REPEAT directives for
              examples of how to use the .ENDR directive.

        Notes

                 If .ENDR is encountered outside a repeat block, the
                 assembler displays an error message.






















        5-48

 



                                                     Assembler Directives
                                                               .END_EXACT


        _________________________________________________________________

        .END_EXACT

              End exact instruction block directive

        Format

              .END_EXACT

        Description

              .END_EXACT delimits the end of an exact instruction block.
              An exact instruction block suppresses the optimizations
              SCHEDULE and PEEPHOLE, and the alignment options ALIGN_CODE
              and ALIGN_DATA for the specified range of instructions
              regardless if code optimizations are enabled for the
              assembly unit.

              For more information on the .END_EXACT directive, see the
              description of the .BEGIN_EXACT directive in this chapter.
























                                                                     5-49

 



        Assembler Directives
        .ERROR


        _________________________________________________________________

        .ERROR

              Error directive

        Format

              .ERROR  quoted-literal

        Parameters

              quoted-literal
              A string of characters, between a pair of double quotes,
              displayed during assembly. For more information on quoted
              literals, see Section 2.4.

        Description

              .ERROR causes the assembler to display an error message on
              the terminal or batch log file and in the listing file (if
              there is one).

              Using .ERROR prevents an output object file from being
              produced.

        Notes

              o  .PRINT, .WARN, and .ERROR are directives used to display
                 messages. You can use them to display information
                 indicating unexpected or important conditions within
                 the assembly.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                .ERROR "Illegal Arguments"
                ^
                %MACRO64-E-GENERROR, Generated ERROR: Illegal Arguments
                at line number 3 in file DISK$:[TEST]ERROR.M64;2


        5-50

 



                                                     Assembler Directives
                                                                    .EVEN


        _________________________________________________________________

        .EVEN

              Even location counter alignment directive

        Format

              .EVEN

        Description

              .EVEN ensures that the current value of the location
              counter is even by adding 1 if the current value is odd.
              If the current value is already even, no action is taken.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.
























                                                                     5-51

 



        Assembler Directives
        .EXTERNAL


        _________________________________________________________________

        .EXTERNAL
        .EXTRN

              External symbol attribute directive

        Format

              .EXTERNAL  symbol-list

              .EXTRN  symbol-list

        Parameters

              symbol-list
              A list of symbol names, separated by commas.

        Description

              .EXTERNAL indicates that the specified symbols are
              external; that is, the symbols are defined in another
              object module.

        Notes

                 The alternate form of .EXTERNAL is .EXTRN.

        Examples

                     .EXTERNAL B    ; B is defined in another module
                        .
                        .
                        .
                A::  .ADDRESS B    ; Its address is stored here










        5-52

 



                                                     Assembler Directives
                                                              .F_FLOATING


        _________________________________________________________________

        .F_FLOATING
        .FLOAT

              Floating-point storage directive

        Format

              .F_FLOATING  floating-point-number-list

              .FLOAT  floating-point-number-list

        Parameters

              floating-point-number-list
              A list of one or more floating-point constants separated by
              commas. For more information on floating-point numbers, see
              Section 2.3.2. The constants cannot contain any operators
              except unary plus or unary minus.

        Description

              .F_FLOATING evaluates the specified floating-point
              constant(s) and stores the results in the object module.
              .F_FLOATING generates 32-bit, single-precision, floating-
              point data (1 bit of sign, 8 bits of exponent, and 23 bits
              of fractional significance). See the description of .D_
              FLOATING for information on storing double-precision
              floating-point constants and the descriptions of .G_
              FLOATING, S_FLOATING, and T_FLOATING for descriptions of
              other floating-point constants.

        Notes

              o  The alternate form of .F_FLOATING is .FLOAT.

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a longword (32-
                 bit) boundary before allocating storage.

                                                                     5-53

 



        Assembler Directives
        .F_FLOATING



        Examples

                .F_FLOATING 1.0,3.0E+2









































        5-54

 



                                                     Assembler Directives
                                                              .G_FLOATING


        _________________________________________________________________

        .G_FLOATING

              G_floating-point storage directive

        Format

              .G_FLOATING  floating-point-number-list

        Parameters

              floating-point-number-list
              A comma-separated list of one or more floating-point
              constants. For more information on floating-point numbers,
              see Section 2.3.2. The constants cannot contain any
              operators except unary plus or unary minus.

        Description

              .G_FLOATING evaluates the specified floating-point
              constants and stores the results in the object module. .G_
              FLOATING generates 64-bit data (1 bit of sign, 11 bits of
              exponent, and 52 bits of fraction). See the description of
              .D_FLOATING for information on storing double-precision
              floating-point constants and the descriptions of .F_
              FLOATING, S_FLOATING, and T_FLOATING for descriptions of
              other floating-point constants.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword
                 (64-bit) boundary before allocating storage.

        Examples

                .G_FLOATING  2.0E-3



                                                                     5-55

 



        Assembler Directives
        .IDENT


        _________________________________________________________________

        .IDENT

              Identification directive

        Format

              .IDENT  quoted-literal

        Parameters

              quoted-literal
              A 1- to 31-character string, within double quotes, that
              identifies the module, such as a string that specifies a
              version number. For more information on quoted literals,
              see Section 2.4.

        Description

              .IDENT provides a means of identifying the object module.
              This identification is in addition to the name assigned
              to the object module with .TITLE. A character string can
              be specified in .IDENT to label the object module. This
              string is printed in the header of the listing file and
              also appears in the object module.

        Notes

                 If a source module contains more than one .IDENT, the
                 last directive given establishes the character string
                 that forms part of the object module identification.

        Examples

                .IDENT "Module Name"









        5-56

 



                                                     Assembler Directives
                                                                      .IF


        _________________________________________________________________

        .IF

              Conditional assembly block directive

        Format

              .IF  condition argument(s)
                 .
                 .
                 .

              range
                 .
                 .
                 .

              .ENDC

        Parameters

              condition
              A specified condition that must be met if the block is
              to be included in the assembly. The condition must be
              separated from the argument by a comma, space, or tab.
              Table 5-4 lists the conditions that can be tested by the
              conditional assembly directives.

              argument(s)
              One or more symbolic arguments or expressions of the
              specified conditional test. If the argument is an
              expression, it cannot contain any undefined symbols.
              The assembler converts relocatable arguments to absolute
              arguments by discarding the relocatable portion of the
              expression and using only the offset from the beginning of
              the psect. Arguments must be separated by a comma.

              range
              The block of source code that is conditionally included in
              the assembly.




                                                                     5-57

 



        Assembler Directives
        .IF


        Table_5-4_Condition_Tests_for_Conditional_Assembly_Directives____

                                                                        Condition
        Condition         Complement                         Number     That
                          Condition              Argument    of         Assembles
        Test              Test                   Type        Arguments  Block
                   Short                  Short
        Long
        Form_______Form___Long_Form_______Form___________________________

        EQUAL      EQ     NOT_EQUAL       NE     Expression  1 or       Expression-
                                                             2[1]       1 is
                                                                        equal to
                                                                        expression-
                                                                        2 or not
                                                                        equal to
                                                                        expression-
                                                                        2.

        GREATER    GT     LESS_EQUAL      LE     Expression  1 or       Expression-
                                                             2[1]       1 is
                                                                        greater
                                                                        than
                                                                        expression-
                                                                        2 or
                                                                        less
                                                                        than or
                                                                        equal to
                                                                        expression-
                                                                        2.

        [1]If_the_second_argument_is_omitted,_comparison_is_made_against_

        0.

                                                 (continued on next page)









        5-58

 



                                                     Assembler Directives
                                                                      .IF


        Table 5-4 (Cont.) Condition Tests for Conditional Assembly
        __________________Directives_____________________________________

                                                                        Condition
        Condition         Complement                         Number     That
                          Condition              Argument    of         Assembles
        Test              Test                   Type        Arguments  Block
                   Short                  Short
        Long
        Form_______Form___Long_Form_______Form___________________________

        LESS_      LT     GREATER_EQUAL   GE     Expression  1 or       Expression-
        THAN                                                 2[1]       1 is
                                                                        less
                                                                        than
                                                                        expression-
                                                                        2 or
                                                                        greater
                                                                        than or
                                                                        equal to
                                                                        expression-
                                                                        2.

        DEFINED    DF     NOT_DEFINED     NDF    Symbolic    1          Symbol
                                                                        is
                                                                        defined
                                                                        or not
                                                                        defined.

        BLANK      B      NOT_BLANK       NB     Macro       1          Argument
                                                                        is blank
                                                                        or not
                                                                        blank.

        IDENTICAL  IDN    DIFFERENT       DIF    Macro       2          Arguments
                                                                        are
                                                                        identi-
                                                                        cal or
                                                                        differ-
                                                                        ent.
        [1]If_the_second_argument_is_omitted,_comparison_is_made_against_

        0.
        _________________________________________________________________

                                                                     5-59

 



        Assembler Directives
        .IF



        Description

              A conditional assembly block is a series of source
              statements that are assembled only if a certain condition
              is met. A .IF starts the conditional block and a .ENDC ends
              the conditional block; each .IF must have a corresponding
              .ENDC. The .IF directive contains a condition test and
              one or two arguments. The condition test specified is
              applied to the arguments. If the test is met, all MACRO-64
              statements between .IF and .ENDC are assembled. If the test
              is not met, the statements are not assembled. Optionally,
              you can use the .ELSE directive (or a combination of the
              .IFF, .IFT, and .IFTF directives) to specify an alternate
              series of statements to assemble if the test is not met.

              Conditional blocks can be nested; that is, a conditional
              block can be inside another conditional block. In this
              case, the statements in the inner conditional block are
              assembled only if the condition is met for both the outer
              and inner block.

        Notes

              o  The assembler displays an error message if the following
                 directives occur outside a conditional assembly block:
                 .ENDC, .ELSE, .IF_FALSE, .IF_TRUE, .IF_TRUE_FALSE.

              o  MACRO-64 permits a nesting depth of 100 conditional
                 assembly levels. If a statement attempts to exceed this
                 nesting level depth, the assembler displays an error
                 message.

              o  The effect of logical expressions can only be achieved
                 by using several levels of .IF directives. See Example
                 5.

              o  Lowercase string arguments are converted to uppercase
                 before being compared, unless the string is surrounded
                 by double quotes or /NAMES=as_is is specified on the
                 command line.

              o  The assembler displays an error message if .IF specifies
                 any of the following: a condition test other than those
                 in Table 5-4, an illegal argument, or a null argument
                 specified in an .IF directive.

        5-60

 



                                                     Assembler Directives
                                                                      .IF



        Examples

                 Example 1

                 An example of a conditional assembly directive is:

                .IF EQUAL  ALPHA+1        ; Assemble block if ALPHA+1=0. Do
                  .                       ;   not assemble if ALPHA+1 not=0
                  .
                  .
                .ENDC

                 Example 2

                 Nested conditional directives take the form:

                .IF   condition argument(s)
                .IF   condition argument(s)
                  .
                  .
                  .
                .ENDC
                .ENDC

                 Example 3

                 The following conditional directives can govern whether
                 assembly of the specified range is to occur:

                .IF DEFINED  SYM1
                .IF DEFINED  SYM2
                  .
                  .
                  .
                .ENDC
                .ENDC

                 Example 4

                 In this example, if the outermost condition is not
                 satisfied, no deeper level of evaluation of nested
                 conditional statements within the program occurs.
                 Therefore, both SYM1 and SYM2 must be defined for the
                 specified range to be assembled.

                 An alternate series of statements can be specified using
                 .ELSE:

                                                                     5-61

 



        Assembler Directives
        .IF


                .IF EQUAL A,B        ; Assemble if A is equal to B
                .ELSE                ; Assemble if A is not equal to B
                .ENDC

                 Example 5

                 The following example demonstrates the use of .ELSE and
                 nesting:

                .IF LESS_THAN X,Y    ; Assemble if X is less than Y
                   .IF DEFINED Z     ; Assemble if Z is defined and
                                     ;  X is less than Y
                   .ELSE             ; Assemble if Z is not defined and
                                     ;  X is less than Y
                   .ENDC
                .ELSE                ; Assemble if X is greater than or equal to Y
                   .IF DEFINED Z     ; Assemble if Z is defined and X is
                                     ;  greater than or equal to Y
                   .ENDC
                .ENDC

























        5-62

 



                                                     Assembler Directives
                                                                    .IF_x


        _________________________________________________________________

        .IF_x

              Subconditional assembly block directives

        Format

              .IF_FALSE

              .IF_TRUE

              .IF_TRUE_FALSE

        Description

              For compatibility with VAX MACRO, MACRO-64 provides three
              directives for use within .IF blocks:

              ___________________________________________________________
              Directive_______Function___________________________________

              .IF_FALSE       If the condition of the assembly block
                              tests false, the program includes the
                              source code following the .IF_FALSE
                              directive and continuing up to the next
                              subconditional directive or to the end of
                              the conditional assembly block.

              .IF_TRUE        If the condition of the assembly block
                              tests true, the program includes the source
                              code following the .IF_TRUE directive and
                              continuing up to the next subconditional
                              directive or to the end of the conditional
                              assembly block.

              .IF_TRUE_FALSE  Regardless of whether the condition of the
                              assembly block tests true or false, the
                              source code following the .IF TRUE_FALSE
                              directive (and continuing up to the next
                              subconditional directive or to the end of
              ________________the_assembly_block)_is_always_included.____

              The implied argument of a subconditional directive is the
              condition test specified when the conditional assembly
              block was entered. A conditional or subconditional
              directive in a nested conditional assembly block is not

                                                                     5-63

 



        Assembler Directives
        .IF_x


              evaluated if the preceding (or outer) condition in the
              block is not satisfied (see Example 3 and Example 4).

              A conditional block with a subconditional directive is
              different from a nested conditional block. If the condition
              in the .IF is not met, the inner conditional blocks are not
              assembled, but a subconditional directive can cause a block
              to be assembled.

        Notes

              o  If a subconditional directive appears outside a
                 conditional assembly block, the assembler displays an
                 error message.

              o  The alternate forms of .IF_FALSE, .IF_TRUE, and .IF_
                 TRUE_FALSE are .IFF, .IFT, and .IFTF.

              o  You cannot use .ELSE in the same conditional block as
                 .IF_x.

        Examples

                 Example 1

                 Assume that symbol SYM is defined:



















        5-64

 



                                                     Assembler Directives
                                                                    .IF_x


                   .IF DEFINED   SYM               ; Tests TRUE since SYM is defined.
                     .                             ;   Assembles the following code.
                     .
                     .
                   .IF_FALSE                       ; Tests FALSE since previous
                     .                             ;   .IF was TRUE.  Does not
                     .                             ;   assemble the following code.
                     .
                   .IF_TRUE                        ; Tests TRUE since SYM is defined.
                     .                             ;   Assembles the following code.
                     .
                     .
                   .IF_TRUE_FALSE                  ; Assembles following code
                     .                             ;   unconditionally.
                     .
                     .
                   .IF_TRUE                        ; Tests TRUE since SYM is defined.
                     .                             ;   Assembles remainder of
                     .                             ;   conditional assembly block.
                     .
                   .ENDC

                 Example 2

                 Assume that symbol X is defined and that symbol Y is not
                 defined:

                   .IF DEFINED  X                  ; Tests TRUE since X is defined.
                   .IF DEFINED  Y                  ; Tests FALSE since Y is not defined.
                   .IF_FALSE                       ; Tests TRUE since Y is not defined.
                     .                             ;   Assembles the following code.
                     .
                     .
                   .IF_TRUE                        ; Tests FALSE since Y is not defined.
                     .                             ;   Does not assemble the following
                     .                             ;   code.
                     .
                   .ENDC
                   .ENDC






                                                                     5-65

 



        Assembler Directives
        .IF_x


                 Example 3

                 Assume that symbol A is defined and that symbol B is not
                 defined:

                   .IF DEFINED  A                  ; Tests TRUE since A is defined.
                     .                             ;   Assembles the following code.
                     .
                     .
                   .IF_FALSE                       ; Tests FALSE since A is defined.
                     .                             ;   Does not assemble the following
                     .                             ;   code.
                     .
                   .IF NOT_DEFINED B               ; Nested conditional directive
                     .                             ;   is not evaluated.
                     .
                     .
                   .ENDC
                   .ENDC

                 Example 4

                 Assume that symbol X is not defined but symbol Y is
                 defined:

                   .IF DEFINED  X                  ; Tests FALSE since X is not defined.
                     .                             ;   Does not assemble the following
                     .                             ;   code.
                     .
                   .IF DEFINED  Y                  ; Nested conditional directive
                     .                             ;   is not evaluated.
                     .
                     .
                   .IF_FALSE                       ; Nested subconditional
                     .                             ;   directive is not evaluated.
                     .
                     .
                   .IF_TRUE                        ; Nested subconditional
                     .                             ;   directive is not evaluated.
                     .
                     .
                   .ENDC
                   .ENDC


        5-66

 



                                                     Assembler Directives
                                                                     .IIF


        _________________________________________________________________

        .IIF

              Immediate conditional assembly block directive

        Format

              .IIF  condition [,]argument(s), statement

        Parameters

              condition
              One of the legal condition tests defined for conditional
              assembly blocks in Table 5-4 (see the description of .IF).
              The condition must be separated from the arguments by a
              comma, space, or tab. If the first argument can be a blank,
              the condition must be separated from the arguments with a
              comma.

              argument(s)
              An expression or symbolic argument (described in Table 5-4)
              associated with the immediate conditional assembly block
              directive. If the argument is an expression, it cannot
              contain any undefined symbols. For more information on
              terms and expressions, see Section 2.8. The assembler
              converts relocatable arguments to absolute arguments by
              discarding the relocatable portion of the expression and
              using only the offset from the beginning of the psect. The
              arguments must be separated from the statement by a comma.

              statement
              The statement to be assembled if the condition is
              satisfied.

        Description

              .IIF provides a means of writing a one-line conditional
              assembly block. The condition to be tested and the
              conditional assembly block are expressed completely within
              the line containing the .IIF directive. No terminating
              .ENDC statement is required or allowed.



                                                                     5-67

 



        Assembler Directives
        .IIF



        Notes

                 The assembler displays an error message if .IIF
                 specifies a condition test other than those listed
                 in Table 5-4, which the assembler considers valid, an
                 illegal argument, or a null argument.

        Examples

              In the following example, the symbol EXAM is defined within
              the source program:

                .IIF DEFINED EXAM, BR ALPHA

              This directive generates the following code:

                BR    ALPHA



























        5-68

 



                                                     Assembler Directives
                                                                 .INCLUDE


        _________________________________________________________________

        .INCLUDE

              Include source file directive

        Format

              .INCLUDE  quoted-literal

        Parameters

              quoted-literal
              The name of the source file to be included within double
              quotes. If a logical name exists that is the same as
              the source file name, specify the .M64 file extension to
              override the logical name. For more information on how to
              specify quoted literals, see Section 2.4.

        Description

              .INCLUDE indicates that the current input source file
              should be suspended and the specified file should be used.
              When that file ends, the original source stream resumes,
              starting at the line after .INCLUDE.

        Notes

                 The assembler issues an error message if the file
                 nesting level exceeds 50.

        Examples

                .INCLUDE "file1.m64"











                                                                     5-69

 



        Assembler Directives
        .INSTRUCTION


        _________________________________________________________________

        .INSTRUCTION

              Instruction directive

        Format

              .INSTRUCTION  expression

        Parameters

              expression
              An absolute expression in the range of -2147483648 to
              2147483647. For more information on terms and expressions,
              see Section 2.8. The expression cannot be relocatable,
              external, or complex.

        Description

              The specified value is stored at the current location as an
              instruction. You can use .INSTRUCTION to specify arbitrary
              instructions. Similar to .LONG, .INSTRUCTION stores a
              longword (32-bits) of data. Unlike .LONG, the assembler
              considers .INSTRUCTION an instruction and allows its use in
              code psects.

        Notes

              o  This directive can only be used within code or
                 mixed psects (psects that have either the EXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled within a mixed
                 psect, this directive aligns the current location
                 counter to a longword (32-bit) boundary before
                 allocating storage.

              o  This directive can be used to store arbitrary, longword,
                 assembly-time constant data in a code section.





        5-70

 



                                                     Assembler Directives
                                                             .INSTRUCTION



        Examples

                .INSTRUCTION 7









































                                                                     5-71

 



        Assembler Directives
        .IRP


        _________________________________________________________________

        .IRP

              Indefinite repeat argument directive

        Format

              .IRP  symbol,<argument list>

                 .
                 .
                 .
              range

                 .
                 .
                 .
              .ENDR

        Parameters

              symbol
              A formal argument that is successively replaced with the
              specified actual arguments enclosed in angle brackets
              (<>). If no formal argument is specified, the assembler
              displays an error message.

              <argument list>
              A list of actual arguments enclosed in angle brackets and
              used in expanding the indefinite repeat range. An actual
              argument can consist of one or more characters. Multiple
              arguments must be separated by a legal separator (comma,
              space, or tab). If no actual arguments are specified, no
              action is taken.

              range
              The block of source text to be repeated once for each
              occurrence of an actual argument in the list. The range
              can contain macro definitions and repeat ranges. .MEXIT is
              legal within the range and causes the current and remaining
              repetitions to be aborted.



        5-72

 



                                                     Assembler Directives
                                                                     .IRP



        Description

              .IRP replaces a formal argument with successive actual
              arguments specified in an argument list. This replacement
              process occurs during the expansion of the indefinite
              repeat block range. The .ENDR directive specifies the end
              of the range.

              .IRP is analogous to a macro definition with only one
              formal argument. At each successive expansion of the repeat
              block, this formal argument is replaced with successive
              elements from the argument list. The directive and its
              range are coded in line within the source program. This
              type of macro definition and its range do not require
              calling the macro by name, as do other macros described
              in this section.

              .IRP can appear either inside or outside another macro
              definition, indefinite repeat block, or repeat block (see
              the description of .REPEAT). The rules for specifying
              .IRP arguments are the same as those for specifying macro
              arguments.

        Examples

              The macro definition is as follows:

                .macro CHECK_PROCEDURE_KIND PROCEDURE_KIND
                    OK = 0      ; Assume procedure_kind is unknown
                    .irp REFERENCE_KIND,BOUND,NULL, REGISTER,STACK
                        .if identical, <PROCEDURE_KIND>, <REFERENCE_KIND>
                            OK = 1 ; Procedure_kind is known
                            .mexit ; No need to look further
                        .endc
                    .endr
                    .if eq, OK  ; If unknown procedure kind
                        .error "Unknown procedure kind: PROCEDURE_KIND"
                    .endc
                .endm CHECK_PROCEDURE_KIND

                CHECK_PROCEDURE_KIND REGISTER
                CHECK_PROCEDURE_KIND FOOZLE


                                                                     5-73

 



        Assembler Directives
        .IRP


              The macro call and expansion of the previously defined
              macro is as follows:

                CHECK_PROCEDURE_KIND REGISTER
                    OK = 0      ; Assume procedure kind is unknown
                    .if identical,<REGISTER>,<BOUND>
                    .endc
                    .if identical,<REGISTER>,<NULL>
                    .endc
                    .if identical,<REGISTER>,<REGISTER>
                        OK = 1 ; Procedure kind is known
                        .mexit ; No need to look further
                    .if eq, OK  ; If unknown procedure kind
                    .endc

                CHECK_PROCEDURE_KIND FOOZLE
                    OK = 0      ; Assume procedure kind is unknown
                    .if identical,<FOOZLE>,<BOUND>
                    .endc
                    .if identical,<FOOZLE>,<NULL>
                    .endc
                    .if identical,<FOOZLE>,<REGISTER>
                    .endc
                    .if identical,<FOOZLE>,<STACK>
                    .endc
                    .if eq, OK  ; If unknown procedure kind
                        .error "Unknown procedure kind: FOOZLE"
                    .endc

              In this example the CHECK_PROCEDURE_KIND macro uses the
              .IRP directive to iterate over a list of reference keywords
              to determine if its argument matches one of the reference
              keywords. If a match is not found, the macro displays an
              error message.











        5-74

 



                                                     Assembler Directives
                                                                    .IRPC


        _________________________________________________________________

        .IRPC

              Indefinite repeat character directive

        Format

              .IRPC  symbol,<STRING>

                 .
                 .
                 .
              range

                 .
                 .
                 .
              .ENDR

        Parameters

              symbol
              A formal argument that is successively replaced with the
              specified characters enclosed in angle brackets (<>). If
              no formal argument is specified, the assembler displays an
              error message.

              <STRING>
              A sequence of characters enclosed in angle brackets and
              used in the expansion of the indefinite repeat range.
              Although the angle brackets are required only when the
              string contains separating characters, their use is
              recommended for legibility.

              range
              The block of source text to be repeated once for each
              occurrence of a character in the list. The range can
              contain macro definitions and repeat ranges. .MEXIT is
              legal within the range.





                                                                     5-75

 



        Assembler Directives
        .IRPC



        Description

              .IRPC is similar to .IRP except that .IRPC permits single-
              character substitution rather than argument substitution.
              On each iteration of the indefinite repeat range, the
              formal argument is replaced with each successive character
              in the specified string. The .ENDR directive specifies the
              end of the range.

              .IRPC is analogous to a macro definition with only one
              formal argument. At each expansion of the repeat block,
              this formal argument is replaced with successive characters
              from the actual argument string. The directive and its
              range are coded in line within the source program and do
              not require calling the macro by name.

              .IRPC can appear either inside or outside another macro
              definition, indefinite repeat block, or repeat block (see
              description of .REPEAT).

        Examples

              The macro definition is as follows:

                    .macro X_COUNT ARG
                        COUNT = 0
                        .irpc CH,<ARG>
                            .iif identical,<CH>,<X>, COUNT = COUNT + 1
                        .endr
                    .endm X_COUNT

              The macro call and expansion of the macro defined
              previously is as follows:











        5-76

 



                                                     Assembler Directives
                                                                    .IRPC


                    X_COUNT XXFOOXBARXX
                        COUNT = 0
                        .irpc CH,<XXFOOXBARXX>
                            .iif identical,<CH>,<X>, COUNT = COUNT + 1
                        .endr
                            .iif identical,<X>,<X>, COUNT = COUNT + 1
                            .iif identical,<X>,<X>, COUNT = COUNT + 1
                            .iif identical,<F>,<X>, COUNT = COUNT + 1
                            .iif identical,<O>,<X>, COUNT = COUNT + 1
                            .iif identical,<O>,<X>, COUNT = COUNT + 1
                            .iif identical,<X>,<X>, COUNT = COUNT + 1
                            .iif identical,<B>,<X>, COUNT = COUNT + 1
                            .iif identical,<A>,<X>, COUNT = COUNT + 1
                            .iif identical,<R>,<X>, COUNT = COUNT + 1
                            .iif identical,<X>,<X>, COUNT = COUNT + 1
                            .iif identical,<X>,<X>, COUNT = COUNT + 1

                        .print "%integer(COUNT)"
                %MACRO64-I-GENPRINT, Generated PRINT: 5

              This example uses the .IRPC directive to iterate over the
              characters in the argument to the X_COUNT macro. Each
              time an argument character is X, the variable COUNT is
              incremented. After the X_COUNT macro has expanded, the
              example uses the %INTEGER() lexical operator to display
              the value of COUNT.



















                                                                     5-77

 



        Assembler Directives
        .LIBRARY


        _________________________________________________________________

        .LIBRARY

              Macro library directive

        Format

              .LIBRARY  quoted-literal1 [quoted-literal2]

        Parameters

              quoted-literal1
              A string enclosed within double quotes that is the file
              specification of a macro library. If a logical name exists
              and it is the same as the macro library name, specify the
              .MLB file extension to override the logical name. For more
              information on quoted literals, see Section 2.4.

              quoted-literal2
              An optional string enclosed within double quotes that
              specifies a search list of file specifications where the
              assembler should look for the specified macro library. The
              assembler successively processes the search list in left
              to right order and attempts to locate the specified macro
              library in each location specified in the search list until
              the macro library is found. If the macro library is not
              found, the assembler issues a diagnostic message. If you
              omit the second argument to the .LIBRARY directive, the
              assembler uses the following search list by default:

              o  The current device and directory

              o  The device and directory specified by the logical name
                 MACRO64$LIBRARY (if defined)

              o  The device and directory specified by the logical name
                 ALPHA$LIBRARY (if defined)

              o  The device and directory specified by the logical name
                 SYS$LIBRARY

              Logical names may be defined as VMS search lists.


        5-78

 



                                                     Assembler Directives
                                                                 .LIBRARY



        Description

              .LIBRARY adds a name to the macro library list that is
              searched whenever a .MCALL or an undefined opcode is
              encountered. The libraries are searched in the reverse
              order in which they were specified to the assembler.

              If you omit any information from the macro-library-name
              argument, default values are assumed. The device defaults
              to you current default disk; the directory defaults to your
              current default directory; the file type defaults to MLB.


        Examples

                .LIBRARY "MY_MACROS" 1
                .LIBRARY "PROJ_
        MACROS" "PROJ:[MACRO],PROJ:[DEVELOPMENT]" 2

              1  The first statement adds the macro library MY_MACROS.MLB
                 to the macro library list. The assembler first looks
                 for MY_MACROS.MLB in the current directory. If not found
                 there, the assembler next looks in the directory or
                 directories indicated by the MACRO64$LIBRARY logical
                 name if it is defined. If not found there or if
                 MACRO64$LIBRARY is not defined, the assembler next
                 looks in the directory or directories indicated by
                 the ALPHA$LIBRARY logical name if it is defined. If
                 not found there or if ALPHA$LIBRARY is not defined, the
                 assembler next looks in the directory or directories
                 indicated by the SYS$LIBRARY logical name. If not found
                 there, the assembler issues a diagnostic message.

              2  The second statement adds the macro library
                 PROJ_MACROS.MLB to the macro library list. The assembler
                 first looks for PROJ_MACROS.MLB in the PROJ:[MACRO]
                 directory. If not found there, the assembler next looks
                 in the PROJ:[DEVELOPMENT] directory. If not found there,
                 the assembler issues a diagnostic message.





                                                                     5-79

 



        Assembler Directives
        .LINKAGE_PAIR


        _________________________________________________________________

        .LINKAGE_PAIR

              Linkage directive

        Format

              .LINKAGE_PAIR  name

        Parameters

              name
              The name of the procedure descriptor, possibly defined
              in a different module of the routine to which linkage is
              required.

        Description

              .LINKAGE_PAIR causes a linkage pair to be stored at the
              current location counter. A linkage pair consists of two
              quadwords. The first quadword is the code entry point of
              the routine indicated by the specified identifier. (See
              .CODE_ADDRESS.) The second quadword is the address of
              the procedure descriptor of the routine indicated by the
              specified identifier. The second quadword is also called
              the procedure value. The specified name should reference
              a procedure descriptor that is either defined within the
              assembly unit or that becomes defined at the time the
              program is linked.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to an octaword (128-
                 bit) boundary before allocating storage.





        5-80

 



                                                     Assembler Directives
                                                            .LINKAGE_PAIR



        Examples


                .LINKAGE_PAIR A     ; Code address A followed by address of
                                    ; procedure descriptor A







































                                                                     5-81

 



        Assembler Directives
        .LIST


        _________________________________________________________________

        .LIST

              Listing directive

        Format

              .LIST  [argument-list]

        Parameters

              argument-list
              One or more of the symbolic arguments defined in Table 5-7
              . You can use either the long form or the short form of the
              arguments. If multiple arguments are specified, separate
              them with commas, spaces, or tabs.

        Description

              .LIST is equivalent to .SHOW. See the description of .SHOW
              for more information.























        5-82

 



                                                     Assembler Directives
                                                      .LOCAL_CODE_ADDRESS


        _________________________________________________________________

        .LOCAL_CODE_ADDRESS

              Local code address storage directive

        Format

              .LOCAL_CODE_ADDRESS  name-list

        Parameters

              name-list
              A list of symbols separated by commas. Each symbol
              references a procedure descriptor, defined in the current
              module.

        Description

              .LOCAL_CODE_ADDRESS causes the code addresses of the
              specified identifiers to be placed at the current psect
              and current location counter. The specified identifier must
              reference a procedure descriptor defined within the module.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword
                 (64-bit) boundary before allocating storage.

        Examples

                .PROCEDURE_DESCRIPTOR P1,C1
                .BLKQ 1
                .LOCAL_CODE_ADDRESS P1       ; Code address
                                             ; of P1...address of C1...
                                             ; is stored here.




                                                                     5-83

 



        Assembler Directives
        .LOCAL_LINKAGE_PAIR


        _________________________________________________________________

        .LOCAL_LINKAGE_PAIR

              Local linkage directive

        Format

              .LOCAL_LINKAGE_PAIR  name

        Parameters

              name
              The name of a procedure descriptor of the routine to which
              linkage is required. The specified procedure descriptor
              must be defined in the current module.

        Description

              .LOCAL_LINKAGE_PAIR causes a linkage pair to be stored at
              the current location counter. A linkage pair consists of a
              code address and the address of the specified identifier.
              The specified name must reference a procedure descriptor
              that is defined within the assembly unit.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to an octaword (128-
                 bit) boundary before allocating storage.

        Examples

                .PROCEDURE_DESCRIPTOR P1,CA1
                 .
                 .
                 .
                .LOCAL_LINKAGE_
        PAIR P1        ; Code address CA1 followed by
                                              ; procedure descriptor address P1.

        5-84

 



                                                     Assembler Directives
                                              .LOCAL_PROCEDURE_DESCRIPTOR


        _________________________________________________________________

        .LOCAL_PROCEDURE_DESCRIPTOR

              Procedure descriptor labeling directive

        Format

              .LOCAL_PROCEDURE_DESCRIPTOR  pd-name, ca-name

        Parameters

              pd-name
              The name of the procedure descriptor. This name can be up
              to 31 characters long. It cannot be a temporary label.

              ca-name
              The name of the code address that corresponds to the
              procedure descriptor. This name must be defined later
              in the program as a label in a psect that has either the
              EXE or MIX attribute, or both. This name can be up to 31
              characters long. It cannot be a temporary label.

        Description

              .LOCAL_PROCEDURE_DESCRIPTOR defines a bivalued local
              identifier that is used to represent a local routine. The
              first value is the procedure value, which is the address
              of the procedure descriptor. This value is defined as the
              current location counter at the point where you use the
              .LOCAL_PROCEDURE_DESCRIPTOR directive. The second value is
              the code address, which is the code entry-point address of
              the procedure. This value is defined by the second argument
              to the .LOCAL_PROCEDURE_DESCRIPTOR directive. No storage is
              allocated.

        Notes

              o  See the VMS Calling Standard for a full description of
                 procedure descriptors.

              o  You must specify .LOCAL_PROCEDURE_DESCRIPTOR before the
                 code of the routine it describes.


                                                                     5-85

 



        Assembler Directives
        .LOCAL_PROCEDURE_DESCRIPTOR


              o  See Section 6.7 for a description of the $PROCEDURE_
                 DESCRIPTOR and $ROUTINE library macros. These macros
                 define the procedure identifier and define the storage
                 for the procedure descriptor.

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information on psects, see
                 Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword (64-
                 bit) boundary before defining the procedure identifier.

        Examples

                .LOCAL_PROCEDURE_DESCRIPTOR LP1,C1




























        5-86

 



                                                     Assembler Directives
                                                                    .LONG


        _________________________________________________________________

        .LONG

              Longword storage directive

        Format

              .LONG  expression-list

        Parameters

              expression-list
              One or more expressions separated by commas.

        Description

              .LONG generates successive longwords (4 bytes) of data in
              the object module. The assembler truncates on the left of
              an integer or external value.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.3.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a longword (32-
                 bit) boundary before allocating storage.

              o  You can define a 32-bit address item using macros and
                 the .LONG directive. For example:

                 .macro address_32 item
                 .long item
                 .endm address_32

        Examples

                .LONG 4     ; Places 4 in 4 bytes of storage.




                                                                     5-87

 



        Assembler Directives
        .MACRO


        _________________________________________________________________

        .MACRO

              Macro definition directive

        Format

              .MACRO  macro-name [formal-argument-list]
                 .
                 .
                 .

              range
                 .
                 .
                 .

              .ENDM  [macro name]

        Parameters

              macro-name
              The name of the macro to be defined; this name can be any
              legal symbol up to 31 characters long.

              formal-argument-list
              The symbols, separated by commas, to be replaced by the
              actual arguments in the macro call.

              range
              The source text to be included in the macro expansion.

        Description

              .MACRO begins the definition of a macro. It gives the macro
              name and a list of formal arguments. The .MACRO directive
              is followed by the source text to be included in the macro
              expansion. The .ENDM directive specifies the end of the
              range.

              Macro names do not conflict with user-defined symbols. Both
              a macro and a user-defined symbol can have the same name.


        5-88

 



                                                     Assembler Directives
                                                                   .MACRO


              When the assembler encounters a .MACRO directive, it
              adds the macro name to its macro name table and stores
              the source text of the macro (up to the matching .ENDM
              directive). No other processing occurs until the macro is
              expanded.

              The symbols in the formal argument list are associated
              with the macro name and are limited to the scope of the
              definition of that macro. For this reason, the symbols
              that appear in the formal argument list can also appear
              elsewhere in the program.

              For more information, see Section 4.1.

        Notes

              o  If a macro has the same name as an Alpha AXP opcode, the
                 macro is used instead of the instruction. This feature
                 allows you to temporarily redefine an opcode.

              o  A macro can be redefined by using a .MACRO directive
                 with the same name as in a previous macro definition.
                 Therefore, the previous macro definition is implicitly
                 deleted and the new macro definition supersedes the
                 previous definition. See the .MDELETE directive for more
                 information on macro deletion.

              o  A macro definition can be nested within another macro
                 definition. The inner macro is not defined until the
                 outer macro is invoked.

              o  A macro invocation can be nested so that one macro can
                 invoke another. The assembler suports nested macro
                 invocations to a depth of 1000. If a macro invokes
                 itself, either directly or indirectly, it is recursive.
                 Recursive macros must specify a basis-step in order to
                 avoid infinite recursion. A basis-step is a macro exit
                 condition that will eventually cause the macro to exit,
                 thus ending the recursion (see the example below).






                                                                     5-89

 



        Assembler Directives
        .MACRO



        Examples

                 Example 1

                 This example shows how macro definitions and invocations
                 may be nested. It also shows examples of the various
                 forms of parameter passing. See Section 4.1 for more
                 information on parameter passing. .

                .MACRO OP1 A,B=R4,?C
                C:      ADDL R2, B, R3
                .MACRO OP'B
                        TRAPB
                .ENDM OP'B
                        ADDL A, R2, R3
                        OP'B
                        .MDELETE OP'B
                .ENDM OP1

                 When OP1 is invoked "OP1 R0", the text expands to:

                33000$: ADDL R2, R4, R3
                .MACRO OPR4
                        TRAPB
                .ENDM
                        ADDL R0, R2, R3
                        OPR4
                        .MDELETE OPR4

                 Processing this text will cause OPR4 to be expanded to
                 TRAPB; the final text will be:

                33000$: ADDL R2, R4 R3
                        ADDL R0, R2, R3
                        TRAPB









        5-90

 



                                                     Assembler Directives
                                                                   .MACRO


                 Example 2

                 The following example shows macro redefinition:

                .MACRO INITIALIZE
                   .MACRO INITIALIZE   ;Redefine to nothing
                   .ENDM INITIALIZE
                   X=0
                   Y=1
                   Z=-1
                .ENDM INITIALIZE

                 Note that while the redefined version of the macro
                 immediately supersedes the previous definition in any
                 subsequent invocation, the invocation of the original
                 definition expands to completion.

                 Example 3

                 This example shows a recursive macro:

                .MACRO FACTORIAL N
                   .IF EQUAL <N>,0      ;Basis step; stop at zero
                      F=1
                   .ELSE
                      FACTORIAL <N-1>
                      F = F * <N>
                   .ENDC
                .ENDM FACTORIAL
















                                                                     5-91

 



        Assembler Directives
        .MCALL


        _________________________________________________________________

        .MCALL

              Macro call directive

        Format

              .MCALL  macro-name-list

        Parameters

              macro-name-list
              A list of macros to be defined for this assembly. Separate
              the macro names with commas.

        Description

              .MCALL specifies the names of the system and user-defined
              macros that are required to assemble the source program but
              are not defined in the source file.

              If any named macro is not found upon completion of the
              search (that is, if the macro is not defined in any of the
              macro libraries), the assembler displays an error message.

        Notes

                 Using the .MCALL directive is optional unless the macro
                 name is the same as an opcode or assembler directive.
                 The assembler automatically searches for a library macro
                 when it encounters an identifier that is not an opcode
                 or directive in the opcode field. If your macro name
                 is the same as an opcode or directive, you must use the
                 .MCALL directive. You can also use the .MCALL directive
                 in your program to document which macros are used by
                 your program.

        Examples

                .MCALL TRAPB       ; Substitute macro in library for
                                   ; TRAPB instruction



        5-92

 



                                                     Assembler Directives
                                                                 .MDELETE


        _________________________________________________________________

        .MDELETE

              Macro deletion directive

        Format

              .MDELETE  macro-name-list

        Parameters

              macro-name-list
              A list of macros whose definitions are to be deleted. You
              may separate the macros with a comma or spaces.

        Description

              .MDELETE deletes the definitions of specified macros.

              .MDELETE completely deletes the macro. If you delete a
              macro that is currently expanding (such as a macro that
              deletes itself), the macro name is immediately removed from
              the macro name table and the macro is marked for deletion.
              When the macro finishes expanding, it is deleted.

        Examples

                .MACRO FOO
                .PRINT "In macro FOO"
                .ENDM FOO
                FOO
                .MDELETE FOO












                                                                     5-93

 



        Assembler Directives
        .MEXIT


        _________________________________________________________________

        .MEXIT

              Macro exit directive

        Format

              .MEXIT

        Description

              .MEXIT terminates a macro expansion before the end of
              the macro. Termination is the same as if .ENDM were
              encountered. You can also use the directive within repeat
              blocks. .MEXIT is useful in conditional expansion of macros
              and repeat blocks because it bypasses the complexities of
              nested conditional directives and alternate assembly paths.

        Notes

              o  When .MEXIT occurs in a repeat block, the assembler
                 terminates the current repetition of the range and
                 suppresses further expansion of the repeat range.

              o  When macros or repeat blocks are nested, .MEXIT exits to
                 the next higher level of expansion.

              o  If .MEXIT occurs outside a macro definition or a repeat
                 block, the assembler displays an error message.

        Examples

                 Example 1

                 The following macro definition uses the .MEXIT
                 directive to exit the current macro when it has finished
                 processing a particular kind of argument.







        5-94

 



                                                     Assembler Directives
                                                                   .MEXIT


                        .macro STORE REG, LOCATION
                           .if identical,<REG>,<FP>
                                STQ REG, LOCATION
                                .mexit
                            .endc
                            .if identical,<REG>,<SP>
                                STQ REG, LOCATION
                                .mexit
                            .endc
                            .if identical,<%extract(0,1,<REG>)>,<R>
                                STQ REG, LOCATION
                                .mexit
                            .endc
                            .if identical,<%extract(0,1,<REG>)>,<F>
                                STT REG, LOCATION
                                .mexit
                            .endc
                            .error "Register argument is not a register"
                        .endm STORE


                 Example 2

                 In this example, the STORE macro (as defined in Example
                 1) attempts to recognize its REG argument as either FP,
                 SP, an integer register (a register with R as its first
                 letter), or a floating-point register (a register with
                 F as its first letter). The following example show two
                 expansions of the STORE macro.

                        STORE R1, 0(SP)
                            .if identical,<R1>,<FP>
                            .endc
                            .if identical,<R1>,<SP>
                            .endc
                            .if identical,<%extract(0,1,<R1>)>, <R>
                            .if identical,<R>,<R>
                                STQ R1, 0(SP)
                                .mexit






                                                                     5-95

 



        Assembler Directives
        .MEXIT


                        STORE 24(SP), 16(SP)
                            .if identical,<24(SP)>,<FP>
                            .endc
                            .if identical,<24(SP)>,<SP>
                            .endc
                            .if identical,<%extract(0,1,<24(SP)>)>,<R>
                            .if identical,<2>,<R>
                            .endc
                            .if identical, <%extract(0,1<24(SP)>)>,<F>
                            .if identical,<2>,<F>
                            .endc
                            .error "Register argument is not a register"

                 The first call of the STORE macro above stores R1 at
                 0(SP). The STORE macro determines to do an integer store
                 by recognizing the letter R as the first letter of the
                 register name. Once it has done so, it abandons further
                 expansion of the macro using the .MEXIT directive.
                 The second invocation attempts to store 24(SP) at
                 16(SP). Since the STORE macro cannot identify 24(SP)
                 as a legitimate register in any of the four forms it
                 recognizes, the STORE macro does not attempt to store
                 the REG argument, and does not abandon expansion with
                 the .MEXIT directive. Instead, the STORE macro expands
                 and issues a diagnostic message.




















        5-96

 



                                                     Assembler Directives
                                                                    .NARG


        _________________________________________________________________

        .NARG

              Number of arguments directive

        Format

              .NARG  symbol

        Parameters

              symbol
              A symbol that is assigned a value equal to the number of
              positional arguments in the macro call.

        Description

              .NARG determines the number of arguments in the current
              macro call.

              .NARG counts all the positional arguments specified in the
              macro call, including null arguments (specified by adjacent
              commas). The value assigned to the specified symbol does
              not include any keyword arguments or any formal arguments
              that have default values.

        Notes

                 If .NARG appears outside a macro, the assembler displays
                 an error message.

        Examples

              Example 1

              The macro definition is as follows:

                .MACRO  CNT_ARG A1,A2,A3,A4,A5,A6,A7,A8,A9=DEF9,A10=DEF10
                .NARG   COUNTER         ; COUNTER is set to no. of ARGS
                .WORD   COUNTER         ; Store value of COUNTER
                .ENDM   CNT_ARG



                                                                     5-97

 



        Assembler Directives
        .NARG


              Example 2

              The macro calls and expansions of the macro previously
              defined are as follows:

                CNT_ARG TEST,FIND,ANS   ; COUNTER will = 3
                .NARG   COUNTER         ; COUNTER is set to no. of ARGS
                .WORD   COUNTER         ; Store value of COUNTER

                CNT_ARG                 ; COUNTER will = 0
                .NARG   COUNTER         ; COUNTER is set to no. of ARGS
                .WORD   COUNTER         ; Store value of COUNTER

                CNT_ARG TEST,A2=SYMB2,A3=SY3      ; COUNTER will = 1
                .NARG   COUNTER         ; COUNTER is set to no. of ARGS
                .WORD   COUNTER         ; Store value of COUNTER
                                        ; Keyword arguments are not counted

                CNT_ARG ,SYMBL,,        ; COUNTER will = 4
                .NARG   COUNTER         ; COUNTER is set to no. of ARGS
                .WORD   COUNTER         ; Store value of COUNTER
                                        ; Null arguments are counted























        5-98

 



                                                     Assembler Directives
                                                                    .NCHR


        _________________________________________________________________

        .NCHR

              Number of characters directive

        Format

              .NCHR  symbol,<string>

        Parameters

              symbol
              A symbol that is assigned a value equal to the number of
              characters in the specified character string.

              <string>
              A sequence of printable characters. Delimit the character
              string with angle brackets (<>) (or a character preceded
              by a circumflex (^)) only if the specified character
              string contains a legal separator (comma, space, or tab)
              or a semicolon (;).

        Description

              .NCHR determines the number of characters in a specified
              character string. It can appear anywhere in an MACRO-64
              program and is useful in calculating the length of macro
              arguments.

        Notes

                 You can use the %LENGTH lexical operator instead of the
                 .NCHR directive.

        Examples

                 Example 1

                 The macro definition is as follows:

                .MACRO   CHAR    MESS                    ; Define MACRO
                .NCHR    CHRCNT,<MESS>                   ; Assign value to CHRCNT
                .WORD    CHRCNT                          ; Store value
                .ASCII   "MESS"                          ; Store characters
                .ENDM    CHAR                            ; Finish

                                                                     5-99

 



        Assembler Directives
        .NCHR


                 Example 2

                 The macro calls and expansions of the macro previously
                 defined are as follows:

                CHAR     <HELLO>                        ; CHRCNT will = 5
                .NCHR    CHRCNT,<HELLO>                 ; Assign value to CHRCNT
                .WORD    CHRCNT                          ; Store value
                .ASCII   "HELLO"                         ; Store characters

                CHAR     <14, 75.39  4>                 ; CHRCNT will = 12(dec)
                .NCHR    CHRCNT,<14, 75.39  4>          ; Assign value to CHRCNT
                .WORD    CHRCNT                          ; Store value
                .ASCII   "14, 75.39  4"                  ; Store characters































        5-100

 



                                                     Assembler Directives
                                                                   .NLIST


        _________________________________________________________________

        .NLIST

              Listing exclusion directive

        Format

              .NLIST  [argument-list]

        Parameters

              argument-list
              One or more of the symbolic arguments listed in Table 5-7
              . Use either the long form or the short form of the
              arguments. If you specify multiple arguments, separate
              them with commas, spaces, or tabs.

        Description

              .NLIST is equivalent to .NOSHOW. See the description of
              .SHOW for more information.























                                                                    5-101

 



        Assembler Directives
        .NOSHOW


        _________________________________________________________________

        .NOSHOW

              Listing exclusion directive

        Format

              .NOSHOW  [argument-list]

        Parameters

              argument-list
              One or more of the symbolic arguments listed in Table 5-7
              in the description of .SHOW. Use either the long form or
              the short form of the arguments. If you specify multiple
              arguments, separate them with commas, spaces, or tabs.

        Description

              .NOSHOW specifies listing control options. See the
              description of .SHOW for more information.























        5-102

 



                                                     Assembler Directives
                                                                    .OCTA


        _________________________________________________________________

        .OCTA

              Octaword storage directive

        Format

              .OCTA  expression-list

        Parameters

              expression-list
              A list of constant values separated by commas. Each value
              results in a 64-bit value being sign-extended to 128 bits
              and stored in an octaword.

        Description

              .OCTA generates 128 bits (16 bytes) of binary data.

        Notes

              o  The low quadword contains the specified constant value.

              o  The high quadword contains the sign extension of the
                 specified constant value. That is, the high quadword
                 contains zero if the specified value is positive, and
                 it contains all bits set to 1 if the specified value is
                 negative.

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to an octaword (128-
                 bit) boundary before allocating storage.







                                                                    5-103

 



        Assembler Directives
        .OCTA



        Examples

                .OCTA  0                         ; OCTA 0
                .OCTA  ^X01234ABCD5678F9         ; OCTA hex value specified

                .OCTA  VINTERVAL                 ; VINTERVAL has 64-
        bit value,

                                                 ;   sign-extended



































        5-104

 



                                                     Assembler Directives
                                                                     .ODD


        _________________________________________________________________

        .ODD

              Odd location counter alignment directive

        Format

              .ODD

        Description

              .ODD ensures that the current value of the location counter
              is odd by adding 1 if the current value is even. If the
              current value is already odd, no action is taken.

        Notes

                 This directive can be used only within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.3.
























                                                                    5-105

 



        Assembler Directives
        .PACKED


        _________________________________________________________________

        .PACKED

              Packed decimal string storage directive

        Format

              .PACKED  decimal-string[,symbol]

        Description

              .PACKED is supplied as a library macro with MACRO-64. For
              more information, see Chapter 6.































        5-106

 



                                                     Assembler Directives
                                                                    .PAGE


        _________________________________________________________________

        .PAGE

              Page ejection directive

        Format

              .PAGE

        Description

              .PAGE forces a new page in the listing. The directive
              itself is also printed in the listing and begins the new
              page.

              .PAGE in a macro definition is ignored. The paging
              operation is performed only during macro expansion. If
              the .PAGE directive occurs during macro expansion, text
              beginning with the original macro invocation line appears
              at the top of a new page.

        Examples

                .MACRO SKIP    ; macro definition with .PAGE
                .PAGE          ;
                .ENDM SKIP     ;
                .PSECT A,NOEXE ;
                .BLKW 10       ;
                SKIP           ; In the listing file, a form feed
                               ;  will be inserted here














                                                                    5-107

 



        Assembler Directives
        .PRINT


        _________________________________________________________________

        .PRINT

              Assembly message directive

        Format

              .PRINT  quoted-literal

        Parameters

              quoted-literal
              The string of characters enclosed in quotes are displayed
              when encountered during assembly. For more information on
              quoted literals, see Section 2.4.

        Description

              .PRINT causes the assembler to display an informational
              message. The message consists of the string.

        Notes

              o  .PRINT, .WARN, and .ERROR are directives that display
                 messages. You can use these to display information
                 indicating unexpected or important conditions within
                 the assembly.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                .PRINT "Questionable usage"
                ^
                %MACRO64-I-GENPRINT, Generated PRINT: Questionable usage
                at line number 3 in file DISK$:[TEST]PRINT.M64;2






        5-108

 



                                                     Assembler Directives
                                                    .PROCEDURE_DESCRIPTOR


        _________________________________________________________________

        .PROCEDURE_DESCRIPTOR

              Procedure descriptor labeling directive

        Format

              .PROCEDURE_DESCRIPTOR  pd-name, ca-name

        Parameters

              pd-name
              The name of the procedure descriptor. This name can be up
              to 31 characters long. It cannot be a temporary label.

              ca-name
              The name of the code address that corresponds to the
              procedure descriptor. This name must be defined later
              in the program as a label in a psect that has either the
              EXE or MIX attribute, or both. This name can be up to 31
              characters long. It cannot be a temporary label.

        Description

              .PROCEDURE_DESCRIPTOR defines a bivalued global identifier
              that is used to represent a global routine. The first
              value is the procedure value, which is the address of
              the procedure descriptor. This value is defined as the
              current location counter at the point where you use the
              .PROCEDURE_DESCRITOR directive. The second value is the
              code address, which is the code entry-point address of the
              procedure. This value is defined by the second argument
              to the .PROCEDURE_DESCRIPTOR directive. No storage is
              allocated.

        Notes

              o  See the VMS Calling Standard for a full description of
                 procedure descriptors.

              o  You must specify .PROCEDURE_DESCRIPTOR before the code
                 of the routine it describes.


                                                                    5-109

 



        Assembler Directives
        .PROCEDURE_DESCRIPTOR


              o  See Section 6.7 for a description of the
                 $PROCEDURE_DESCRIPTOR  and $ROUTINE library macros.
                 These macros define the procedure identifier and define
                 the storage for the procedure descriptor.

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword (64-
                 bit) boundary before defining the procedure identifier.

































        5-110

 



                                                     Assembler Directives
                                                                   .PSECT


        _________________________________________________________________

        .PSECT

              Program sectioning directive

        Format

              .PSECT  program-section-name[,argument-list]

        Parameters

              program-section-name
              The name of the program section. For more information on
              psects, see Section 5.1.

              argument-list
              A list containing the program section attributes and the
              program section alignment. Table 5-5 lists the attributes
              and their functions. Table 5-6 lists the default attributes
              and their opposites. Program sections are aligned when you
              specify an integer in the range 0 to 16 or one of the five
              keywords listed in the following table. If you specify an
              integer, the program section is linked to begin at the next
              virtual address that is a multiple of two raised to the
              power of the integer. If you specify a keyword, the program
              section is linked to begin at the next virtual address
              that is a multiple of the corresponding value listed in the
              following table:

              ___________________________________________________________
              Keyword_Size_(in_Bytes)____________________________________

              BYTE    20= 1

              WORD    21= 2

              LONG    22= 4

              QUAD    23= 8

              OCTA    24= 16
              ___________________________________________________________

              QUAD is the default.

                                                                    5-111

 



        Assembler Directives
        .PSECT


        Table_5-5_Program_Section_Attributes_____________________________

        AttributFunction_________________________________________________

        ABS     Absolute-The program section has an absolute address. An
                absolute program section contributes no binary code to
                the image, so its byte allocation request to the linker
                is zero. You cannot store initial values in an absolute
                program section with directives such as .BYTE, .WORD,
                .LONG, QUAD. Usually the .BLKx directives are used in
                conjunction with label definitions within an absolute
                program section to define symbolic offsets within a
                structure. Compare this attribute with its opposite,
                REL.

        CON     Concatenate-Program sections with the same name and
                attributes (including CON) from other modules are
                concatenated into one program section at link time.
                Their contents are concatenated in the order in which
                the linker acquires them. The allocated virtual address
                space is the sum of the individual requested allocations.
                Compare this attribute with its opposite, OVL.

        EXE     Executable-The program section contains instructions.
                This attribute provides the capability of separating
                instructions from read-only and read/write data. The
                linker uses this attribute in gathering program sections
                and in verifying that the transfer address is in an
                executable program section. The assembler only allows
                you to place instructions in a program section that has
                either or both the EXE or MIX attributes. Compare this
                attribute with its opposite, NOEXE.

        GBL     Global-Program sections that have the same name and
                attributes will be combined at link time into a single
                program section even when the individual program sections
                are in different clusters. This attribute is specified
                for FORTRAN COMMON block program sections. Compare this
                attribute with its opposite, LCL.

        LCL     Local-The program section is restricted to its cluster.
                Compare this attribute with its opposite, GBL.

                                                 (continued on next page)

        5-112

 



                                                     Assembler Directives
                                                                   .PSECT


        Table_5-5_(Cont.)_Program_Section_Attributes_____________________

        AttributFunction_________________________________________________

        MIX     Mix-The program section can contain both data and
                instructions. The MIX and NOMIX attributes are assembly-
                time attributes which only affect assembler processing.
                The MIX and NOMIX attributes do not appear in the object
                module and do not affect linker processing. To mix
                instructions and data in the same psect, you must specify
                the MIX attribute. The NOMIX attribute is the default. If
                you choose to use instructions in a NOEXE psect, or use
                data directives in an EXE psect, you must specify the MIX
                attribute. The following limitations apply when using the
                MIX attribute:

                o  Optimizations and alignment of code labels are not
                   performed. Optimizations and code-label alignment are
                   not performed on instructions placed in a MIX psect,
                   regardless of whether the .ENABLE/.DISABLE options
                   have been set, or if command line /OPTIMIZATION and
                   /ALIGNMENT=code options have been specified.

                o  Limited debugging information is provided. No PC-line
                   (program counter) correlation information is generated
                   for the instructions placed in a MIX psect.

                o  The listing file includes only binary encoded
                   instructions. All instructions that are placed in a
                   MIX psect appear in the machine-code portion of the
                   listing file, in their binary encoded instruction form
                   as a data initializer to the .LONG data directive.

                There are no restrictions on data directives. Compare
                this attribute with its opposite, NOMIX. For more
                information, see Section 5.1.

        NOEXE   Not Executable-The program section contains data only; it
                does not contain instructions. The assembler only allows
                you to place data allocations in a program section that
                has either or both the NOEXE and MIX attributes. Compare
                this attribute with its opposite, EXE.

                                                 (continued on next page)

                                                                    5-113

 



        Assembler Directives
        .PSECT


        Table_5-5_(Cont.)_Program_Section_Attributes_____________________

        AttributFunction_________________________________________________

        NOMIX   The default attribute when you use the .PSECT directive.
                Compare this attribute with its opposite, MIX.

        NOPIC   Non-Position-Independent Content-The program section is
                assigned to a fixed location in virtual memory (when it
                is in a shareable image). Compare this attribute with its
                opposite, PIC.

        NORD    Nonreadable-Reserved for future use. Compare this
                attribute with its opposite, RD.

        NOSHR   No Share-The program section is reserved for private use
                at execution time by the initiating process. Compare this
                attribute with its opposite, SHR.

        NOWRT   Nonwriteable-The contents of the program section cannot
                be altered (written into) at execution time. Compare this
                attribute with its opposite, WRT.

        OVR     Overlay-Program sections with the same name and
                attributes (including OVR) from other modules receive
                the same relocatable base address in memory at link time.
                The allocated virtual address space is the requested
                allocation of the largest overlaying program section.
                Compare this attribute with its opposite, CON.

        PIC     Position-Independent Content-The program section can be
                relocated; that is, it can be assigned to any memory area
                (when it is in a shareable image). Compare this attribute
                with its opposite, NOPIC.

        RD      Readable-Reserved for future use. Compare this attribute
                with its opposite, NORD.

        REL     Relocatable-The linker assigns the program section a
                relocatable base address. The contents of the program
                section can be code or data. Compare this attribute with
                its opposite, ABS.

                                                 (continued on next page)

        5-114

 



                                                     Assembler Directives
                                                                   .PSECT


        Table_5-5_(Cont.)_Program_Section_Attributes_____________________

        AttributFunction_________________________________________________

        SHR     Share-The program section can be shared at execution
                time by multiple processes. This attribute is assigned
                to a program section that can be linked into a shareable
                image. Compare this attribute with its opposite, NOSHR.

        WRT     Write-The contents of the program section can be altered
                (written into) at execution time. Compare this attribute
        ________with_its_opposite,_NOWRT.________________________________

              Table_5-6_Default_Program_Section_Attributes_______________

              Default
              Attribute_____Opposite_Attribute___________________________

              CON           OVR

              EXE           NOEXE

              LCL           GBL

              NOMIX         MIX

              NOPIC         PIC

              NOSHR         SHR

              RD            NORD

              REL           ABS

              WRT___________NOWRT________________________________________

        Description

              .PSECT defines a program section and its attributes and
              refers to a program section once it is defined. Use program
              sections to do the following:

              o  Develop modular programs.

              o  Separate instructions from data.

              o  Allow different modules to access the same data.

              o  Protect read-only data and instructions from being
                 modified.

              o  Identify sections of the object module to the linker and
                 the debugger.

                                                                    5-115

 



        Assembler Directives
        .PSECT


              o  Control the order in which program sections are stored
                 in virtual memory.

              When the assembler encounters a .PSECT directive that
              specifies a new program section name, it creates a new
              program section and stores the name, attributes, and
              alignment of the program section. The assembler includes
              all data or instructions that follow the .PSECT directive
              in that program section until it encounters another .PSECT
              directive. The assembler starts all program sections at a
              relative location counter of 0.

              The assembler does not automatically define program
              sections. Any code or data placed before the first .PSECT
              directive in the source code produces an assembly error.

              If the assembler encounters a .PSECT directive that
              specifies the name of a previously defined program section,
              it stores the new data or instructions after the last
              entry in the previously defined program section, even
              with program sections that have the OVR attribute. (OVR
              program sections from separate modules are overlaid by
              the linker. The OVR attribute does not affect how multiple
              contributions to a psect are processed within a single
              assembly unit.) You need not re-list the attributes when
              continuing a program section, but any attributes that are
              listed must be the same as those previously in effect for
              the program section. A continuation of a program section
              cannot contain attributes conflicting with those specified,
              or defaulted, in the original .PSECT directive.

              The attributes listed in the .PSECT directive describe the
              contents of the program section. Except for the EXE and
              NOEXE attributes, the assembler does not check to ensure
              that the contents of the program section actually adhere
              to the attributes listed. However, the assembler and the
              linker do check that all program sections with the same
              name have exactly the same attributes. The assembler and
              linker display an error message if the program section
              attributes are not consistent.

              Program section names are independent of local symbol,
              global symbol, and macro names. You can use the same
              symbolic name for a program section and for a local symbol,
              global symbol, or macro name. You may want to use unique
              names for clarity and maintainability.

        5-116

 



                                                     Assembler Directives
                                                                   .PSECT



        Notes

              o  The .ALIGN directive cannot specify an alignment greater
                 than that of the current program section; consequently,
                 .PSECT should specify the largest alignment needed in
                 the program section.

              o  For efficiency of execution and ease of programming, an
                 alignment of quadword or larger is recommended for all
                 program sections that have quadword data.

        Examples

                .PSECT A,QUAD,EXE     ; Code psect






























                                                                    5-117

 



        Assembler Directives
        .QUAD


        _________________________________________________________________

        .QUAD

              Quadword storage directive

        Format

              .QUAD  expression-list

        Parameters

              expression-list
              One or more expressions separated by commas.

        Description

              .QUAD generates 64 bits (8 bytes) of binary data.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword
                 (64-bit) boundary before allocating storage.

        Examples

                A:: .QUAD 4













        5-118

 



                                                     Assembler Directives
                                                                  .REPEAT


        _________________________________________________________________

        .REPEAT
        .REPT

              Repeat block directive

        Format

              .REPEAT expression
                 .
                 .
                 .

              range
                 .
                 .
                 .

              .ENDR

        Parameters

              expression
              An expression whose value controls the number of times
              the range is to be assembled within the program. When
              the expression is less than or equal to zero, the repeat
              block is not assembled. The expression must be absolute
              or relocatable and must not contain any undefined symbols.
              The assembler converts a relocatable value to the relative
              offset within the psect.

              range
              The source text to be repeated the number of times
              specified by the value of the expression. The repeat block
              can contain macro definitions or other repeat blocks.
              .MEXIT is legal within the range and causes the current
              and all succeeding repetitions to be aborted.







                                                                    5-119

 



        Assembler Directives
        .REPEAT



        Description

              .REPEAT repeats a block of code a specified number of
              times, in line with other source code. The .ENDR directive
              specifies the end of the range.

        Notes

                 The alternate form of .REPEAT is .REPT.

        Examples

                 Example 1

                 The following macro definition uses the .REPEAT
                 directive to store an ASCII string a specified number
                 of times, followed by a zero byte:

                .MACRO  COPIES  STRING,NUM
                .REPEAT NUM
                .ASCII  "STRING"
                .ENDR
                .BYTE   0
                .ENDM   COPIES

                 Example 2

                 The following macro call stores five copies of the
                 string "ABCDEF". This example is divided into 4 parts:

                 Macro invocation:

                COPIES  <ABCDEF>,5

                 Macro expansion of .REPEAT invocation:

                  .REPEAT 5
                  .ASCII  "ABCDEF"
                  .ENDR

                 .REPEAT expansion:

                  .ASCII  "ABCDEF"
                  .ASCII  "ABCDEF"
                  .ASCII  "ABCDEF"
                  .ASCII  "ABCDEF"
                  .ASCII  "ABCDEF"

        5-120

 



                                                     Assembler Directives
                                                                  .REPEAT


                 End of macro expansion:

                  .BYTE   0

                 Example 3

                 The following macro call stores three copies of the
                 string "How Many Times". This example is divided into 4
                 parts:

                 Macro invocation:

                VARB = 3
                  COPIES  <How Many Times>,VARB

                 Macro expansion of .REPEAT invocation:

                .REPEAT VARB
                  .ASCII  "How Many Times"
                  .ENDR

                 .REPEAT expansion:

                .ASCII  "How Many Times"
                  .ASCII  "How Many Times"
                  .ASCII  "How Many Times"

                 End of macro expansion:

                  .BYTE   0















                                                                    5-121

 



        Assembler Directives
        .RESTORE_PSECT


        _________________________________________________________________

        .RESTORE_PSECT
        .RESTORE

              Restore previous program section context directive

        Format

              .RESTORE_PSECT

              .RESTORE

        Description

              .RESTORE_PSECT retrieves the program section from the top
              of the program section context stack, an internal stack in
              the assembler. If the stack is empty when .RESTORE_PSECT
              is issued, the assembler displays an error message. When
              .RESTORE_PSECT retrieves a program section, it restores
              the current location counter to the value it had when the
              program section was saved. The maximum stack level is 50.
              See the description of .SAVE_PSECT for more information.

        Notes

              o  The alternate form of .RESTORE_PSECT is .RESTORE.

              o  You cannot use .RESTORE_PSECT to overwrite previous
                 data storage initializations. In the following example,
                 MACRO-64 attempts to store "42" over "43" and fails,
                 resulting in a diagnostic.

                 .PSECT A
                 .SAVE PSECT
                 .PSECT A
                 .QUAD 43
                 .RESTORE PSECT
                 .QUAD 42






        5-122

 



                                                     Assembler Directives
                                                           .RESTORE_PSECT



        Examples

                    .PSECT A,QUAD,NOEXE
                A1: .WORD 5
                A2: .QUAD 6
                    .SAVE_PSECT        ; Saves psect A context
                    .PSECT B,QUAD,NOEXE
                B1: .WORD 6
                    .RESTORE_PSECT     ; Return A location counter
                A3: .WORD 5

                    .PSECT B,QUAD,NOEXE
                1$: .WORD 5
                    .SAVE LOCAL_
        BLOCK  ; Saves psect B context and temporary
                                       ; label context

                    .PSECT C,NOEXE
                1$: .WORD 6
                    .RESTORE_PSECT     ; Restores psect B and saves
                                       ; label context
                    .ADDRESS 1$        ; References the address of
                                       ; psect B temporary label 1$





















                                                                    5-123

 



        Assembler Directives
        .SAVE_PSECT


        _________________________________________________________________

        .SAVE_PSECT
        .SAVE

              Save current program section context directive

        Format

              .SAVE_PSECT  [LOCAL_BLOCK]

              .SAVE  [LOCAL_BLOCK]

        Description

              .SAVE_PSECT stores the current program section context on
              the top of the program section context stack, an internal
              assembler stack. It leaves the current program section
              context in effect. The program section context stack can
              hold up to 50 entries. Each entry includes the value of
              the current location counter and the maximum value assigned
              to the location counter in the current program section. If
              the stack is full when .SAVE_PSECT is encountered, an error
              occurs.

              If the LOCAL_BLOCK option is specified, the current
              temporary label block is saved with the current program
              section context.

              .SAVE_PSECT and .RESTORE_PSECT are especially useful in
              macros that define program sections. See the description of
              .RESTORE_PSECT for an example using .SAVE_PSECT.

        Notes

                 The alternate form of .SAVE_PSECT is .SAVE.









        5-124

 



                                                     Assembler Directives
                                                              .S_FLOATING


        _________________________________________________________________

        .S_FLOATING

              Single-precision IEEE floating-point arithmetic directive

        Format

              .S_FLOATING  floating-point-number-list

        Parameters

              floating-point-number-list
              A list of IEEE single-precision floating-point constants
              separated by commas. For more information on floating-point
              numbers, see Section 2.3.2.

        Description

              .S_FLOATING evaluates the specified floating-point
              constants and stores the results in the object module.
              .S_FLOATING generates 32-bit, single-precision, floating-
              point data (1 bit of sign, 8 bits of exponent, and 23 bits
              of fractional significance). See the description of .T_
              FLOATING for information on storing double-precision
              floating-point IEEE numbers and the descriptions of
              .D_FLOATING, .F_FLOATING, and .G_FLOATING for descriptions
              of other floating-point numbers.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.3.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a longword (32-
                 bit) boundary before allocating storage.

        Examples

                .S_FLOATING 2.0,3.0,4.405



                                                                    5-125

 



        Assembler Directives
        .SHOW


        _________________________________________________________________

        .SHOW
        .NOSHOW

              Listing inclusion and exclusion directives

        Format

              .SHOW  [argument-list]

              .NOSHOW  [argument-list]

        Parameters

              [argument-list]
              Use one or more of the symbolic arguments defined in
              Table 5-7. You can use either the long form or the short
              form of the arguments. If you specify multiple arguments,
              you must separate them by commas. If any argument is not
              specifically included in a listing control statement,
              the assembler assumes its default value (show or noshow)
              throughout the source program.

        Table_5-7_.SHOW_and_.NOSHOW_Symbolic_Arguments___________________

                        Short
        Long_Form_______Form______Default___Function_____________________

        CONDITIONALS    CND       Noshow    Lists unsatisfied conditional
                                            code associated with
                                            the conditional assembly
                                            directives.

        EXPANSIONS      ME        Noshow    Lists macro and repeat range
                                            expansions.

        LIBRARY         None      Noshow    Includes the macro
                                            definitions in a library
                                            in the listing.

        INCLUDE         None      Noshow    Lists include file text in
        ____________________________________the_listing_file.____________


        5-126

 



                                                     Assembler Directives
                                                                    .SHOW



        Description

              .SHOW and .NOSHOW specify listing control options in the
              source text of a program. You can use .SHOW and .NOSHOW
              with or without an argument list.

              When you use them with an argument list, .SHOW includes and
              .NOSHOW excludes the lines specified in Table 5-7. .SHOW
              and .NOSHOW control the listing of the source lines that
              are in conditional assembly blocks (see the description of
              .IF), macros, and repeat blocks. When you use them without
              arguments, these directives alter the listing level count.
              The listing level count is initialized to 0. Each time
              .SHOW appears in a program, the listing level count is
              incremented; Each time .NOSHOW appears in a program, the
              listing level count is decremented.

              When the listing level count is negative, the listing is
              suppressed, unless the line contains an error. Conversely,
              when the listing level count is positive, the listing
              is generated. When the count is 0, the line is either
              listed or suppressed, depending on the value of the listing
              control symbolic arguments.

        Notes

              o  The listing level count allows macros to be listed
                 selectively; a macro definition can specify .NOSHOW
                 at the beginning to decrement the listing count and can
                 specify .SHOW at the end to restore the listing count to
                 its original value.

              o  The alternate forms of .SHOW and .NOSHOW are .LIST and
                 .NLIST.

              o  The initial setting for each list .LIST/.SHOW option
                 is obtained from the command line setting using the
                 /SHOW qualifier. For more information on command line
                 qualifiers, see Section 1.2.





                                                                    5-127

 



        Assembler Directives
        .SHOW



        Examples

                .NOSHOW   ; Turn off listing file display.  Counter < 0.
                   .
                   .
                   .
                .SHOW     ; Turn on listing file display.  Counter = 0.
                          ; Value of .SHOW options are used.
                   .
                   .
                   .
                .SHOW     ; Counter > 0.  Listing file display is
                          ; on for all options regardless of setting.
                   .
                   .
                   .




























        5-128

 



                                                     Assembler Directives
                                                             .SIGNED_BYTE


        _________________________________________________________________

        .SIGNED_BYTE

              Signed byte storage directive

        Format

              .SIGNED_BYTE  expression-list

        Parameters

              expression-list
              An expression or list of expressions separated by commas.
              Each expression specifies a value to be stored. The value
              must be in the range -128 through +127.

        Description

              .SIGNED_BYTE generates successive bytes of binary data in
              the object module and performs signed range checking. Apart
              from the range check, .SIGNED_BYTE is equivalent to .BYTE
              for storage allocation.

        Notes

                 This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

        Examples

                .PSECTA,NOEXE
                .SIGNED_BYTE   LABEL1-LABEL2  ;  Data must fit
                .SIGNED_BYTE   -126           ;     in a byte










                                                                    5-129

 



        Assembler Directives
        .SIGNED_WORD


        _________________________________________________________________

        .SIGNED_WORD

              Signed word storage directive

        Format

              .SIGNED_WORD  expression-list

        Parameters

              expression-list
              An expression or list of expressions separated by commas.
              Each expression specifies a value to be stored. The value
              must be in the range -32,768 through +32,767.

        Description

              .SIGNED_WORD generates successive words of binary data in
              the object module and performs signed range checking. Apart
              from the range check, .SIGNED_WORD is equivalent to .WORD
              in terms of storage allocation.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a word (16-bit)
                 boundary before allocating storage.

        Examples

                .PSECT $DATA,NOEXE
                .SIGNED_WORD -32766;
                .SIGNED_WORD 32769 ;causes assembly error






        5-130

 



                                                     Assembler Directives
                                                                .SUBTITLE


        _________________________________________________________________

        .SUBTITLE
        .SBTTL

              Listing subtitle directive

        Format

              .SUBTITLE  quoted-literal

              .SBTTL  quoted-literal

        Parameters

              quoted-literal
              An ASCII string enclosed in quotes from 1 to 31 characters
              long; excess characters are truncated. For more information
              on quoted literals, see Section 2.4.

        Description

              .SUBTITLE causes the assembler to print the line of text
              as the subtitle on the second line of each assembly listing
              page. This subtitle text is printed on each page until
              altered by a subsequent .SUBTITLE directive in the program.

        Notes

              o  The alternate form of .SUBTITLE is .SBTTL.

              o

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                .SUBTITLE "Terminal Display Routines"





                                                                    5-131

 



        Assembler Directives
        .T_FLOATING


        _________________________________________________________________

        .T_FLOATING

              Double-precision IEEE floating-point arithmetic directive

        Format

              .T_FLOATING  floating-point-number-list

        Parameters

              floating-point-number-list
              A list of IEEE double-precision floating-point constants
              separated by commas. For more information on floating point
              numbers, see Section 2.3.2.

        Description

              .T_FLOATING evaluates the specified floating-point
              constants and stores the results in the object module.
              .T_FLOATING generates 64-bit, double-precision, floating-
              point data (1 bit of sign, 11 bits of exponent, and 52 bits
              of fractional significance). See the description of .S_
              FLOATING for information on storing single-precision
              floating-point IEEE numbers and the descriptions of .D_
              FLOATING, F_FLOATING, and G_FLOATING for descriptions of
              other floating-point numbers.

        Notes

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a quadword
                 (64-bit) boundary before allocating storage.

        Examples

                .T_FLOATING 4.5036,6.034



        5-132

 



                                                     Assembler Directives
                                                                   .TITLE


        _________________________________________________________________

        .TITLE

              Listing title directive

        Format

              .TITLE  module-name ["listing-title"]

        Parameters

              module-name
              Either a quoted literal or an identifier that specifies the
              module's title. For more information on quoted literals,
              see Section 2.4.

              "listing-title"
              Optional quoted literal that specifies a title to appear
              within the first line of each listing output file. For more
              information on quoted literals, see Section 2.4.

        Description

              .TITLE assigns a name to the object module.

        Notes

              o  The module name specified with .TITLE bears no
                 relationship to the file specification of the object
                 module, as specified in the MACRO-64 command line. The
                 object module name appears in the linker load map and
                 is also the module name that the debugger and librarian
                 recognize.

              o  If .TITLE is not specified, MACRO-64 assigns the default
                 name (.MAIN.) to the object module. If more than one
                 .TITLE directive is specified in the source program, the
                 last .TITLE directive encountered establishes the name
                 for the entire object module.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

                                                                    5-133

 



        Assembler Directives
        .TITLE



        Examples

                .TITLE "MAIN" "Main Entry Point"









































        5-134

 



                                                     Assembler Directives
                                                                    .WARN


        _________________________________________________________________

        .WARN

              Warning directive

        Format

              .WARN  quoted-literal

        Parameters

              quoted-literal
              The string of characters enclosed in quotes are displayed
              during assembly. For more information on quoted literals,
              see Section 2.4.

        Description

              .WARN causes the assembler to display a warning message on
              the terminal or in the batch log file, and in the listing
              file (if there is one).

        Notes

              o  .PRINT, .WARN, and .ERROR are directives that display
                 messages. You can use them to display information
                 indicating an unexpected or important assembly
                 condition.

              o  This directive also accepts VAX MACRO syntax. See
                 VAX MACRO and Instruction Set Reference Manual for
                 details.

        Examples

                .WARN "Illegal parameter value; 0 assumed"
                ^
                %MACRO64-W-
        GENWARN, Generated WARNING: Illegal parameter value; 0 assumed
                at line number 3 in file DISK$:[TEST]WARN.M64;2




                                                                    5-135

 



        Assembler Directives
        .WEAK


        _________________________________________________________________

        .WEAK

              Weak symbol attribute directive

        Format

              .WEAK  symbol-list

        Parameters

              symbol-list
              A list of identifiers separated by commas.

        Description

              .WEAK specifies symbols that are either defined externally
              in another module or defined globally in the current
              module. .WEAK suppresses any object library search for
              the symbol.

              When .WEAK specifies a symbol that is not defined in the
              current module, the symbol is externally defined. If the
              linker finds the symbol's definition in another module,
              it uses that definition. If the linker does not find an
              external definition, the symbol has a value of zero and the
              linker does not report an error. The linker does not search
              a library for the symbol, but if a module brought in from a
              library for another reason contains the symbol definition,
              the linker uses it.

              When .WEAK specifies a symbol that is defined in the
              current module, the symbol is considered to be globally
              defined. However, if this module is inserted in an object
              library, this symbol is not inserted in the library's
              symbol table. Consequently, searching the library at link
              time to resolve this symbol does not cause the module to be
              included.






        5-136

 



                                                     Assembler Directives
                                                                    .WEAK



        Examples

                    .WEAK A,B,C
                A:: .WORD 5     ; A and B are weak global definitions
                B:: .QUAD 6
                    .ADDRESS C  ; C is a weak external reference






































                                                                    5-137

 



        Assembler Directives
        .WORD


        _________________________________________________________________

        .WORD

              Word storage directive

        Format

              .WORD  expression-list

        Parameters

              expression-list
              One or more expressions separated by commas. For more
              information on terms and expressions, see Section 2.8.

        Description

              .WORD generates successive words (2 bytes) of data in the
              object module.

        Notes

              o  The expression is first evaluated as a quadword,
                 then truncated to a word. The value of the expression
                 should be in the range of -32,768 to +32,767 for signed
                 data or 0 to 65,535 for unsigned data. The assembler
                 displays an error if the high-order 6 bytes of the
                 quadword expression have a value other than zero or
                 ^XFFFFFFFFFFFF.

              o  The assembler truncates on the left of an integer or
                 external value.

              o  Addresses are not allowed with .WORD.

              o  This directive can only be used within data or mixed
                 psects (psects that have either the NOEXE or MIX
                 attributes). For more information, see Section 5.1.

              o  If automatic data alignment is enabled, this directive
                 aligns the current location counter to a word (16-bit)
                 boundary before allocating storage.


        5-138

 



                                                     Assembler Directives
                                                                    .WORD



        Examples

                .WORD 5,6,7









































                                                                    5-139

 










                                                                        6
        _________________________________________________________________

                                                 MACRO-64 Supplied Macros


              This chapter describes the library macros supplied with
              the MACRO-64 assembler. These macros make it easy for you
              to define and call routines. For a detailed description of
              each macro, see Section 6.7.

              This chapter also describes the $OPDEF macro, which allows
              you to define your own opcodes.

        6.1 MACRO-64 Supplied Library

              The MACRO-64 assembler provides a library of macros that
              help you to program in conformance with the OpenVMS Calling
              Standard. This library also allows you to define you own
              opcodes. This library, called MACRO64.MLB, is installed on
              your system with the MACRO-64 assembler.

              The MACRO-64 assembler automatically adds the MACRO64.MLB
              library to the library list before it begins processing
              your source program. Consequently, you do not need to add
              it manually using the .LIBRARY directive.

              The following macros are supplied by the MACRO-64
              Assembler.

                 $BEGIN_EPILOGUE
                 $CALL
                 $CODE_SECTION
                 $DATA_SECTION
                 $END_EPILOGUE
                 $END_PROLOGUE
                 $END_ROUTINE
                 $LINKAGE_PAIR
                 $LINKAGE_SECTION
                 $OPDEF
                 $PROCEDURE_DESCRIPTOR
                 $RETURN

                                                                      6-1

 



        MACRO-64 Supplied Macros
        6.1 MACRO-64 Supplied Library


                 $ROUTINE

              Also, Appendix B explains how to program more effectively
              using the MACRO-64 assembly language within the framework
              of the OpenVMS Calling Standard.

        6.2 Routines and Lexical Scope

              The calling-standard macros use the concept of a single,
              current, active routine. A routine is simply a programming
              entity that is associated with a procedure descriptor
              that may be called, or is a main routine specified as the
              transfer address of a linked image.

              Only one routine can be active or current at any given time
              during assembly. If more than one routine is defined in
              a single assembler source file, all items associated with
              the current routine, that is within the lexical scope of
              the routine, must be completed before making a different
              routine current. The lexical scope of one routine cannot
              overlap the lexical scope of another routine.

              A routine becomes current or comes into scope by invoking
              the $ROUTINE macro with the appropriate arguments. $ROUTINE
              marks the beginning of the lexical scope of a routine. The
              complementary macro, $END_ROUTINE, marks the end of the
              current routine's lexical scope.

        6.2.1 Routines and Program Sections

              Routines have three types of associated program sections:

              o  Code section-Contains the executable instructions of
                 the routine. This section is typically read only and
                 executable.

              o  Data section-Contains data accessed by a routine.
                 Typically, this is where variable data is stored.
                 This section is typically non-executable, readable,
                 and writeable.

              o  Linkage section-Contains a routine's procedure
                 descriptor and the necessary linkage information for
                 calling other routines, and for linkage to data not in
                 the linkage section, if any. Also, constant data may be
                 placed here. Typically, this section is read only and
                 not executable.

        6-2

 



                                                 MACRO-64 Supplied Macros
                                           6.2 Routines and Lexical Scope


                 The linkage section is considered a type of data section
                 with the following function:

                 -  Provides linkage information for calls made from a
                    routine associated with the linkage section.

                 -  Provides linkage information for data outside of the
                    linkage section.

                 -  Defines the associated routine's procedure descriptor
                    so that calls can be made to the routine.

                 -  Defines constant or static data.

        6.3 Using Macros to Control Program Sections

              The following section explains how to use the MACRO-64
              supplied macros to define and control the various program
              sections during assembly.

        6.3.1 Defining Program Sections

              Each of the three program section types can be referenced
              by a corresponding macro. The following three macros are
              used to refer to and define these three psects associated
              within a routine:

              o  $CODE_SECTION-makes the routine's code psect current.

              o  $DATA_SECTION-makes the routine's data psect current.

              o  $LINKAGE_SECTION-makes the routine's linkage psect
                 current.

              To switch to one of the current routine's sections, you
              invoke the corresponding macro. For example, after invoking
              $ROUTINE, to place instructions into the current routine's
              code psect, you invoke the $CODE_SECTION macro. This makes
              the code psect associated with the current routine the
              current psect. Similarly, invoking $LINKAGE_SECTION makes
              the linkage psect associated with the current routine the
              current psect.

              You can also control the psect name and attributes for
              each of the program sections by defining arguments to the
              $ROUTINE macro. For more information, see Section 6.7.

                                                                      6-3

 



        MACRO-64 Supplied Macros
        6.3 Using Macros to Control Program Sections


        6.3.2 Using Macro Specific Symbols

              The following symbols are defined by the $ROUTINE macro.
              These symbols are useful while programming with the
              calling-standard macros to refer to particular data and
              linkage section items:

              o  $CS-The address of the beginning of the current
                 routine's code section.

              o  $LS-The address of the beginning of the current
                 routine's linkage section.

              o  $DS-The address of the beginning of the current
                 routine's data section.

              o  $DP-The linkage section address where the $ROUTINE
                 macro places the .ADDRESS $DS to enable access to the
                 data section from the linkage section (this variable is
                 optional).

              o  $SIZE-The size of the fixed stack area in bytes. $SIZE
                 is defined using the value specified with the SIZE
                 argument.

              o  $RSA_OFFSET-The offset within the fixed stack area to
                 the register save area. $RSA_OFFSET is defined using the
                 value specified with the RSA_OFFSET argument.

              o  $RSA_END-The offset within the fixed stack area to the
                 first byte beyond the end of the register save area.

              For more information, see the description for the $ROUTINE
              macro in this chapter.

              The $CALL macro also defines the $STACK_ARG_SIZE symbol.
              This symbol specifies the number of bytes used to store
              arguments on the stack. This value is useful after calling
              a routine that returns a value on the stack. In this case,
              $CALL cannot remove the arguments from the stack because
              you must first retrieve the returned value from the stack.
              Subsequently, you can remove the arguments from the stack
              using the $STACK_ARG_SIZE symbol. For more information, see
              the description of $CALL in this chapter.

        6-4

 



                                                 MACRO-64 Supplied Macros
                             6.3 Using Macros to Control Program Sections


        6.3.3 Defining Procedure Type

              The OpenVMS Calling Standard defines four types of
              routines; stack, register, null, and bound. For more
              information on types of routines, see Section B.4, and
              the OpenVMS Calling Standard.

              You can define the routine type by using the KIND
              keyword argument with $ROUTINE or $PROCEDURE_DESCRIPTOR
              macros. The validity and values of other $ROUTINE and
              $PROCEDURE_DESCRIPTOR macro parameters are determined
              by the type of routine being declared. For example, a
              null procedure type has no stack size, therefore the
              SIZE parameter is invalid and cannot be specified for
              a null procedure type. When using the KIND keyword with
              the $ROUTINE or $PROCEDURE_DESCRIPTOR macros, note the
              following exceptions:

              o  The $SIZE symbol defined by $ROUTINE is only valid for
                 stack and register routines.

              o  The $RSA_OFFSET symbol defined by $ROUTINE is only valid
                 for a stack routine.

        6.3.4 Using Macros in Prologue Sections

              With stack and register routines, $ROUTINE generates
              a standard prologue sequence if you specify
              the STANDARD_PROLOGUE=TRUE keyword argument.
              STANDARD_PROLOGUE=TRUE is the default for register and
              stack routines.

              Alternatively, you can code your own prologue sequence
              by specifying the STANDARD_PROLOGUE argument as FALSE
              and using the $END_PROLOGUE macro to mark the end of
              your prologue sequence. In this case, you may wish to
              use the $SIZE and $RSA_OFFSET symbols to symbolically
              specify the fixed stack size and register save area offset,
              respectively.

              For more information on the prologue sequence of
              instructions that must occur at the beginning of all stack
              and register routines, see the OpenVMS Calling Standard.


                                                                      6-5

 



        MACRO-64 Supplied Macros
        6.3 Using Macros to Control Program Sections


        6.3.5 Using Macros in Epilogue Sections

              With stack and register routines, you can use the $RETURN
              macro to generate an epilogue sequence. Alternatively,
              you can code your own epilogue sequence using the
              $BEGIN_EPILOGUE and $END_EPILOGUE macros to mark the
              beginning and end of your epilogue sequences.

              The OpenVMS Calling Standard also describes the epilogue
              sequence of instructions that must be executed every time a
              stack or register routine returns to its caller.

        6.4 Programming Examples Using Supplied Macros

              The following program examples show how to use the calling-
              standard macros to define a routine, switch control between
              psects, generate an epilogue sequence, and end the routine.

              Example 6-1 Program Using Supplied Macros

                      $ROUTINE MAIN, KIND=STACK,      - ; Stack routine kind 1
                          SAVED_REGS=<FP>,            - ; Saves FP           2
                          SIZE=48                       ; Stack size is 48   3

                      $LINKAGE_SECTION                  ; Switch to the linkage psect. 4

              X:      .long 6                           ; X is a constant
              FP1_ADDR:                                 ; FP1_ADDR -> FP1
                      .address FP1

                      $DATA_SECTION                     ; Switch to the data section 5
              A::     .blkw 5                           ; $DS points here
              B::     .blkw

                      $CODE_SECTION                     ; Switch to the code section 6
                                                        ; ($CS points here)
                             .
                             .
                             .
                      $RETURN                           ; Perform epilogue and return 7

                      $END_ROUTINE MAIN                 ; Mark the end of the routine 8

              1  $ROUTINE defines the routine MAIN. The routine type is
                 defined as a stack routine using the kind=stack keyword
                 argument.

        6-6

 



                                                 MACRO-64 Supplied Macros
                           6.4 Programming Examples Using Supplied Macros


              2  The keyword argument SAVED_REGS=<FP> adds the frame
                 pointer register to the list of registers saved on the
                 stack by the prologue code. The saved_regs keyword is
                 valid only for stack procedures. If you do not specify
                 the FP register (R29) with this argument, it is assumed.

              3  The keyword argument SIZE=48 defines the stack area
                 in bytes. This argument is valid only for register and
                 stack routines. If you do not specify a stack size for a
                 stack or register routine, $ROUTINE computes the minimum
                 stack size required to accomodate the other arguments
                 you specify or leave as the default.

              4  The LINKAGE_SECTION macro switches to the linkage
                 section. The $LS symbol created by the $ROUTINE macro
                 can be used to point to the address of the current
                 routine's linkage section. $ROUTINE creates the
                 procedure descriptor and leaves the current location
                 counter within the linkage section just beyond the
                 procedure descriptor.

              5  The DATA_SECTION macro switches to the data section.
                 The $DS symbol created by the $ROUTINE macro can be used
                 to point to the address of the current routine's data
                 section.

              6  The CODE_SECTION macro switches to the code section.
                 The $CS symbol created by the $ROUTINE macro is used
                 to point to the address of the current routine's code
                 section.

              7  The $RETURN macro generates a standard epilogue
                 instruction sequence. You can use this macro only with
                 stack or register routine defined with the $ROUTINE
                 macro.

              8  The $END_ROUTINE macro marks the end of the routine.








                                                                      6-7

 



        MACRO-64 Supplied Macros
        6.5 Using the $CALL Macro


        6.5 Using the $CALL Macro

              $CALL calls local or external routines previously defined
              by the $ROUTINE macro or defined in another language.

              To call a routine using standard linkage, use the $CALL
              macro. You invoke this macro from within the routine's code
              section. $CALL performs the following actions:

              o  Searches a list of linkage pairs referenced in previous
                 invocations of the $CALL and $LINKAGE_PAIR macros within
                 the calling routine. If a linkage pair is already found
                 to exist on the list, $CALL uses the linkage pair
                 stored from the previous invocation. Otherwise, $CALL
                 stores the linkage pair of the called routine in the
                 caller's linkage section and adds the linkage pair to
                 the caller's list.

              o  Allocates stack space for arguments, if necessary.

              o  Loads arguments specified with the ARGS argument into
                 argument registers and onto the stack, as appropriate.

              o  Sets the arguments information register, R25, according
                 to the arguments specified with ARGS argument.

              o  Generates the following instruction sequence to perform
                 the actual call based on the location of the linkage
                 pair generated from above, and the value of Rls, linkage
                 register, which is assumed to point to the base of the
                 linkage section:

                          LDQ R26, code_addr_offset(Rls)         ; load code address
                          LDQ R27, proc_desc_addr_offset(Rls)    ; load procedure
                                                                 ; descriptor address
                                                                 ;
                          JSR R26, R26                           ; Jump to the routine
                                                                 ;  saving the return
                                                                 ;  address in R26

              o  Frees argument stack space, if any, and if the called
                 routine doesn't return a value on the stack.

                 Like $ROUTINE, the $CALL macro invokes other macros to
                 perform the above tasks.

        6-8

 



                                                 MACRO-64 Supplied Macros
                                                6.5 Using the $CALL Macro


                 If you do not specify the Rls argument in your
                 invocation of $CALL, $CALL assumes that you have used
                 the .BASE directive to define a register that points to
                 the base address of your linkage section. That is, it
                 assumes that you have included a statement similar to
                 the following:

                 .BASE R27, $LS

                 This source statement defines the base address of the
                 linkage section to be R27, and to be associated with the
                 macro symbol $LS. This source statement should be placed
                 in your source code prior to the $CALL macro call.

        6.5.1 Using $CALL in Source Code

              Example 6-2 uses the source code from Example 6-1, except
              it uses the $CALL macro to show how to call a local and
              external routine.


























                                                                      6-9

 



        MACRO-64 Supplied Macros
        6.5 Using the $CALL Macro


              Example 6-2 Program Using $CALL

                          .
                          .
                          .
                      $CODE_SECTION                     ; Switch to the code section
                                                        ; ($CS points here)
                          .
                          .
                          .
                      MOV     R27,R2    1
                      .base   R2, $LS   2
                          .
                          .
                          .
                      $CALL SUB1                        ; Call external routine SUB1  3
                      $CALL SUB2, LOCAL=TRUE            ; Call local routine SUB2     4
                          .
                          .
                          .
                      $RETURN                           ; Perform epilogue and return
                      $END_ROUTINE MAIN                 ; Mark the end of the routine

              1  The $LS symbol is defined to be the address of the
                 procedure that is defined within the linkage section.
                 The calling routine places the address of the procedure
                 descriptor in R27 before making the call. This
                 guarantees that the address associated with the symbol
                 $LS is stored in R27 upon routine entry. Since the
                 information in R27 is erased during a standard call,
                 a copy is preserved in register R2.

              2  Register R2 now contains the address of our procedure
                 descriptor, which is the base address of our linkage
                 section. Since $LS is defined to point to the base
                 address of the linkage section, the assembler computes
                 the offsets within the linkage section using the .BASE
                 directive.

              3  The $CALL macro calls the external routine SUB1.

              4  The $CALL macro calls the local routine SUB2. This call
                 uses the LOCAL=TRUE keyword argument to indicate that
                 routine SUB2 is defined within the module.

        6-10

 



                                                 MACRO-64 Supplied Macros
                                           6.6 Programming Considerations


        6.6 Programming Considerations

              This section discusses some programming considerations you
              need to be aware of when using the calling-standard macros.

        6.6.1 Making Multiple Calls From the Same Routine

              The $CALL macro generates the following instruction
              sequence:

                  LDQ R26, code_address_offset(Rls)                   ; load code address
                  LDQ R27, procedure_descriptor_address_offset(Rls)   ; load procedure
                                                                      ;    descriptor
                                                                      ;    address
                  JSR R26, R26                                        ;

              The contents of R26 and R27 are erased as a result of
              using the $CALL macro. This is important since Rls in the
              previous sequence is typically R27. Thus, if you require
              subsequent access to your linkage section, such as when
              making subsequent calls, you need to make a working copy of
              R27 to use after the first call. Example 6-2 shows how this
              technique is used.

              Note that $CALL also overwrites the values in the argument
              registers and the scratch registers specified or the
              default set by the SCRATCH_REGS argument, when you pass
              arguments to the called routine

        6.6.2 Non-Standard Linkage

              Under certain circumstances, there may be advantages in
              using a non-standard routine linkage. For more information,
              see Appendix B and the OpenVMS Calling Standard.

        6.6.3 Routine Restrictions

              Different routine types have different capabilities and
              restrictions. For example, only a stack routine that
              specifies BASE_REG_IS_FP=TRUE can make standard calls.
              For more information, see the description for $ROUTINE in
              this chapter.

              For a description of the different capabilities and
              restrictions associated with each routine type, see
              Section B.4 and the OpenVMS Calling Standard.

                                                                     6-11

 



        MACRO-64 Supplied Macros
        6.7 Macro Descriptions


        6.7 Macro Descriptions

              This section provides a detailed description of the
              following MACRO-64 macros:

                 $BEGIN_EPILOGUE
                 $CALL
                 $CODE_SECTION
                 $DATA_SECTION
                 $END_EPILOGUE
                 $END_PROLOGUE
                 $END_ROUTINE
                 $LINKAGE_PAIR
                 $LINKAGE_SECTION
                 $OPDEF
                 $PROCEDURE_DESCRIPTOR
                 $RETURN
                 $ROUTINE

        6.7.1 Syntax Rules

              You may use either positional or keyword argument
              association or a combination of the two with these
              macros. For positional association, the order of formal
              arguments is shown with the format of each macro. For more
              information on argument association, see Chapter 4. The
              following syntax rules apply when invoking the assembler
              using the command line qualifier /NAMES=as_is:

              o  When specifying macro names, you must use all uppercase
                 or all lowercase characters. You cannot use both
                 uppercase and lowercase letters.

              o  When specifying keyword arguments, you must use the same
                 alphabetic case as the macro name it is associated with.
                 If you use lowercase characters with the macro name, you
                 must use lowercase characters with the keyword argument.
                 If you use uppercase characters with the macro name, you
                 must use uppercase characters with the keyword argument.






        6-12

 



                                                          MACRO-64 Macros
                                                          $BEGIN_EPILOGUE


        _________________________________________________________________

        $BEGIN_EPILOGUE

              Marks the beginning of an epilogue instruction sequence.

        Format

              $BEGIN_EPILOGUE

        Description

              $BEGIN_EPILOGUE marks the beginning of an epilogue
              instruction sequence that you code within a stack or
              register routine defined with the $ROUTINE macro.

              At each point where a stack or register routine returns
              to its caller, the routine must perform a sequence of
              operations to restore any saved registers and to perform
              stack frame management. This sequence is called the
              epilogue and is described in detail in the OpenVMS Calling
              Standard.

              You can use the $RETURN macro to generate a standard
              epilogue instruction sequence for you, or you can code your
              own sequence. If you code your own epilogue sequence, you
              must mark the beginning and end of the epilogue sequence
              with the $BEGIN_EPILOGUE and $END_EPILOGUE macros.

        Notes

                 You must not use $BEGIN_EPILOGUE for an epilogue
                 instruction sequence generated by $RETURN. $RETURN
                 automatically invokes $BEGIN_EPILOGUE and $END_EPILOGUE.











                                                                     6-13

 



        MACRO-64 Macros
        $BEGIN_EPILOGUE



        Examples

                        $ROUTINE MUMBLE, KIND=REGISTER, SAVE_FP=R1
                            :
                            :
                            :
                        $BEGIN_EPILOGUE
                        MOV     R1,FP               ; Restore caller's frame
                        RET     (R26)               ; Return to caller
                        $END_EPILOGUE
                            :
                            :
                            :
                        $END_ROUTINE MUMBLE






























        6-14

 



                                                          MACRO-64 Macros
                                                                    $CALL


        _________________________________________________________________

        $CALL

              Issues a call to another routine.

        Format

              $CALL  NAME=routine-being-called -
                     [Rls=linkage-section-register] -
                     [LS=linkage-section-address] -
                     [LOCAL=boolean] -
                     [ARGS=argument-list] -
                     [SET_ARG_INFO=boolean-value] -
                     [STACK_RETURN_VALUE=boolean-value] -
                     [SCRATCH_REGS=scratch_reg-list] -
                     [TIE=boolean-value] -
                     [FUNC_RETURN={I64,D64,I32,U32,FF,FD,FG,FS,FT,FDC,FGC,FSC,FTC}]
                     -
                     [USES_VAX_ARGLIST=boolean-value] -
                     [SIGNATURE_BLOCK=signature_address] -
                     [NONSTANDARD=boolean-value] -

        Parameters

              NAME
              The name of the routine to call. This argument is required.

              Rls
              Linkage section register to use when generating the LDQ,
              LDQ, JSR instruction sequence. This argument is optional.

              If Rls is omitted, $CALL assumes that you have issued a
              .BASE directive prior to invoking $CALL that establishes
              the value of a base register pointing into the linkage
              section. If you omit the Rls argument and you do not
              issue such a .BASE directive prior to invoking $CALL, the
              assembler issues the following error message during the
              $CALL macro expansion:

                  "Argument 2 invalid"  The assembler failed to find a base register
                   specified with a previous .BASE directive to form a register
                   expression of the form offset(Rn)"


                                                                     6-15

 



        MACRO-64 Macros
        $CALL


              LS
              LS is the address of the linkage section. If you use
              $CALL within a routine defined by the $ROUTINE macro,
              the LS argument defaults to the $LS symbol defined by
              $ROUTINE. If you use $CALL outside of a routine defined
              by the $ROUTINE macro, there are two ways that you can
              indicate the location of the linkage section to $CALL.
              First, you can specify the LS argument to $CALL as a
              relocatable address expression that indicates the base
              of the linkage section. In this case you must also specify
              the Rls argument. Second, you can specify both the linkage-
              section base register and the linkage section address in a
              .BASE directive prior to invoking $CALL. In this case, you
              must omit both the Rls and LS arguments to $CALL.

              Digital recommends that you omit this argument if you use
              $CALL within a routine defined by the $ROUTINE macro.

              LOCAL
              A boolean value (TRUE or FALSE) that specifies whether the
              routine to be called is local to the module or globally
              visible. By default, $CALL generates a call to a globally
              visible routine. To generate a call to a routine that is
              not globally visible, you must specify LOCAL=TRUE.

              ARGS
              An optional list of arguments to pass to the called
              routine. Enclose the argument list within angle brackets
              (<>), and separate the arguments with commas (,).  You
              can use the following qualifiers with each argument you
              specify with the ARGS argument. Table 6-1 describes these
              qualifiers. Each argument is an address expression (which
              may include a register), followed by a qualifier. The table
              also contains the argument type, the instruction used to
              load the argument into a register, the instruction used
              to store the argument on the stack, and the encodings used
              in the Argument Information Register (R25) in the call
              signature block when you specify TIE=TRUE. See the OpenVMS
              Calling Standard for more information on these encodings.
              Note that arguments are only stored on the stack if there
              are more than six arguments provided to the routine.




        6-16

 



                                                          MACRO-64 Macros
                                                                    $CALL


              Table_6-1_ARGS_Arguments___________________________________

              Argument                                  Reg
                      Argument  LOAD    STORE   AI      Arg     Mem Arg
              QualifieType______InstructInstructionodingSignaturSignature

              /A      Address   LDA     STQ     I64     I64     I64

              /D      D-        LDG     STG     FD      FD      I64
                      floating

              /F      F-        LDF     STF     FF      FF      I64
                      floating

              /G      G-        LDG     STG     FG      FG      I64
                      floating

              /L      Longword  LDL     STQ     I64     I32     I32

              /Q      Quadword  LDQ     STQ     I64     I64     I64

              /S      S-        LDS     STS     FS      FS      I64
                      floating

              /T      T-        LDT     STT     FT      FT      I64
                      floating

              /UL[1]  Unsigned  LDL     STQ     I64     U32     I64
                      longword  /ZAP
                                #^xF0
              [1]Unsigned_32-bit_integers_are_normally_passed_using______

              the /L argument qualifier. Therefore, Digital does not
              recommend that you use the /UL argument qualifier.
              ___________________________________________________________

              SET_ARG_INFO
              An optional argument to indicate whether $CALL should
              set the Argument Information (AI) register (R25) with the
              appropriate argument information or not. By default or if
              you specify SET_ARG_INFO=TRUE, $CALL stores the appropriate
              argument information in R25. If specify SET_ARG_INFO=FALSE,
              $CALL does not affect R25. In this case, you must store
              the appropriate information in R25 yourself before invoking
              $CALL.

              STACK_RETURN_VALUE
              An optional argument to indicate that the called routine
              returns a value on the stack. By default, $CALL assumes
              that the called routine does not return a value on the
              stack. In this case, $CALL removes any arguments passed to

                                                                     6-17

 



        MACRO-64 Macros
        $CALL


              the called routine from the stack when the called routine
              returns.

              If the called routine returns a value on the stack, the
              returned value is placed at a lower address than the
              arguments on the stack. In this case, you must specify
              STACK_RETURN_VALUE=TRUE to prevent $CALL from removing the
              arguments to the called routine from the stack and erasing
              the value returned by the called routine. You must retrieve
              the return value and remove it from the stack. Then you
              can remove the arguments to the called routine using the
              $STACK_ARG_SIZE symbol defined by $CALL.

              SCRATCH_REGS
              An optional list of scratch registers for $CALL to use when
              processing arguments passed to the called routine with the
              ARGS argument. If you pass more than six arguments to the
              called routine, $CALL may need to use scratch registers to
              process the call.

              By default, $CALL uses R0, R1, F0, and F1. You can
              cause $CALL to use different scratch registers with the
              SCRATCH_REGS argument.

              If you are passing integer arguments, you should specify
              at least one integer register. If you are passing floating-
              point arguments, you should specify at least one floating-
              point register.

              $CALL can process arguments to the called routine more
              efficiently if you specify two or more scratch registers
              of the type or types appropriate to the arguments you are
              passsing.

              TIE
              A boolean value (TRUE or FALSE) that specifies whether
              $CALL should generate a call sequence that is compatible
              with both native routines and the Translated Image
              Environment (TIE). By default, $CALL generates a faster
              call sequence that is only compatible with native routines.
              If you specify TIE=TRUE, $CALL generates a call sequence
              that works with both native routines and translated
              routines. If you are calling a VAX routine in a sharable
              image that has been translated with the DECmigrate image
              translator, specify TIE=TRUE. If you are calling a native
              routine, Digital recommends you default the TIE argument

        6-18

 



                                                          MACRO-64 Macros
                                                                    $CALL


              or specify TIE=FALSE. While $CALL generates a call sequence
              that is compatible with native routines when you specify
              TIE=TRUE, that call sequence is slower than when you
              specify or default TIE=FALSE.

              FUNC_RETURN
              An optional argument used to indicate the type of function
              return when you also specify TIE=TRUE. Note that this
              argument is ignored unless you also specify TIE=TRUE.
              Specify one of I64, D64, I32, U32, FF, FD, FG, FS, FT,
              FFC, FDC, FGC, FSC, or FTC. These values correspond to the
              RASE$K_FR_* signature encodings described in table 3-7 in
              the VMS Calling Standard. If you specify TIE=TRUE and do
              not specify a function return type with FUNC_RETURN, the
              default function return type is I64.

                ________________________ Note ________________________

                Specification of the FUNC_RETURN argument does not
                in itself cause $ROUTINE to generate a procedure
                signature block. However, if you specify either or
                both the ARGLIST or USES_VAX_ARGLIST arguments, any
                value you specify with the FUNC_RETURN argument is
                recorded in both the procedure descriptor and the
                procedure signature block.

                ______________________________________________________

              USES_VAX_ARGLIST
              An optional argument to indicate whether the called routine
              uses a VAX argument list. Note that this argument is
              ignored unless you also specify TIE=TRUE. By default, $CALL
              assumes the called routine does not use a VAX argument
              list. Specify USES_VAX_ARGLIST=TRUE to indicate that the
              called routine uses a VAX argument list.

              SIGNATURE_BLOCK
              An optional argument that you can use to supply the address
              of the call signature block. Note that this argument
              is ignored unless you also specify TIE=TRUE. Note also
              that you cannot specify a SIGNATURE_BLOCK argument in
              combination with either of the FUNC_RETURN or USES_VAX_
              ARGLIST arguments. By default, $CALL generates a call
              signature block for you when you specify TIE=TRUE, and
              you can in part control the contents of that signature

                                                                     6-19

 



        MACRO-64 Macros
        $CALL


              block with the FUNC_RETURN and USES_VAX_ARGLIST arguments.
              If you wish to define your own call signature block, do
              not specify either of the FUNC_RETURN or USES_VAX_ARGLIST
              arguments and supply the address of your call signature
              block with the SIGNATURE_BLOCK argument.

              NONSTANDARD
              A boolean value (TRUE or FALSE) that specifies whether
              $CALL should suppress warning and informational messages
              concerning non-standard usage. By default, $CALL issues
              warning and informational messages to indicate you
              are using $CALL in a way that violates the VMS Calling
              Standard or in a way that requires special programming
              considerations. Specify NONSTANDARD=TRUE if you wish to
              suppress these messages.

        Description

              $CALL issues a call to another routine and performs the
              following actions:

              1. Searches a list of linkage pairs referenced in previous
                 invocations of the $CALL and $LINKAGE_PAIR macros. If
                 a linkage pair is already in the list, $CALL uses the
                 linkage pair from the previous invocation. Otherwise,
                 $CALL stores the linkage pair of the called routine in
                 the caller's linkage section and adds the linkage pair
                 to the caller's list. If you use $CALL within a routine
                 defined with the $ROUTINE macro, $CALL and $LINKAGE_PAIR
                 reset the list of linkage pairs for each routine.

              2. Allocates stack space for arguments if necessary.

              3. Generates instructions to load the arguments to the
                 called routine.

              4. Sets the value in the argument information register,
                 R25.

              5. Generates the instruction sequence shown below to
                 perform the actual call based on the location of
                 the linkage pair generated from Step 1 above and the
                 address specified or defaulted with the LS argument. The
                 register specified with the Rls argument is assumed to
                 point to the base of the linkage section as shown in the
                 following example:

        6-20

 



                                                          MACRO-64 Macros
                                                                    $CALL


                     LDQ R26, code_address_offset(Rls)                   ; load code address
                     LDQ R27, procedure_descriptor_address_offset(Rls)   ; load procedure
                                                                         ;    descriptor
                                                                         ;    address
                     JSR R26, R26

              6. Frees argument stack space, if any, and if the called
                 routine does not return a value on the stack.

        Examples

                 Example 1

                    $CALL SUB1, Rls=R13, LS=MY_LINKAGE_SECTION
                    .BASE R13, MY_LINKAGE_SECTION
                    $CALL SUB2

                    $ROUTINE SUB3, KIND=STACK, SAVED_REGS=<R2,FP>
                    $LINKAGE_SECTION
                    .QUAD 1
                XX:
                    $CODE_SECTION
                    MOV R27, R2
                    $CALL SUB4, R2
                    .BASE R2, $LS
                    $CALL SUB5
                    $CALL SUB6, -
                       ARGS=<XX/A, R0/Q>, -
                       SCRATCH_REGS=<R22,R23>
                    $CALL SUB7, -
                       ARGS=<1/A,2/A,3/A>
                    $RETURN
                    $END_ROUTINE SUB3

                 Example 2

                $CALL FOO, ARGS=<A,B,C,D,E,F,G,H>, STACK_RETURN_
        VALUE=TRUE
                                                ; Fetch octaword return value from stack
                LDQ R4, 0(SP)                   ; low quadword
                LDQ R5, 8(SP)                   ; high quadword
                LDA SP, $STACK_ARG_SIZE+16(SP)  ; RESET STACK



                                                                     6-21

 



        MACRO-64 Macros
        $CODE_SECTION


        _________________________________________________________________

        $CODE_SECTION

              Switches control to the current routine's code section
              psect.

        Format

              $CODE_SECTION

        Description

              $CODE_SECTION switches control to the current routine's
              code section psect.

        Examples

                  $CODE_SECTION


























        6-22

 



                                                          MACRO-64 Macros
                                                            $DATA_SECTION


        _________________________________________________________________

        $DATA_SECTION

              Switches control to the current routine's data section
              psect.

        Format

              $DATA_SECTION

        Description

              $DATA_SECTION switches control to the current routine's
              data section psect.

        Examples

                $DATA_SECTION


























                                                                     6-23

 



        MACRO-64 Macros
        $END_EPILOGUE


        _________________________________________________________________

        $END_EPILOGUE

              Marks the end of an epilogue instruction sequence.

        Format

              $END_EPILOGUE

        Description

              You can use the $END_EPILOGUE macro to mark the end of
              an epilogue instruction sequence that you code yourself
              within a stack or register routine defined with the
              $ROUTINE macro. At each point where a STACK or REGISTER
              routine returns to its caller, the routine must perform a
              sequence of operations to restore any saved registers and
              to perform stack-frame management. This sequence is called
              the epilogue and is described in detail in the OpenVMS
              Calling Standard.

              You can use the $RETURN macro to generate a standard
              epilogue instruction sequence for you. Alternatively,
              you can code your own sequence. If you code your own
              epilogue sequence, you must mark the beginning and end
              of the epilogue sequence with the $BEGIN_EPILOGUE and
              $END_EPILOGUE macros, respectively.

              Note that you must not use $END_EPILOGUE for an epilogue
              instruction sequence generated by $RETURN. $RETURN invokes
              $BEGIN_EPILOGUE and $END_EPILOGUE for you.

              You may omit the invocation of $END_EPILOGUE if your
              epilogue sequence occurs at the end of the routine.
              The $END_ROUTINE macro invokes $END_EPILOGUE for you if
              you invoke the $BEGIN_EPILOGUE macro without a matching
              invocation of the $END_EPILOGUE macro. You must invoke
              $END_EPILOGUE with epilogue sequences that occur in the
              middle of your routine.





        6-24

 



                                                          MACRO-64 Macros
                                                            $END_EPILOGUE



        Examples

                        $ROUTINE MUMBLE, KIND=REGISTER, SAVE_FP=R1
                            :
                            :
                            :
                        $BEGIN_EPILOGUE
                        MOV     R1,FP               ; Restore caller's frame
                        RET     (R26)               ; Return to caller
                        $END_EPILOGUE
                            :
                            :
                            :
                        $END_ROUTINE MUMBLE






























                                                                     6-25

 



        MACRO-64 Macros
        $END_PROLOGUE


        _________________________________________________________________

        $END_PROLOGUE

              Marks the end of a prologue instruction sequence.

        Format

              $END_PROLOGUE

        Description

              $END_PROLOGUE marks the end of a routine prologue
              instruction sequence that you code yourself. The prologue
              instruction sequence begins with the first instruction of
              the routine. There can only be one prologue instruction
              sequence in a routine. The prologue is described in detail
              in the OpenVMS Calling Standard.

              You invoke $END_PROLOGUE after the last instruction in
              the routine prologue code. The last instruction in the
              routine prologue is the one that updates FP (R29, the frame
              pointer) and makes the frame become current. You must use
              this macro when the routine type is stack or register and
              you specify STANDARD_PROLOGUE=FALSE to the $ROUTINE macro.

        Notes

                 Do not use this macro when the $ROUTINE macro generates
                 a standard prologue or when the routine type is null or
                 bound. For example, a standard prologue is generated for
                 you when you specify or leave the default of $ROUTINE's
                 STANDARD_PROLOGUE argument to TRUE.

        Examples

                        MOV     SP, FP
                        $END_PROLOGUE







        6-26

 



                                                          MACRO-64 Macros
                                                             $END_ROUTINE


        _________________________________________________________________

        $END_ROUTINE

              Marks the end of a routine.

        Format

              $END_ROUTINE  [name=routine-name]

        Parameters

              name
              The name of the routine that is ended. This argument is
              optional. If you specify a name, $END_ROUTINE verifies that
              the name matches that which was specified with $ROUTINE to
              begin the routine. If the name does not match, $END_ROUTINE
              issues a diagnostic message. There is no default. If you
              omit the name, $END_ROUTINE does not verify a matching
              name.

        Description

              You must use this macro at the end of a routine that is
              defined with the $ROUTINE macro to delimit the end the
              current routine and to perform final macro processing of
              the routine.

        Examples

                    $END_ROUTINE NAME=FOOZLE














                                                                     6-27

 



        MACRO-64 Macros
        $LINKAGE_PAIR


        _________________________________________________________________

        $LINKAGE_PAIR

              Locates or defines a linkage pair in the linkage psect.

        Format

              $LINKAGE_PAIR  name, local=boolean

        Parameters

              name
              Name of the linkage pair to define. This argument is
              required.

              local
              A boolean value (TRUE or FALSE) that specifies whether the
              routine is defined within the module for not. The default
              is to store a linkage pair for a global routine. You must
              specify LOCAL=TRUE to store a linkage pair for a routine
              that is not globally visible.

        Description

              You can invoke this macro to locate or define a linkage
              pair in the linkage psect. The linkage pair is added
              to a list for later use and retrieval by the $CALL and
              $LINKAGE_PAIR macros. Thus, only the first invocation of
              $LINKAGE_PAIR (or $CALL) for a given routine to be called
              results in a linkage pair being stored. $LINKAGE_PAIR and
              $CALL use the same list of linkage pairs. The $ROUTINE
              macro resets this list. $LINKAGE_PAIR restores the current
              psect when it is done.

              $LINKAGE_PAIR defines the symbol $LP. This symbol value is
              the address within the linkage section of the linkage pair
              for the specified routine to call.







        6-28

 



                                                          MACRO-64 Macros
                                                            $LINKAGE_PAIR



        Notes

                 Because the $CALL macro invokes the $LINKAGE_PAIR macro
                 for you, you do not need to use $LINKAGE_PAIR when you
                 are using $CALL. You may wish to use $LINKAGE_PAIR
                 when you are not using $CALL or when you require a
                 specific ordering or placement of linkage pairs within
                 the linkage section.

        Examples

                    $LINKAGE_
        PAIR SUB1          ; define linkage pair in linkage section
                    LDQ R26, $LP
                    LDQ R27, $LP+8
                    JSR R26, R26




























                                                                     6-29

 



        MACRO-64 Macros
        $LINKAGE_SECTION


        _________________________________________________________________

        $LINKAGE_SECTION

              $LINKAGE_SECTION switches control to the current routine's
              linkage section psect.

        Format

              $LINKAGE_SECTION

        Description

              $LINKAGE_SECTION switches control to the current routine's
              linkage section psect.

        Examples

                $LINKAGE_SECTION


























        6-30

 



                                                          MACRO-64 Macros
                                                                   $OPDEF


        _________________________________________________________________

        $OPDEF

              Used to define opcodes.

        Format

              $OPDEF  MNEMONIC, FORMAT, ENCODING

        Parameters

              MNEMONIC
              MNEMONIC is the mnemonic name by which the instruction
              is called. You may optionally specify a qualifier list
              separated from the name by a slash (/). A qualifier list
              is a sequence of one or more letters or digits with no
              intervening spaces or separators.

              FORMAT
              FORMAT is one of the following arguments:

        _________________________________________________________________
        Format__________________________Description______________________

        MEMORY                          Standard memory format
                                        instructions.

        MEMORY_FUNCTION                 Memory format instructions with a
                                        function code.

        JUMP                            Memory format instructions
                                        formatted like jump instructions.

        BRANCH                          Standard branch format
                                        instructions.

        OPERATE                         Standard operate instructions.

        FLOATING_OPERATE                Standard floating-point operate
                                        instructions.

        PAL                             Standard PALcode instructions.

        [<]CUSTOM[=operand_type_list>]__Custom_format.___________________

              With the CUSTOM format, you may optionally specify a list
              of the types of operands the instruction is to accept. If
              you specify a list of operand types, you must enclose the
              entire FORMAT argument within angle brackets, and you must
              specify the operand types in the order they are to be used

                                                                     6-31

 



        MACRO-64 Macros
        $OPDEF


              with the instruction. $OPDEF supports the following operand
              types:

              IREGISTER        Integer register, such as R5 or SP.

              FREGISTER        Floating-point register, such as F7.

              LITERAL          Integer literal, such as #123 or 32767.

              INDIRECT         Indirect integer register notation such as
                               (R7).

              DISPLACEMENT     Indirect integer register notation with
                               an integer literal displacement, such as
                               FOO(R12).

              BRANCH_OFFSET    Label or address expression, such as L1.

              For example:

              FORMAT=<CUSTOM=IREGISTER,DISPLACEMENT>

              For a detailed description of instruction formats, see the
              Alpha Architecture Reference Manual.

              ENCODING
              ENCODING is the numeric encoding for the instruction
              opcode. The default radix is decimal, as is the case for
              all assembler constants. Prefix the value with ^X for
              hexidecimal. Certain instruction formats allow multi-part
              encoding:














        6-32

 



                                                          MACRO-64 Macros
                                                                   $OPDEF

              ___________________________________________________________
              Format________________Encoding_Description_________________

              MEMORY_FUNCTION       Specify the base opcode, followed by
                                    a dot, followed by the function code.
                                    For example:

                                    ENCODING=^X10.F000

              JUMP                  Specify the base opcode, optionally
                                    followed by a dot, and the hardware-
                                    hint bits optionally followed by a
                                    dot and the software-hint bits. For
                                    example:

                                    ENCODING=^X1A.2.1

              OPERATE               Specify the base opcode, followed by
                                    a dot, followed by the function code.
                                    For example:

                                    ENCODING=^X12.3C
                                    ex

              FLOATING_OPERATE      Specify the base opcode, followed by
                                    a dot, followed by the function code.
                                    For example:

                                    ENCODING=^X17.02B

              PAL                   Specify the base opcode, optionally
                                    followed by a dot and the function
                                    code. Omit the function code for a
                                    generic PAL instruction that accepts
                                    an integer-expression argument. For
                                    example:

                                    ENCODING=^X0.0080
                                    ENCODING=^X19

              CUSTOM                Specify a comma-separated list of bit
                                    ranges and values to place in those
                                    bit ranges. For example:

                                    ENCODING = < 26:31=^X14, 21:25=%OP1, -

              ___________________________________16:20=%OP2.REG,_0:15=%OP2.DISP >

              For CUSTOM format instructions, specify the ENCODING
              argument as a comma separated list of bit ranges and values
              to place in those bit ranges. Enclose the list within angle
              brackets.

                                                                     6-33

 



        MACRO-64 Macros
        $OPDEF


              Specify a bit range as start:end where start and end are
              integer constant expressions. For a 1-bit bit range, start
              and end are equal. Bit positions range from 0 to 31. Place
              an equal sign (=) after the bit range specifier followed
              by the value you wish to put in the bit range. You can
              place either a constant integer expression or an operand
              into the bit range. Start and end expressions and integer
              constant expressions must not reference any external
              symbols or symbols not yet defined in the assembly. $OPDEF
              evaluates these expressions at the time that it defines the
              instruction as opposed to when the defined instruction is
              referenced.

              Operand names are of the form %OPn, where n is the ordinal
              number of the operand as specified from left to right with
              the FORMAT argument.

              For IREGISTER, FREGISTER, and INDIRECT operands, $OPDEF
              places the 5-bit register number into the bit positions you
              specify.

              For LITERAL operands, $OPDEF places the literal value of
              the operand into the bit positions you specify. Operand
              literal values can be up to 32-bits long. The most
              significant bits are truncated if the size of the operand
              literal value exceeds the bit range you specify.

              For DISPLACEMENT operands, $OPDEF defines two parts: a 5-
              bit register number and a displacement value that can be
              up to 32-bits long. The most significant bits are truncated
              from the displacement value if the size of the displacement
              value exceeds the bit range you specify. You can reference
              the register number by placing .REG after the operand name.
              For example: %OP2.REG. Similarly, you can reference the
              displacement value by placing .DISP after the operand name.
              For example: %OP2.DISP.

              For BRANCH_OFFSET operands, $OPDEF stores the signed
              longword offset between the next instruction and the
              specified address in the bit positions you specify. The
              address expression specified for a BRANCH_OFFSET operand
              can be a backward or forward reference to a location within
              the current psect. It cannot be an external address or an
              address in a different psect. The resulting offset can be
              up to 32-bits in size. If the size of the offset exceeds

        6-34

 



                                                          MACRO-64 Macros
                                                                   $OPDEF


              the bit range you specify, the most significant bits are
              truncated.

              $OPDEF fills any bit positions you leave unspecified with
              zeros.

        Description

              The $OPDEF macro can be used to define your own opcodes.

              $OPDEF defines a macro using an unqualified version of the
              mnemonic name you specify. When this macro is invoked with
              the instruction qualifiers you specify when you define
              it with $OPDEF (if any), it expands to the instruction
              representation you have defined with $OPDEF. Note that
              you can specify the qualfiers in any order as long as the
              combination of qualifiers you use is the same.

              Other uses of the mnemonic name remain vaild provided
              you do not use the mnemonic name as a macro name in a
              .MACRO directive. For instance, you can use the same
              mnemonic name in the opcode field with different or no
              qualifiers. If the qualifiers (or absence thereof) do
              not match those specified in your $OPDEF instruction
              definition, the macro defined by $OPDEF processes as
              though you had not defined an instruction by that mnemonic
              name. To do so, it expands to a single statement. This
              expansion statement is identical to the mnemonic-name macro
              invocation statement, except it is processed in a context
              that prevents the mnemonic-name macro from expanding
              recursively. Instead, the statement is processed as a
              normal, MACRO-64 instruction statement. In this case, you
              may notice references to the mnemonic-name macro expansion
              in a MACAUXMSG diagnostic message, if the instruction
              statement contains errors.

              For instance, if you define a STQ/P instruction using
              $OPDEF, you can still use the STQ instruction without the
              /P qualifier. If you do, and your STQ instruction statement
              contains an error, the assembler generates a MACAUXMSG
              message indicating that the error occured during the
              expansion of macro STQ. Aside from the fact that the STQ
              instruction is processed in the context of the expansion of
              the STQ macro, $OPDEF's definition of the STQ/P instruction
              has no effect on your use of the STQ instruction.

                                                                     6-35

 



        MACRO-64 Macros
        $OPDEF



        Examples

                $OPDEF MNEMONIC=BANG, FORMAT=PAL, -
                       ENCODING=^X0.0099








































        6-36

 



                                                          MACRO-64 Macros
                                                                  .PACKED


        _________________________________________________________________

        .PACKED

              Packed decimal string storage macro.

        Format

              .PACKED  decimal-string[,symbol]

        Parameters

              decimal-string
              A decimal number from 0 to 31 digits long with an optional
              sign. Digits can be in the range 0 to 9.

              symbol
              An optional symbol that is assigned a value equivalent to
              the number of decimal digits in the string. The sign is not
              counted as a digit.

        Description

              .PACKED generates packed decimal data, two digits per byte.
              Packed decimal data is useful in calculations requiring
              exact accuracy. It is operated on by the decimal string
              instructions.

              A packed decimal string is a contiguous sequence of bytes
              in memory. It is specified by two attributes: the address
              A of the first byte and a length L, which is the number
              of digits in the string and not the length of the string
              in bytes. The bytes of a packed decimal string are divided
              into two, 4-bit fields (nibbles). Each nibble except the
              low nibble (bits 3:0) of the last (highest-addressed)
              byte must contain a decimal digit. The low nibble of
              the highest-addressed byte must contain a sign. The
              representation for the digits and sign is indicated as
              follows:






                                                                     6-37

 



        MACRO-64 Macros
        .PACKED

              ___________________________________________________________
              Digit
              or
              Sign___Decimal__________Hexadecimal________________________

              0      0                0
              1      1                1
              2      2                2
              3      3                3
              4      4                4
              5      5                5
              6      6                6
              7      7                7
              8      8                8
              9      9                9
              +      10,12,14, or 15  A,C,E, or F
              -______11_or_13_________B_or_D_____________________________

              The preferred sign representation is 12 for plus (+) and
              13 for minus (-). The length L is the number of digits in
              the packed decimal string (not counting the sign); L must
              be in the range 0 to 31. When the number of digits is odd,
              the digits and the sign fit into a string of bytes whose
              length is defined by the following equation: L/2(integer
              part only) + 1. When the number of digits is even, it is
              required that an extra zero appear in the high nubble (bits
              7:4) of the first byte of the string. Again, the length in
              bytes of the string is L/2 + 1.

              The address A of the string specifies the byte of the
              string containing the most-significant digit in its high
              nibble. Digits of decreasing significance are assigned
              to increasing byte addresses and from high nibble to low
              nibble within a byte. Thus +123 has a length of 3 and is
              represented as follows:

              7    4 3    0
              +-----+------+
              |  1  |   2  |  :A
              +-----+------+
              |  3  |  12  |  :A+1
              +-----+------+




        6-38

 



                                                          MACRO-64 Macros
                                                                  .PACKED


              The packed decimal number -12 has a length of 2 and is
              represented as follows:

              7    4 3    0
              +-----+------+
              |  0  |   1  |  :A
              +-----+------+
              |  2  |  13  |  :A+1
              +-----+------+

        Examples

                .PACKED -12,PACKED_SIZED        ; PACKED_
        SIZE gets value of 2
                .PACKED +500
                .PACKED 0
                .PACKED -0,SUM_SIZE             ; SUM_
        SIZE gets value of 1



























                                                                     6-39

 



        MACRO-64 Macros
        $PROCEDURE_DESCRIPTOR


        _________________________________________________________________

        $PROCEDURE_DESCRIPTOR

              Defines a procedure descriptor structure at the current
              psect and offset.

        Format

              $PROCEDURE_DESCRIPTOR

        Description

              The arguments for the $PROCEDURE_DESCRIPTOR macro are the
              same as the $ROUTINE macro, with the following exceptions:

              o  The ENTRY argument is required.

              o  There are no CODE_SECTION, LINKAGE_SECTION,
                 DATA_SECTION, DATA_SECTION_POINTER, or STANDARD_PROLOGUE
                 arguments.

              o  There is an additional END_PROLOGUE argument. This
                 argument must be a label that you define at the end
                 of the routine's prologue sequence. This argument is
                 required for stack and register procedure types.

        Notes

                 Because the $ROUTINE macro invokes the
                 $PROCEDURE_DESCRIPTOR macro for you, you do not need to
                 use the $PROCEDURE_DESCRIPTOR macro if you use $ROUTINE.
                 You may wish to use $PROCEDURE_DESCRIPTOR when you are
                 not using $ROUTINE.

        Examples

                    $PROCEDURE_DESCRIPTOR p1,           -
                                      KIND=NULL,        -
                                      ENTRY=p1_entry





        6-40

 



                                                          MACRO-64 Macros
                                                                  $RETURN


        _________________________________________________________________

        $RETURN

              Generates a standard epilogue instruction sequence.

        Format

              $RETURN

        Description

              Generates a standard epilogue instruction sequence when
              used within a stack or register routine defined with the
              $ROUTINE macro. The epilogue sequence generated by $RETURN
              restores any registers you specify with the SAVED_REGS
              argument to $ROUTINE and performs stack frame management
              as necessary. You can use $RETURN whether you specify or
              default STANDARD_PROLOGUE as TRUE or not.

              You can use $RETURN any number of times within a given
              stack or register routine to affect a return to the calling
              routine.

              You must not use the $BEGIN_EPILOGUE or $END_EPILOGUE
              macros for an epilogue sequence generated by $RETURN.
              $RETURN invokes $BEGIN_EPILOGUE and $END_EPILOGUE for you.

        Examples

                $ROUTINE FOOZLE, KIND=REGISTER, SAVE_FP=R1
                    :
                    :
                    :
                $RETURN
                $END_ROUTINE FOOZLE









                                                                     6-41

 



        MACRO-64 Macros
        $ROUTINE


        _________________________________________________________________

        $ROUTINE

              Defines the current routine and creates a context for the
              routine.

        Format

              $ROUTINE  NAME=routine name -
                        ALIASES=alias names -
                        LOCAL=boolean value -
                        STANDARD_PROLOGUE=boolean value ENTRY=code entry
                        point -
                        CODE_SECTION=code section psect name -
                        DATA_SECTION=data section psect name -
                        DATA_SECTION_POINTER=boolean value -
                        LINKAGE_SECTION=linkage section psect name -
                        KIND=routine type-
                        HANDLER_REINVOKABLE=boolean value -
                        BASE_REG_IS_FP=boolean value-
                        REI_RETURN=boolean value -
                        STACK_RETURN_VALUE=boolean value -
                        RSA_OFFSET=integer value -
                        SAVE_FP=FP register name -
                        SAVE_RA=return address register name -
                        SIZE=numeric value -
                        SAVED_REGS=list of registers -
                        HANDLER=exception handler address -
                        HANDLER_DATA=data address for exception handler -
                        SYNCH_EXCEPTIONS=boolean value-
                        PROC_VALUE=procedure value -
                        ENVIRONMENT=environment value -
                        FUNC_RETURN=function return type -
                        ARGLIST=Argument type list -
                        USES_VAX_ARGLIST=boolean value -
                        OVERRIDE_FLAGS=procedure descriptor flags -
                        DEFAULT_SIGNATURE=boolean value -
                        COMMON_BASE=list of registers






        6-42

 



                                                          MACRO-64 Macros
                                                                 $ROUTINE



        Parameters

              NAME
              The name of the routine. This argument is required for all
              procedure kinds. There is no default. For example:

              NAME=FOOZLE

              ALIASES
              List of alias names for the routine. This argument is
              optional for all procedure types. There is no default.
              For example:

              ALIASES=<FOO,BAR,FOOBAR,foo,bar,foobar,Foo,Bar,FooBar>

              LOCAL
              Boolean value indicating whether the routine is local
              (TRUE) or externally visible (FALSE). This argument is
              optional for all procedure kinds. The default is FALSE. For
              example:

              LOCAL=TRUE

              STANDARD_PROLOGUE
              Specifies a boolean value to indicate whether $ROUTINE
              should generate a standard, instruction prologue sequence
              at the beginning of the routine's code section. This
              argument is optional and valid only with REGISTER and
              STACK procedures. If the procedure type is stack or
              register , the default is TRUE and $ROUTINE generates a
              standard prologue sequence. The prologue sequence generated
              by $ROUTINE saves the registers you specify with the
              SAVED_REGS argument and performs stack-frame management
              as necessary.

              If you also specify BASE_REG_IS_FP=FALSE, the standard
              prologue sequence generated by $ROUTINE makes a copy of the
              procedure descriptor address that is in R27 upon entry into
              R29 (FP). While you cannot change the value in R29 prior to
              the epilogue, you can use R29 as a working, linkage-section
              register. If you specify the STANDARD_PROLOGUE argument
              as FALSE, you must code your own prologue sequence and
              mark the end of the prologue with the $END_PROLOGUE macro.
              Whether you specify or default STANDARD_PROLOGUE as TRUE
              or not, you can generate a standard epilogue sequence for

                                                                     6-43

 



        MACRO-64 Macros
        $ROUTINE


              stack and register procedures with the $RETURN macro. For
              example:

              STANDARD_PROLOGUE=FALSE

              ENTRY
              The name of the code-entry point. This argument is the
              code entry-point label that $ROUTINE defines for you at
              the beginning of the code section for the routine. If
              this argument is omitted, $ROUTINE generates a label. For
              example:

              ENTRY=FOOZLE_ENTRY

              CODE_SECTION
              The psect name and attributes of the code section. This
              argument is optional for all procedure kinds. If omitted,
              the default is the name and attributes defined by the
              $CODE$ lexical string symbol. If you specify a name
              and attributes for the CODE_SECTION argument, $ROUTINE
              redefines the $CODE$ lexical string symbol such that the
              specified values become the new default. Initially, $CODE$
              is defined as follows:

              $CODE$ = "$CODE$,OCTA,PIC,CON,REL,LCL,SHR,EXE,NORD,NOWRT"

              Since you must delimit the psect name and attributes using
              commas, be sure to enclose this argument within angle
              brackets to avoid having the assembler interpret the name
              and attributes as different arguments to $ROUTINE. For
              example:

              CODE_SECTION=<MY_CODE,EXE,QUAD,NOWRT>

              DATA_SECTION
              The psect name and attributes of the data section. This
              argument is optional for all procedure kinds. If omitted,
              the default is the name and attributes defined by the
              $DATA$ lexical string symbol. If you specify a name
              and attributes for the DATA_SECTION argument, $ROUTINE
              redefines the $DATA$ lexical string symbol such that the
              specified values become the new default. Initially, $DATA$
              is defined as follows:

              $DATA$ = "$DATA$,OCTA,NOPIC,CON,REL,LCL,NOSHR,NOEXE,RD,WRT"

        6-44

 



                                                          MACRO-64 Macros
                                                                 $ROUTINE


              Since you must delimit the psect name and attributes using
              commas, be sure to enclose this argument within angle
              brackets to avoid having the assembler interpret the name
              and attributes as different arguments to $ROUTINE. For
              example:

              DATA_SECTION=<MY_DATA,NOEXE,QUAD,RD,WRT>

              DATA_SECTION_POINTER
              Boolean value indicating whether $ROUTINE should store a
              pointer to the data section in the linkage section and
              define $DP as the address of that pointer. This argument is
              optional for all procedure kinds. The default is FALSE. For
              example:

              DATA_SECTION_POINTER=TRUE

              You can use the DATA_SECTION_POINTER argument as follows:

                          $routine TALLY_HO, data_section_pointer=TRUE
                          $data_section
                  TALLY:  .quad 0
                          $code_section
                          .base       R27, $LS        ; Inform assembler that R27->$LS
                          LDQ         R1, $DP         ; R1->$DS
                          .base R1,$DS                ;Inform assembler that R1-$DS
                          LDQ         R0, TALLY       ; R0<-TALLY
                          LDA         R0, 1(R0)       ; R0<-R0++
                          STQ         R0, TALLY       ; TALLY<-R0
                          RET         (R26)           ; Return
                          $end_routine TALLY_HO

              In this example, the DATA_SECTION_POINTER argument is
              specified in order to obtain linkage to the data section.
              The first LDQ instruction loads R1 with the pointer to the
              data section that $ROUTINE stores in the linkage section.
              The next three instructions increment the value in the
              TALLY variable in the data section. Finally, the routine
              returns the incremented value to its caller in R0.

              LINKAGE_SECTION
              The psect name and attributes of the linkage section.
              This argument is optional for all procedure kinds. If
              omitted, the default is the name and attributes defined
              by the $LINK$ lexical string symbol. If you specify a name
              and attributes for the LINKAGE_SECTION argument, $ROUTINE
              redefines the $LINK$ lexical string symbol such that the

                                                                     6-45

 



        MACRO-64 Macros
        $ROUTINE


              specified values become the new default. Initially, $LINK$
              is defined as follows:

              $LINK$ = "$LINK$,OCTA,NOPIC,CON,REL,LCL,NOSHR,NOEXE,RD,NOWRT"

              Since you must delimit the psect name and attributes using
              commas, be sure to enclose this argument within angle
              brackets to avoid having the assembler interpret the name
              and attributes as different arguments to $ROUTINE. For
              example:

              LINKAGE_SECTION=<MY_LINK,NOEXE,QUAD,RD,NOWRT>

              KIND
              Specifies the kind of routine being defined. This must be
              one of the following: STACK, REGISTER, NULL, or BOUND. This
              is an optional argument. The default is NULL. For example:

              KIND=STACK

              HANDLER_REINVOKABLE
              Specifies a boolean value to indicate whether the condition
              handler can be re-invoked. This argument is optional and
              valid only with STACK and REGISTER procedures. It defaults
              to FALSE if no value is specified and the procedure kind
              is STACK or REGISTER. Note that this argument is only valid
              if a value is also specified for the HANDLER argument. For
              example:

              HANDLER_REINVOKABLE=TRUE

              BASE_REG_IS_FP
              Specifies a boolean value to indicate whether register
              R29 (FP) is used as the frame-pointer base register (TRUE)
              or not (FALSE). If specified as FALSE, R29 must be used
              to hold the address of the procedure descriptor (or the
              address of the address of the procedure descriptor-refer to
              the OpenVMS Calling Standard. Thus you may use R29 to hold
              a working copy of the linkage-section address passed in
              R27. In addition, your prologue and epilogue instruction
              sequences can be shorter and more efficient. However,
              you cannot not make standard calls to other routines if
              BASE_REG_IS_FP is specified as FALSE. This argument is
              optional and valid only with stack and register procedure
              kinds. It defaults to TRUE if the procedure type is stack
              or register. For example:

        6-46

 



                                                          MACRO-64 Macros
                                                                 $ROUTINE


              BASE_REG_IS_FP=FALSE

              REI_RETURN
              Specifies a boolean value to indicate whether this routine
              returns using an REI instruction. This argument is optional
              and valid only with STACK, REGISTER, and NULL procedure
              kinds. It defaults to FALSE if the procedure kind is STACK,
              REGISTER, or NULL. For example:

              REI_RETURN=TRUE

              STACK_RETURN_VALUE
              Specifies a boolean value indicating whether this routine
              has a stack return value. This argument is optional and
              valid only with STACK, REGISTER, and NULL procedure kinds.
              It defaults to FALSE if the procedure kind is STACK,
              REGISTER or NULL. For example:

              STACK_RETURN_VALUE=TRUE

              RSA_OFFSET
              An integer value specifying the stack offset (in bytes)
              of the register save area. This argument is optional and
              valid only for STACK procedures. If you specify BASE_REG_
              IS_FP as TRUE, the value you specify with RSA_OFFSET must
              be at least 8. RSA_OFFSET defaults to 8 if BASE_REG_IS_FP
              is specified as TRUE, 0 otherwise. For example:

              RSA_OFFSET=32

              SAVE_FP
              The register that contains a copy of the value of FP (R29)
              upon entry to this routine. The prologue instruction
              sequence must copy FP to the register specified by SAVE_
              FP and the epilogue instruction sequence(s) must restore
              FP from the register specified by SAVE_FP. This argument is
              required and only valid for REGISTER procedures. There is
              no default. For example:

              SAVE_FP=R1

              SAVE_RA
              The register that contains the return address. This
              argument is optional and only valid for REGISTER
              procedures. If SAVE_RA is not R26, the prologue instruction
              sequence must copy R26 to the register specified by SAVE_
              RA and the epilogue instruction sequence(s) must use the

                                                                     6-47

 



        MACRO-64 Macros
        $ROUTINE


              return address stored in the register specified by SAVE_FP
              to affect its return to caller. SAVE_RA defaults to R26 if
              the procedure kind is REGISTER. For example:

              SAVE_RA=R22

              SIZE
              A numeric value that must be a multiple of 16 specifying
              the size of the fixed stack area in bytes. This parameter
              is valid only for REGISTER and STACK procedure kinds. It
              defaults to the minimum value possible given the other
              arguments you specify or default. $ROUTINE computes the
              amount of stack storage needed for the register save area
              (if any) and defines the $RSA_END symbol to be the offset
              of the first byte beyond the register save area. If you
              wish to allocate a fixed area of stack beyond the register
              save area, you can specify an expression with the SAZE
              argument that includes the term $RSA_END plus the amount
              of fixed stack storage you need for your application. For
              example:

              SIZE=$RSA_END+32

              SAVED_REGS
              A list of registers saved on the stack by the prologue code
              of this routine. It is valid only for STACK procedures and
              you must specify at least FP (R29) with this argument. It
              defaults to FP (R29) for STACK procedures. For example:

              SAVED_REGS=<R5,FP,F2,F3,F4>

              HANDLER
              The address of an exception handler. It is optional and
              valid only for STACK and REGISTER procedure kinds. By
              default, the procedure is defined not to have an exception
              handler. For example:

              HANDLER=MY_HANDLER

              HANDLER_DATA
              The address of data for the specified handler, if any. This
              argument is optional and valid only for stack and register
              procedure kinds and has no default value. You cannot
              specify a HANDLER_DATA argument if you do not specify the
              HANDLER argument. For example:

              HANDLER_DATA=MY_HANDLER_DATA

        6-48

 



                                                          MACRO-64 Macros
                                                                 $ROUTINE


              SYNCH_EXCEPTIONS
              An argument to indicate whether exceptions must be
              syncronized or not. This argument is optional with STACK
              and REGISTER routines and is not allowed with other kinds
              of routines. This argument defaults to TRUE if you specify
              an exception handler with the HANDLER argument. Otherwise,
              it defaults to FALSE. When this argument is TRUE and
              you specify or default STANDARD_PROLOGUE=TRUE, $ROUTINE
              generates a TRAPB instruction as part of the standard
              prologue sequence. In addition, when this argument is
              true, the $RETURN macro generates a TRAPB instruction as
              part of the standard epilogue sequence. When this argument
              is FALSE, neither $ROUTINE nor $RETURN generate TRAPB
              instructions.

              PROC_VALUE
              The procedure value of a bound procedure's parent. This
              argument is required for BOUND procedures and is invalid
              for all other procedure kinds. For example:

              PROC_VALUE=PARENT_PROC

              ENVIRONMENT
              Specifies an environment value. This parameter is optional
              and valid only for BOUND procedures. It has no default
              value. For example:

              ENVIRONMENT=0

              FUNC_RETURN
              Specifies the function return type. This argument is
              optional and valid for all procedure kinds. If specified,
              it must be one of the following: I64, D64, I32, U32, FF,
              FD, FG, FS, FT, FFC, FDC, FGC, FSC, or FTC. These values
              correspond to those listed in Table 3-7 of the OpenVMS
              Calling Standard that have an additional "RASE$K_FR_"
              prefix. There is no default. For example:

              FUNC_RETURN=U32

              ARGLIST
              Argument type list. This argument is optional and valid for
              all procedure kinds. If the argument list contains one or
              more elements, each of the first six elements must be one
              of the following: I64, I32, U32, FF, FD, FG, FS, or FT. The

                                                                     6-49

 



        MACRO-64 Macros
        $ROUTINE


              seventh and subsequent arguments (if any) must be either
              I32 or I64.

              These values correspond to the PSIG$K_RA_* and MASE$K_
              MA_* signature encodings in Table 3-6 of the OpenVMS
              Calling Standard. There is no default. If you specify this
              argument, $ROUTINE generates a procedure signature block.
              For example:

              ARGLIST=<I64,I32,FF,FF,U32>.

              USES_VAX_ARGLIST
              Specifies a boolean value indicating whether the routine
              uses a VAX argument list. This argument is optional for all
              procedure kinds and defaults to FALSE. If you specify this
              argument, $ROUTINE generates a procedure signature block.
              For example:

              USES_VAX_ARGLIST=TRUE

              OVERRIDE_FLAGS
              Specifies overriding flags for the PDSC$W_FLAGS field in
              the procedure descriptor. This argument is optional and
              valid for all procedure kinds. However, it is required
              for BOUND procedures when the parameter specified with the
              PROC_VALUE argument is an external or forward reference.
              There is no default. For example:

              OVERRIDE_FLAGS=PARENT_FLAGS

              DEFAULT_SIGNATURE
              Specifies a boolean value to indicate whether the standard
              procedure signature is used. TRUE means to use the standard
              signature. It is optional and valid for all procedure
              kinds. The default is FALSE if you specify either the
              ARGLIST or USES_VAX_ARGLIST arguments. Otherwise, the
              default is TRUE. Note that this argument must be FALSE
              or blank if you specify either the ARGLIST or USES_VAX_
              ARGLIST arguments.

              DEFAULT_SIGNATURE=TRUE

              COMMON_BASE
              An argument to specify one or more base registers that
              are used in common with other routines. This argument
              is optional for all routine kinds. By default, $ROUTINE
              invalidates any previous .BASE directives that may be

        6-50

 



                                                          MACRO-64 Macros
                                                                 $ROUTINE


              in effect when you invoke $ROUTINE. In this way, you are
              prevented from inadvertently processing the second or
              subsequent routines in a module with .BASE directives in
              effect that apply only to a previous routine. However,
              you may wish to share a common base register assignment
              between a number of routines. To do so, you could re-issue
              the appropriate .BASE directive or directives after each
              invocation of $ROUTINE. Alternatively, you can specify
              one or more common base registers with the COMMON_BASE
              argument, and issue the appropriate .BASE directive or
              directives only once at the beginning of the module.
              Specify the value for the COMMON_BASE argument as a list
              of integer registers. For example:

              COMMON_BASE=<R5,R13>

              In this example, $ROUTINE invalidates any previous .BASE
              directives except those for registers R5 and R13. Previous
              .BASE directives for registers R5 and R13 are unaffected.

        Description

              $ROUTINE defines a routine, makes it the current routine,
              and performs the following actions:

              o  Creates and associates a linkage section, code section,
                 and data section with the routine.

              o  Defines a procedure descriptor and optional signature
                 block in accordance with the values of macro arguments.

              o  Optionally stores a pointer to the data section within
                 the linkage section.

              o  Creates the following numeric and lexical symbols:










                                                                     6-51

 



        MACRO-64 Macros
        $ROUTINE

                 ________________________________________________________
                 Symbol________Description_______________________________

                 $CS           Address of start of the current routine's
                               code section.

                 $DS           Address of start of the current routine's
                               data section.

                 $DP           Optional address of a pointer to the
                               current routine's data section. This
                               symbol has a value that is an address
                               in the current routine's linkage section
                               at which the $ROUTINE macro has placed
                               the address of the data section ($DS) as
                               follows:

                               $DP = .
                               .ADDRESS $DS

                                  $DP enables a programmer to access the
                                  data area of the current routine from
                                  its linkage section.

                 $LS           Address of the current routine's linkage
                               section.

                 $SIZE         Size of fixed area of stack frame of the
                               current routine. This symbol is valid only
                               with STACK and REGISTER routines.

                 $RSA_OFFSET   The offset within the fixed stack area
                               to the register save area. This symbol is
                               valid only with STACK routines.

                 $RSA_END      The offset within the fixed stack area to
                               the the first byte beyond the end of the
                               register save area (if any).

                 $CODE$        A lexical string symbol that defines the
                               routine's code psect name and attributes.

                 $DATA$        A lexical symbol that defines the
                               routine's data psect name and attributes.

                 $LINK$        A lexical string symbol that defines
                               the routine's linkage psect name and
                 ______________attributes._______________________________

              o  Optionally generates a standard, instruction prologue
                 sequence at the beginning of the code section.

        6-52

 



                                                          MACRO-64 Macros
                                                                 $ROUTINE


                 If you specify /NAMES=AS_IS on the command line, all
                 but the last three of these symbols are defined in
                 both complete uppercase and complete lowercase. These
                 symbols are intended for your use outside of the macros
                 themselves. For example, the values of these numeric
                 symbols may be useful as a mnemonic when coding an
                 instruction with a register as in the following example:

                  lda   SP,-$SIZE(SP)

                 The last three symbols ,$CODE$, $DATA$, and $LINK$ are
                 only defined in uppercase. They are used by the $ROUTINE
                 macro for the default code, data, and linkage section
                 psect names and attributes. You can define these symbols
                 prior to invoking $ROUTINE to alter the default program
                 sections as follows:

                 -  $CODE$ = "MY_CODE,EXE,OCTA,SHR,NORD,NOWRT,GBL"

                 -  $DATA$ = "MY_DATA,NOEXE,OCTA,NOSHR,RD,WRT,GBL"

                 -  $LINK$ = "MY_LINK,NOEXE,OCTA,SHR,RD,NOWRT,GBL"

                 These statements cause $ROUTINE to use the above psect
                 names and attributes by default. If you specify any
                 of the CODE_SECTION, DATA_SECTION, or LINKAGE_SECTION
                 arguments in your invocation of $ROUTINE, $ROUTINE
                 uses the psect name and attributes specified with the
                 argument.

                 In addition, $ROUTINE redefines the corresponding
                 $CODE$, $DATA$, or $LINK$ lexical string symbol to
                 the value you specify when you specify any of the
                 CODE_SECTION, DATA_SECTION, or LINKAGE_SECTION arguments
                 with $ROUTINE.

        Examples

                        $ROUTINE MAIN1, KIND=NULL

                        $ROUTINE MAIN1,         -
                            KIND=STACK,         -
                            SIZE=48,            -
                            SAVED_REGS=<R2,FP,F5>

                                                                     6-53

 










                                                                        A
        _________________________________________________________________

                          MACRO-64 Alpha AXP Architecture Quick Reference


              This appendix provides figures and tables showing the
              data types and addressing capabilities of the Alpha AXP
              architecture. The information is derived from the Alpha AXP
              Achitecture Quick Reference Guide. Minor changes have been
              made to reflect the usage of the Alpha AXP architecture
              that is specific to MACRO-64.

              For more information, see the Alpha Architecture Reference
              Manual and the OpenVMS Calling Standard.

              Figure A-1 shows integer and floating point data
              structures. Figure A-2 shows instruction formats.
























                                                                      A-1

 



        MACRO-64 Alpha AXP Architecture Quick Reference
















































        A-2

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                           A.1 Register Usage Conventions


        A.1 Register Usage Conventions

              Table A-1 lists the register usage conventions for OpenVMS
              AXP. MACRO-64 recognizes FP and SP as register synonyms,
              but does not recognize AI, RA, or PV as register synonyms.

        Table_A-1_Register_Usage_Conventions_for_OpenVMS_AXP_____________

        For OpenVMS:
        R0               Int func ret value
        R1               Scratch
        R2-R15           Saved
        R16-             Argument
        R21
        R22-             Scratch
        R24
        R25      AI      Argument information
        R26      RA      Return address
        R27      PV      Procedure value
        R28              Volatile scratch
        R29      FP      Stack frame base
        R30      SP      Stack pointer
        R31              Zero
        F0               F-P function ret value
        F1               F-P complex func ret value
        F2-F9            Saved
        F10-             Scratch
        F15
        F16-             Argument
        F22
        F23-             Scratch
        F30
        F31______________Zero____________________________________________












                                                                      A-3

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.2 Instruction Operand Notation


        A.2 Instruction Operand Notation

              Table A-2 shows the notation for instruction operands. The
              notation format is as follows:

              <name>.<access type><data type>

        Table_A-2_Instruction_Operand_Notation___________________________

        <name>:
        disp  Displacement field
        fnc   PALcode function field
        Ra    Integer register operand in the Ra field
        Rb    Integer register operand in the Rb field
        #b    Integer literal operand in the Rb field
        Rc    Integer register operand in the Rc field
        Fa    Floating-point register operand in the Ra field
        Fb    Floating-point register operand in the Rb field
        Fc    Floating-point register operand in the Rc field
        <access type>:
        a     The operand is used in an address calculation to form
              an effective address. The data type code that follows
              indicates the units of addressability (or scale factor)
              applied to this operand when the instruction is decoded.
        i     The operand is an immediate literal.
        m     The operand is both read and written.
        r     The operand is read only.
        w     The operand is write only.
        <data type>:
        b     Byte
        f     F_floating
        g     G_floating
        l     Longword
        q     Quadword
        s     IEEE single floating (S_floating)
        t     IEEE double floating (T_floating)
        w     Word
        x_____The_data_type_is_specified_by_the_instruction______________







        A-4

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                       A.3 Instruction Qualifier Notation


        A.3 Instruction Qualifier Notation

              Table A-3 shows the notation for instruction qualifiers.

        Table_A-3_Instruction_Qualifier_Notation_________________________

        /Qualifier_Meaning_______________________________________________

        C          Chopped rounding
        D          Dynamic rounding
                   (mode determined by FPCR<DYN>)
        I          Inexact result enable
        M          Minus infinity rounding
        S          Software completion enable
        U          Floating underflow enable
        V__________Integer_overflow_enable_______________________________


        A.4 F-P Control Register (FPCR) Format

              Table A-4 shows the format for the F-P Control Register.

        Table_A-4_F-P_Control_Register_(FPCR)_Format_____________________

        Bits____Symbol___Meaning_________________________________________

        63      SUM      Bitwise OR of <57:52>
        62:60   RAZ      Read as zero; ignored when written
                /IGN
        59:58   DYN      IEEE rounding mode selected:

                         00   Chopped
                         01   Minus infinity
                         10   Normal rounding
                         11   Plus infinity
        57      IOV      Integer overflow of destination precision
        56      INE      Floating mathematically inexact result
        55      UNF      Floating underflow of destination exponent
        54      OVF      Floating overflow of destination exponent
        53      DZE      Floating divide with divisor of zero
        52      INV      Floating invalid operand value

                                                 (continued on next page)


                                                                      A-5

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.4 F-P Control Register (FPCR) Format


        Table_A-4_(Cont.)_F-P_Control_Register_(FPCR)_Format_____________

        Bits____Symbol___Meaning_________________________________________

        51:0    RAZ      Read as zero; ignored when written
        ________/IGN_____________________________________________________







































        A-6

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                          A.5 Decodable Pseudo-Operations


        A.5 Decodable Pseudo-Operations

              Table A-5 lists decodable pseudo-operations and their
              associated actual instructions.

        Table_A-5_Decodable_Pseudo-Operations____________________________

        Pseudo-                 Actual
        Operation_______________Instruction______________________________

        BR        target        BR          R31,target
        CLR       Rx            BIS         R31,R31,Rx
        FABS      Fx,Fy         CPYS        F31,Fx,Fy
        FCLR      Fx            CPYS        F31,F31,Fx
        FMOV      Fx,Fy         CPYS        Fx,Fx,Fy
        FNEG      Fx,Fy         CPYSN       Fx,Fx,Fy
        FNOP                    CPYS        F31,F31,F31
        MOV       Lit,Rx        LDA         Rx,lit(R31)
        MOV       {Rx           BIS         R31,{Rx/Lit8},Ry
                  /Lit8},Ry
        MF_FPCR   Fx            MF_FPCR     Fx,Fx,Fx
        MT_FPCR   Fx            MT_FPCR     Fx,Fx,Fx
        NEGF      Fx,Fy         SUBF        F31,Fx,Fy
        NEGF/S    Fx,Fy         SUBF/S      F31,Fx,Fy
        NEGG      Fx,Fy         SUBG        F31,Fx,Fy
        NEGG/S    Fx,Fy         SUBG/S      F31,Fx,Fy
        NEGL      {Rx           SUBL        R31,{Rx/Lit},Ry
                  /Lit8},Ry
        NEGL/V    {Rx           SUBL/V      R31,{Rx/Lit},Ry
                  /Lit8},Ry
        NEGQ      {Rx           SUBQ        R31,{Rx/Lit},Ry
                  /Lit8},Ry
        NEGQ/V    {Rx           SUBQ/V      R31,{Rx/Lit},Ry
                  /Lit8},Ry
        NEGS      Fx,Fy         SUBS        F31,Fx,Fy
        NEGS/SU   Fx,Fy         SUBS/SU     F31,Fx,Fy
        NEGS      Fx,FY         SUBS/SUI    F31,Fx,Fy
        /SUI
        NEGT      Fx,Fy         SUBT        F31,Fx,Fy

                                                 (continued on next page)




                                                                      A-7

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.5 Decodable Pseudo-Operations


        Table_A-5_(Cont.)_Decodable_Pseudo-Operations____________________

        Pseudo-                 Actual
        Operation_______________Instruction______________________________

        NEGT/SU   Fx,Fy         SUBT/SU     F31,Fx,Fy
        NEGT      Fx,FY         SUBT/SUI    F31,Fx,Fy
        /SUI
        NOP                     BIS         R31,R31,R31
        NOT       {Rx           ORNOT       R31,{Rx/Lit},Ry
                  /Lit8},Ry
        SEXTL     {Rx/Lit},Ry   ADDL        R31,{Rx/Lit},Ry
        UNOP____________________LDQ_U_______R31,0(Rx)____________________
































        A-8

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                       A.6 Common Architecture Opcodes in Numerical Order


        A.6 Common Architecture Opcodes in Numerical Order

              Table A-6 lists the common architecture opcodes in
              numerical order

        Table_A-6_Common_Architecture_Opcodes_in_Numerical_Order_________

        Opcode________________Opcode________________Opcode_______________

        00      CALL_PAL      11.26   CMOVNE        15.01E    CVTDG
                                                              /C
        01      OPC01         11.28   ORNOT         15.020    ADDG
                                                              /C
        02      OPC02         11.40   XOR           15.021    SUBG
                                                              /C
        03      OPC03         11.44   CMOVLT        15.022    MULG
                                                              /C
        04      OPC04         11.46   CMOVGE        15.023    DIVG
                                                              /C
        05      OPC05         11.48   EQV           15.02C    CVTGF
                                                              /C
        06      OPC06         11.64   CMOVLE        15.02D    CVTGD
                                                              /C
        07      OPC07         11.66   CMOVGT        15.02F    CVTGQ
                                                              /C
        08      LDA           12.02   MSKBL         15.03C    CVTQF
                                                              /C
        09      LDAH          12.06   EXTBL         15.03E    CVTQG
                                                              /C
        0A      OPC0A         12.0B   INSBL         15.080    ADDF
        0B      LDQ_U         12.12   MSKWL         15.081    SUBF
        0C      OPC0C         12.16   EXTWL         15.082    MULF
        0D      OPC0D         12.1B   INSWL         15.083    DIVF
        0E      OPC0E         12.22   MSKLL         15.09E    CVTDG
        0F      STQ_U         12.26   EXTLL         15.0A0    ADDG
        10.00   ADDL          12.2B   INSLL         15.0A1    SUBG
        10.02   S4ADDL        12.30   ZAP           15.0A2    MULG
        10.09   SUBL          12.31   ZAPNOT        15.0A3    DIVG
        10.0B   S4SUBL        12.32   MSKQL         15.0A5    CMPGEQ
        10.0F   CMPBGE        12.34   SRL           15.0A6    CMPGLT
        10.12   S8ADDL        12.36   EXTQL         15.0A7    CMPGLE

                                                 (continued on next page)


                                                                      A-9

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.6 Common Architecture Opcodes in Numerical Order


        Table_A-6_(Cont.)_Common_Architecture_Opcodes_in_Numerical_Order_

        Opcode________________Opcode________________Opcode_______________

        10.1B   S8SUBL        12.39   SLL           15.0AC    CVTGF
        10.1D   CMPULT        12.3B   INSQL         15.0AD    CVTGD
        10.20   ADDQ          12.3C   SRA           15.0AF    CVTGQ
        10.22   S4ADDQ        12.52   MSKWH         15.0BC    CVTQF
        10.29   SUBQ          12.57   INSWH         15.0BE    CVTQG
        10.2B   S4SUBQ        12.5A   EXTWH         15.100    ADDF
                                                              /UC
        10.2D   CMPEQ         12.62   MSKLH         15.101    SUBF
                                                              /UC
        10.32   S8ADDQ        12.67   INSLH         15.102    MULF
                                                              /UC
        10.3B   S8SUBQ        12.6A   EXTLH         15.103    DIVF
                                                              /UC
        10.3D   CMPULE        12.72   MSKQH         15.11E    CVTDG
                                                              /UC
        10.40   ADDL/V        12.77   INSQH         15.120    ADDG
                                                              /UC
        10.49   SUBL/V        12.7A   EXTQH         15.121    SUBG
                                                              /UC
        10.4D   CMPLT         13.00   MULL          15.122    MULG
                                                              /UC
        10.60   ADDQ/V        13.20   MULQ          15.123    DIVG
                                                              /UC
        10.69   SUBQ/V        13.30   UMULH         15.12C    CVTGF
                                                              /UC
        10.6D   CMPLE         13.40   MULL/V        15.12D    CVTGD
                                                              /UC
        11.00   AND           13.60   MULQ/V        15.12F    CVTGQ
                                                              /VC
        11.08   BIC           14      OPC14         15.180    ADDF
                                                              /U
        11.14   CMOVLBS       15.000  ADDF/C        15.181    SUBF
                                                              /U
        11.16   CMOVLBC       15.001  SUBF/C        15.182    MULF
                                                              /U
        11.20   BIS           15.002  MULF/C        15.183    DIVF
                                                              /U

                                                 (continued on next page)


        A-10

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                       A.6 Common Architecture Opcodes in Numerical Order


        Table_A-6_(Cont.)_Common_Architecture_Opcodes_in_Numerical_Order_

        Opcode________________Opcode________________Opcode_______________

        11.24   CMOVEQ        15.003  DIVF/C        15.19E    CVTDG
                                                              /U
        15.1A0  ADDG/U        15.580  ADDF/SU       16.0A6    CMPTLT
        15.1A1  SUBG/U        15.581  SUBF/SU       16.0A7    CMPTLE
        15.1A2  MULG/U        15.582  MULF/SU       16.0AC    CVTTS
        15.1A3  DIVG/U        15.583  DIVF/SU       16.0AF    CVTTQ
        15.1AC  CVTGF/U       15.59E  CVTDG/SU      16.0BC    CVTQS
        15.1AD  CVTGD/U       15.5A0  ADDG/SU       16.0BE    CVTQT
        15.1AF  CVTGQ/V       15.5A1  SUBG/SU       16.0C0    ADDS
                                                              /D
        15.400  ADDF/SC       15.5A2  MULG/SU       16.0C1    SUBS
                                                              /D
        15.401  SUBF/SC       15.5A3  DIVG/SU       16.0C2    MULS
                                                              /D
        15.402  MULF/SC       15.5AC  CVTGF/SU      16.0C3    DIVS
                                                              /D
        15.403  DIVF/SC       15.5AD  CVTGD/SU      16.0E0    ADDT
                                                              /D
        15.41E  CVTDG/SC      15.5AF  CVTGQ/SV      16.0E1    SUBT
                                                              /D
        15.420  ADDG/SC       16.000  ADDS/C        16.0E2    MULT
                                                              /D
        15.421  SUBG/SC       16.001  SUBS/C        16.0E3    DIVT
                                                              /D
        15.422  MULG/SC       16.002  MULS/C        16.0EC    CVTTS
                                                              /D
        15.423  DIVG/SC       16.003  DIVS/C        16.0EF    CVTTQ
                                                              /D
        15.42C  CVTGF/SC      16.020  ADDT/C        16.0FC    CVTQS
                                                              /D
        15.42D  CVTGD/SC      16.021  SUBT/C        16.0FE    CVTQT
                                                              /D
        15.42F  CVTGQ/SC      16.022  MULT/C        16.100    ADDS
                                                              /UC
        15.480  ADDF/S        16.023  DIVT/C        16.101    SUBS
                                                              /UC

                                                 (continued on next page)



                                                                     A-11

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.6 Common Architecture Opcodes in Numerical Order


        Table_A-6_(Cont.)_Common_Architecture_Opcodes_in_Numerical_Order_

        Opcode________________Opcode________________Opcode_______________

        15.481  SUBF/S        16.02C  CVTTS/C       16.102    MULS
                                                              /UC
        15.482  MULF/S        16.02F  CVTTQ/C       16.103    DIVS
                                                              /UC
        15.483  DIVF/S        16.03C  CVTQS/C       16.120    ADDT
                                                              /UC
        15.49E  CVTDG/S       16.03E  CVTQT/C       16.121    SUBT
                                                              /UC
        15.4A0  ADDG/S        16.040  ADDS/M        16.122    MULT
                                                              /UC
        15.4A1  SUBG/S        16.041  SUBS/M        16.123    DIVT
                                                              /UC
        15.4A2  MULG/S        16.042  MULS/M        16.12C    CVTTS
                                                              /UC
        15.4A3  DIVG/S        16.043  DIVS/M        16.12F    CVTTQ
                                                              /VC
        15.4A5  CMPGEQ/S      16.060  ADDT/M        16.140    ADDS
                                                              /UM
        15.4A6  CMPGLT/S      16.061  SUBT/M        16.141    SUBS
                                                              /UM
        15.4A7  CMPGLE/S      16.062  MULT/M        16.142    MULS
                                                              /UM
        15.4AC  CVTGF/S       16.063  DIVT/M        16.143    DIVS
                                                              /UM
        15.4AD  CVTGD/S       16.06C  CVTTS/M       16.160    ADDT
                                                              /UM
        15.4AF  CVTGQ/S       16.06F  CVTTQ/M       16.161    SUBT
                                                              /UM
        15.500  ADDF/SUC      16.07C  CVTQS/M       16.162    MULT
                                                              /UM
        15.501  SUBF/SUC      16.07E  CVTQT/M       16.163    DIVT
                                                              /UM
        15.502  MULF/SUC      16.080  ADDS          16.16C    CVTTS
                                                              /UM
        15.503  DIVF/SUC      16.081  SUBS          16.16F    CVTTQ
                                                              /VM

                                                 (continued on next page)



        A-12

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                       A.6 Common Architecture Opcodes in Numerical Order


        Table_A-6_(Cont.)_Common_Architecture_Opcodes_in_Numerical_Order_

        Opcode________________Opcode________________Opcode_______________

        15.51E  CVTDG/SUC     16.082  MULS          16.180    ADDS
                                                              /U
        15.520  ADDG/SUC      16.083  DIVS          16.181    SUBS
                                                              /U
        15.521  SUBG/SUC      16.0A0  ADDT          16.182    MULS
                                                              /U
        15.522  MULG/SUC      16.0A1  SUBT          16.183    DIVS
                                                              /U
        15.523  DIVG/SUC      16.0A2  MULT          16.1A0    ADDT
                                                              /U
        15.52C  CVTGF/SUC     16.0A3  DIVT          16.1A1    SUBT
                                                              /U
        15.52D  CVTGD/SUC     16.0A4  CMPTUN        16.1A2    MULT
                                                              /U
        15.52F  CVTGQ/SVC     16.0A5  CMPTEQ        16.1A3    DIVT
                                                              /U
        16.1AC  CVTTS/U       16.5AF  CVTTQ/SV      16.7BC    CVTQS
                                                              /SUI
        16.1AF  CVTTQ/V       16.5C0  ADDS/SUD      16.7BE    CVTQT
                                                              /SUI
        16.1C0  ADDS/UD       16.5C1  SUBS/SUD      16.7C0    ADDS
                                                              /SUID
        16.1C1  SUBS/UD       16.5C2  MULS/SUD      16.7C1    SUBS
                                                              /SUID
        16.1C2  MULS/UD       16.5C3  DIVS/SUD      16.7C2    MULS
                                                              /SUID
        16.1C3  DIVS/UD       16.5E0  ADDT/SUD      16.7C3    DIVS
                                                              /SUID
        16.1E0  ADDT/UD       16.5E1  SUBT/SUD      16.7E0    ADDT
                                                              /SUID
        16.1E1  SUBT/UD       16.5E2  MULT/SUD      16.7E1    SUBT
                                                              /SUID
        16.1E2  MULT/UD       16.5E3  DIVT/SUD      16.7E2    MULT
                                                              /SUID
        16.1E3  DIVT/UD       16.5EC  CVTTS/SUD     16.7E3    DIVT
                                                              /SUID

                                                 (continued on next page)



                                                                     A-13

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.6 Common Architecture Opcodes in Numerical Order


        Table_A-6_(Cont.)_Common_Architecture_Opcodes_in_Numerical_Order_

        Opcode________________Opcode________________Opcode_______________

        16.1EC  CVTTS/UD      16.5EF  CVTTQ/SVD     16.7EC    CVTTS
                                                              /SUID
        16.1EF  CVTTQ/VD      16.6AC  CVTST/S       16.7EF    CVTTQ
                                                              /SVID
        16.2AC  CVTST         16.700  ADDS/SUIC     16.7FC    CVTQS
                                                              /SUID
        16.500  ADDS/SUC      16.701  SUBS/SUIC     16.7FE    CVTQT
                                                              /SUID
        16.501  SUBS/SUC      16.702  MULS/SUIC     17.010    CVTLQ
        16.502  MULS/SUC      16.703  DIVS/SUIC     17.020    CPYS
        16.503  DIVS/SUC      16.720  ADDT/SUIC     17.021    CPYSN
        16.520  ADDT/SUC      16.721  SUBT/SUIC     17.022    CPYSE
        16.521  SUBT/SUC      16.722  MULT/SUIC     17.024    MT_
                                                              FPCR
        16.522  MULT/SUC      16.723  DIVT/SUIC     17.025    MF_
                                                              FPCR
        16.523  DIVT/SUC      16.72C  CVTTS/SUIC    17.02A    FCMOVEQ
        16.52C  CVTTS/SUC     16.72F  CVTTQ/SVIC    17.02B    FCMOVNE
        16.52F  CVTTQ/SVC     16.73C  CVTQS/SUIC    17.02C    FCMOVLT
        16.540  ADDS/SUM      16.73E  CVTQT/SUIC    17.02D    FCMOVGE
        16.541  SUBS/SUM      16.740  ADDS/SUIM     17.02E    FCMOVLE
        16.542  MULS/SUM      16.741  SUBS/SUIM     17.02F    FCMOVGT
        16.543  DIVS/SUM      16.742  MULS/SUIM     17.030    CVTQL
        16.560  ADDT/SUM      16.743  DIVS/SUIM     17.130    CVTQL
                                                              /V
        16.561  SUBT/SUM      16.760  ADDT/SUIM     17.530    CVTQL
                                                              /SV
        16.562  MULT/SUM      16.761  SUBT/SUIM     18.0000   TRAPB
        16.563  DIVT/SUM      16.762  MULT/SUIM     18.0400   EXCB
        16.56C  CVTTS/SUM     16.763  DIVT/SUIM     18.4000   MB
        16.56F  CVTTQ/SVM     16.76C  CVTTS/SUIM    18.4400   WMB
        16.580  ADDS/SU       16.76F  CVTTQ/SVIM    18.8000   FETCH
        16.581  SUBS/SU       16.77C  CVTQS/SUIM    18.A000   FETCH_
                                                              M
        16.582  MULS/SU       16.77E  CVTQT/SUIM    18.C000   RPCC
        16.583  DIVS/SU       16.780  ADDS/SUI      18.E000   RC
        16.5A0  ADDT/SU       16.781  SUBS/SUI      18.F000   RS

                                                 (continued on next page)


        A-14

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                       A.6 Common Architecture Opcodes in Numerical Order


        Table_A-6_(Cont.)_Common_Architecture_Opcodes_in_Numerical_Order_

        Opcode________________Opcode________________Opcode_______________

        16.5A1  SUBT/SU       16.782  MULS/SUI      19        PAL19
        16.5A2  MULT/SU       16.783  DIVS/SUI      1A.0      JMP
        16.5A3  DIVT/SU       16.7A0  ADDT/SUI      1A.1      JSR
        16.5A4  CMPTUN/SU     16.7A1  SUBT/SUI      1A.2      RET
        16.5A5  CMPTEQ/SU     16.7A2  MULT/SUI      1A.3      JSR_
                                                              COROUTINE
        16.5A6  CMPTLT/SU     16.7A3  DIVT/SUI      1B        PAL1B
        16.5A7  CMPTLE/SU     16.7AC  CVTTS/SUI     1C        OPC1C
        16.5AC  CVTTS/SU      16.7AF  CVTTQ/SVI     1D        PAL1D
        1E      PAL1E         2A      LDL_L         36        FBGE
        1F      PAL1F         2B      LDQ_L         37        FBGT
        20      LDF           2C      STL           38        BLBC
        21      LDG           2D      STQ           39        BEQ
        22      LDS           2E      STL_C         3A        BLT
        23      LDT           2F      STQ_C         3B        BLE
        24      STF           30      BR            3C        BLBS
        25      STG           31      FBEQ          3D        BNE
        26      STS           32      FBLT          3E        BGE
        27      STT           33      FBLE          3F        BGT
        28      LDL           34      BSR
        29______LDQ___________35______FBNE_______________________________




















                                                                     A-15

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.7 OpenVMS PALcode Instruction Summary


        A.7 OpenVMS PALcode Instruction Summary

              Table A-7 lists the OpenVMS unprivileged PALcode
              instructions and Table A-8 lists the OpenVMS privileged
              PALcode instructions.

        Table_A-7_OpenVMS_Unprivileged_PALcode_Instructions______________

        Mnemonic______Opcode____Description______________________________

        AMOVRM        00.00A1   Atomic move from register to memory
        AMOVRR        00.00A0   Atomic move from register to register
        BPT           00.0080   Breakpoint
        BUGCHK        00.0081   Bugcheck
        CHMK          00.0083   Change mode to kernel
        CHME          00.0082   Change mode to executive
        CHMS          00.0084   Change mode to supervisor
        CHMU          00.0085   Change mode to user
        GENTRAP       00.00AA   Generate software trap
        IMB           00.0086   I-stream memory barrier
        INSQHIL       00.0087   Insert into longword queue at head
                                interlocked
        INSQHILR      00.00A2   Insert into longword queue at head
                                interlocked resident
        INSQHIQ       00.0089   Insert into quadword queue at head
                                interlocked
        INSQHIQR      00.00A4   Insert into quadword queue at head
                                interlocked resident
        INSQTIL       00.0088   Insert into longword queue at tail
                                interlocked
        INSQTILR      00.00A3   Insert into longword queue at tail
                                interlocked resident
        INSQTIQ       00.008A   Insert into quadword queue at tail
                                interlocked
        INSQTIQR      00.00A5   Insert into quadword queue at tail
                                interlocked resident
        INSQUEL       00.008B   Insert entry into longword queue
        INSQUEL/D     00.008D   Insert entry into longword queue deferred
        INSQUEQ       00.008C   Insert entry into quadword queue
        INSQUEQ/D     00.008E   Insert entry into quadword queue deferred
        PROBER        00.008F   Probe for read access

                                                 (continued on next page)


        A-16

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                  A.7 OpenVMS PALcode Instruction Summary


        Table_A-7_(Cont.)_OpenVMS_Unprivileged_PALcode_Instructions______

        Mnemonic______Opcode____Description______________________________

        PROBEW        00.0090   Probe for write access
        RD_PS         00.0091   Move processor status
        READ_UNQ      00.009E   Read unique context
        REI           00.0092   Return from exception or interrupt
        REMQHIL       00.0093   Remove from longword queue at head
                                interlocked
        REMQHILR      00.00A6   Remove from longword queue at head
                                interlocked resident
        REMQHIQ       00.0095   Remove from quadword queue at head
                                interlocked
        REMQHIQR      00.00A8   Remove from quadword queue at head
                                interlocked resident
        REMQTIL       00.0094   Remove from longword queue at tail
                                interlocked
        REMQTILR      00.00A7   Remove from longword queue at tail
                                interlocked resident
        REMQTIQ       00.0096   Remove from quadword queue at tail
                                interlocked
        REMQTIQR      00.00A9   Remove from quadword queue at tail
                                interlocked resident
        REMQUEL       00.0097   Remove entry from longword queue
        REMQUEL/D     00.0099   Remove entry from longword queue deferred
        REMQUEQ       00.0098   Remove entry from quadword queue
        REMQUEQ/D     00.009A   Remove entry from quadword queue deferred
        RSCC          00.009D   Read system cycle counter
        SWASTEN       00.009B   Swap AST enable for current mode
        WRITE_UNQ     00.009F   Write unique context
        WR_PS_SW______00.009C___Write_processor_status_software_field____

        Table_A-8_OpenVMS_Privileged_PALcode_Instructions________________

        Mnemonic_________Opcode____Description___________________________

        CFLUSH           00.0001   Cache flush
        CSERVE           00.0009   Console service
        DRAINA           00.0002   Drain aborts
        HALT             00.0000   Halt processor

                                                 (continued on next page)


                                                                     A-17

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.7 OpenVMS PALcode Instruction Summary


        Table_A-8_(Cont.)_OpenVMS_Privileged_PALcode_Instructions________

        Mnemonic_________Opcode____Description___________________________

        LDQP             00.0003   Load quadword physical
        MFPR_ASN         00.0006   Move from processor register ASN
        MFPR_ESP         00.001E   Move from processor register ESP
        MFPR_FEN         00.000B   Move from processor register FEN
        MFPR_IPL         00.000E   Move from processor register IPL
        MFPR_MCES        00.0010   Move from processor register MCES
        MFPR_PCBB        00.0012   Move from processor register PCBB
        MFPR_PRBR        00.0013   Move from processor register PRBR
        MFPR_PTBR        00.0015   Move from processor register PTBR
        MFPR_SCBB        00.0016   Move from processor register SCBB
        MFPR_SISR        00.0019   Move from processor register SISR
        MFPR_SSP         00.0020   Move from processor register SSP
        MFPR_TBCHK       00.001A   Move from processor register TBCHK
        MFPR_USP         00.0022   Move from processor register USP
        MFPR_VPTB        00.0029   Move from processor register VPTB
        MFPR_WHAMI       00.003F   Move from processor register WHAMI
        MTPR_ASTEN       00.0026   Move to processor register ASTEN
        MTPR_ASTSR       00.0027   Move to processor register ASTSR
        MTPR_DATFX       00.002E   Move to processor register DATFX
        MTPR_ESP         00.001F   Move to processor register ESP
        MTPR_FEN         00.000B   Move to processor register FEN
        MTPR_IPIR        00.000D   Move to processor register IPRI
        MTPR_IPL         00.000E   Move to processor register IPL
        MTPR_MCES        00.0011   Move to processor register MCES
        MTPR_PERFMON     00.002B   Move to processor register PERFMON
        MTPR_PRBR        00.0014   Move to processor register PRBR
        MTPR_SCBB        00.0017   Move to processor register SCBB
        MTPR_SIRR        00.0018   Move to processor register SIRR
        MTPR_SSP         00.0021   Move to processor register SSP
        MTPR_TBIA        00.001B   Move to processor register TBIA
        MTPR_TBIAP       00.001C   Move to processor register TBIAP
        MTPR_TBIS        00.001D   Move to processor register TBIS
        MTPR_TBISD       00.0024   Move to processor register TBISD
        MTPR_TBISI       00.0025   Move to processor register TBISI

                                                 (continued on next page)





        A-18

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                  A.7 OpenVMS PALcode Instruction Summary


        Table_A-8_(Cont.)_OpenVMS_Privileged_PALcode_Instructions________

        Mnemonic_________Opcode____Description___________________________

        MTPR_USP         00.0023   Move to processor register USP
        MTPR_VPTB        00.002A   Move to processor register VPTB
        STQP             00.0004   Store quadword physical
        SWPCTX           00.0005   Swap privileged context
        SWPPAL___________00.000A___Swap_PALcode_image____________________




































                                                                     A-19

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.8 PALcode Opcodes in Numerical Order


        A.8 PALcode Opcodes in Numerical Order

              Table A-9 lists the PALcode opcodes in numerical order.

        Table_A-9_PALcode_Opcodes_in_Numerical_Order_____________________

        Opcode(16)Opcode(10)OpenVMS______________________________________

        00.0000   00.0000   HALT
        00.0001   00.0001   CFLUSH
        00.0002   00.0002   DRAINA
        00.0003   00.0003   LDQP
        00.0004   00.0004   STQP
        00.0005   00.0005   SWPCTX
        00.0006   00.0006   MFPR_ASN
        00.0007   00.0007   MTPR_ASTEN
        00.0008   00.0008   MTPR_ASTSR
        00.0009   00.0009   CSERVE
        00.000A   00.0010   SWPPAL
        00.000B   00.0011   MFPR_FEN
        00.000C   00.0012   MTPR_FEN
        00.000D   00.0013   MTPR_IPIR
        00.000E   00.0014   MFPR_IPL
        00.000F   00.0015   MTPR_IPL
        00.0010   00.0016   MFPR_MCES
        00.0011   00.0017   MTPR_MCES
        00.0012   00.0018   MFPR_PCBB
        00.0013   00.0019   MFPR_PRBR
        00.0014   00.0020   MTPR_PRBR
        00.0015   00.0021   MFPR_PTBR
        00.0016   00.0022   MFPR_SCBB
        00.0017   00.0023   MTPR_SCBB
        00.0018   00.0024   MTPR_SIRR
        00.0019   00.0025   MFPR_SISR
        00.001A   00.0026   MFPR_TBCHK
        00.001B   00.0027   MTPR_TBIA
        00.001C   00.0028   MTPR_TBIAP
        00.001D   00.0029   MTPR_TBIS
        00.001E   00.0030   MFPR_ESP
        00.001F   00.0031   MTPR_ESP
        00.0020   00.0032   MFPR_SSP

                                                 (continued on next page)


        A-20

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                   A.8 PALcode Opcodes in Numerical Order


        Table_A-9_(Cont.)_PALcode_Opcodes_in_Numerical_Order_____________

        Opcode(16)Opcode(10)OpenVMS______________________________________

        00.0021   00.0033   MTPR_SSP
        00.0022   00.0034   MFPR_USP
        00.0023   00.0035   MTPR_USP
        00.0024   00.0036   MTPR_TBISD
        00.0025   00.0037   MTPR_TBISI
        00.0026   00.0038   MFPR_ASTEN
        00.0027   00.0039   MFPR_ASTSR
        00.0029   00.0040   MFPR_VPTB
        00.002A   00.0041   MTPR_VPTB
        00.002B   00.0042   MTPR_PERFMON
        00.002E   00.0043   MTPR_DATFX
        00.003F   00.0063   MFPR_WHAMI
        00.0080   00.0128   BPT
        00.0081   00.0129   BUGCHK
        00.0082   00.0130   CHME
        00.0083   00.0131   CHMK
        00.0084   00.0132   CHMS
        00.0085   00.0133   CHMU
        00.0086   00.0134   IMB
        00.0087   00.0135   INSQHIL
        00.0088   00.0136   INSQTIL
        00.0089   00.0137   INSQHIQ
        00.008A   00.0138   INSQTIQ
        00.008B   00.0139   INSQUEL
        00.008C   00.0140   INSQUEQ
        00.008D   00.0141   INSQUEL/D
        00.008E   00.0142   INSQUEQ/D
        00.008F   00.0143   PROBER
        00.0090   00.0144   PROBEW
        00.0091   00.0145   RD_PS
        00.0092   00.0146   REI
        00.0093   00.0147   REMQHIL
        00.0094   00.0148   REMQTIL
        00.0095   00.0149   REMQHIQ
        00.0096   00.0150   REMQTIQ
        00.0097   00.0151   REMQUEL
        00.0098   00.0152   REMQUEQ

                                                 (continued on next page)


                                                                     A-21

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.8 PALcode Opcodes in Numerical Order


        Table_A-9_(Cont.)_PALcode_Opcodes_in_Numerical_Order_____________

        Opcode(16)Opcode(10)OpenVMS______________________________________

        00.0099   00.0153   REMQUEL/D
        00.009A   00.0154   REMQUEQ/D
        00.009B   00.0155   SWASTEN
        00.009C   00.0156   WR_PS_SW
        00.009D   00.0157   RSCC
        00.009E   00.0158   READ_UNQ
        00.009F   00.0159   WRITE_UNQ
        00.00A0   00.0160   AMOVRR
        00.00A1   00.0161   AMOVRM
        00.00A2   00.0162   INSQHILR
        00.00A3   00.0163   INSQTILR
        00.00A4   00.0164   INSQHIQR
        00.00A5   00.0165   INSQTIQR
        00.00A6   00.0166   REMQHILR
        00.00A7   00.0167   REMQTILR
        00.00A8   00.0168   REMQHIQR
        00.00A9   00.0169   REMQTIQR
        00.00AA___00.0170___GENTRAP______________________________________























        A-22

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        A.9 Common Architecture Instructions

              Table A-10 lists common architecture instructions. Where
              enclosed in square brackets, Ra.wq defaults to R31. This
              occurs for instructions BR, JMP, and RET.

        Table_A-10_Common_Architecture_Instructions______________________

        Mnemonic________Code____Operands______________Operation__________

        ADDF            15.080  Fa.rf,Fb.rf,Fc.wf     Fc< - Fav + Fbv
        ADDF/C          15.000
        ADDF/S          15.480
        ADDF/SC         15.400
        ADDF/SUC        15.500
        ADDF/SU         15.580
        ADDF/U          15.180
        ADDF/UC         15.100
        ADDG            15.0A0  Fa.rg,Fb.rg,Fc.wg     Fc< - Fav + Fbv
        ADDG/C          15.020
        ADDG/S          15.4A0
        ADDG/SC         15.420
        ADDG/SU         15.5A0
        ADDG/SUC        15.520
        ADDG/U          15.1A0
        ADDG/UC         15.120
        ADDL            10.00   Ra.rl,{Rb.rl          Rc< - SEXT((Rav +
                                /#b.ib},Rc.wq         Rbv)<31:0>)
        ADDL/V          10.40
        ADDQ            10.20   Ra.rq,{Rb.rq          Rc< - Rav + Rbv
                                /#b.ib},Rc.wq
        ADDQ/V          10.60
        ADDS            16.080  Fa.rs,Fb.rs,Fc.ws     Fc< - Fav + Fbv
        ADDS/C          16.000
        ADDS/D          16.0C0
        ADDS/M          16.040
        ADDS/SU         16.580
        ADDS/SUC        16.500
        ADDS/SUD        16.5C0
        ADDS/SUI        16.780
        ADDS/SUIC       16.700

                                                 (continued on next page)


                                                                     A-23

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        ADDS/SUID       16.7C0
        ADDS/SUIM       16.740
        ADDS/SUM        16.540
        ADDS/U          16.180
        ADDS/UC         16.100
        ADDS/UD         16.1C0
        ADDS/UM         16.140
        ADDT            16.0A0  Fa.rt,Fb.rt,Fc.wt     Fc< - Fav + Fbv
        ADDT/C          16.020
        ADDT/D          16.0E0
        ADDT/M          16.060
        ADDT/SU         16.5A0
        ADDT/SUC        16.520
        ADDT/SUD        16.5E0
        ADDT/SUI        16.7A0
        ADDT/SUIC       16.720
        ADDT/SUID       16.7E0
        ADDT/SUIM       16.760
        ADDT/SUM        16.560
        ADDT/U          16.1A0
        ADDT/UC         16.120
        ADDT/UD         16.1E0
        ADDT/UM         16.160
        AND             11.00   Ra.rq,{Rb.rq          Rc< - Rav AND Rbv
                                /#b.ib},Rc.wq
        BEQ             39      Ra.rq,disp.al         If Rav = 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BGE             3E      Ra.rq,disp.al         If Rav   0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BGT             3F      Ra.rq,disp.al         If Rav > 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BIC             11.08   Ra.rq,{Rb.rq          Rc< - Rav AND {NOT
                                /#b.ib},Rc.wq         Rbv}

                                                 (continued on next page)



        A-24

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        BIS             11.20   Ra.rq,{Rb.rq          Rc< - Rav OR Rbv
                                /#b.ib},Rc.wq
        BLBC            38      Ra.rq,disp.al         If Rav<0> = 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BLBS            3C      Ra.rq,disp.al         If Rav<0> = 1
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BLE             3B      Ra.rq,disp.al         If Rav   0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BLT             3A      Ra.rq,disp.al         If Rav < 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BNE             3D      Ra.rq,disp.al         If Rav /= 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        BR              30      [Ra.wq],disp.al       Ra< - PC; PC< - PC +
                                                      {4*SEXT(disp)}
        BSR             34      Ra.wq,disp.al         Ra< - PC; PC< - PC +
                                                      {4*SEXT(disp)}
        CALL_PAL        00      fnc.ir                Trap to PALcode
        CMOVEQ          11.24   Ra.rq,{Rb.rq          If Rav = 0 Then
                                /#b.ib},Rc.wq         Rc< - Rbv
        CMOVGE          11.46   Ra.rq,{Rb.rq          If Rav   0 Then
                                /#b.ib},Rc.wq         Rc< - Rbv
        CMOVGT          11.66   Ra.rq,{Rb.rq          If Rav > 0 Then
                                /#b.ib},Rc.wq         Rc< - Rbv
        CMOVLBC         11.16   Ra.rq,{Rb.rq          If Rav<0> = 0 Then
                                /#b.ib},Rc.wq         Rc< - Rbv
        CMOVLBS         11.14   Ra.rq,{Rb.rq          If Rav<0> = 1 Then
                                /#b.ib},Rc.wq         Rc< - Rbv
        CMOVLE          11.64   Ra.rq,{Rb.rq          If Rav   0 Then
                                /#b.ib},Rc.wq         Rc< - Rbv
        CMOVLT          11.44   Ra.rq,{Rb.rq          If Rav < 0 Then
                                /#b.ib},Rc.wq         Rc< - Rbv

                                                 (continued on next page)



                                                                     A-25

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        CMOVNE          11.26   Ra.rq,{Rb.rq          If Rav /= 0 Then
                                /#b.ib},Rc.wq         Rc< - Rbv
        CMPBGE          10.0F   Ra.rq,{Rb.rq          Rc< - Bytewise
                                /#b.ib},Rc.wq         compare mask of
                                                      {Rav   Rbv}
        CMPEQ           10.2D   Ra.rq,{Rb.rq          If Rav = Rbv Then
                                /#b.ib},Rc.wq         Rc< - 1 Else Rc< - 0
        CMPGEQ          15.0A5  Fa.rg,Fb.rg,Fc.wq     If Fav = Fbv Then
                                                      Fc< - 0.5 Else
                                                      Fc< - 0.0
        CMPGEQ/S        15.4A5
        CMPGLE          15.0A7  Fa.rg,Fb.rg,Fc.wq     If Fav   Fbv Then
                                                      Fc< - 0.5 Else
                                                      Fc< - 0.0
        CMPGLE/S        15.4A7
        CMPGLT          15.0A6  Fa.rg,Fb.rg,Fc.wq     If Fav < Fbv Then
                                                      Fc< - 0.5 Else
                                                      Fc< - 0.0
        CMPGLT/S        15.4A6
        CMPLE           10.6D   Ra.rq,{Rb.rq          If Rav   Rbv Then
                                /#b.ib},Rc.wq         Rc< - 1 Else Rc< - 0
        CMPLT           10.4D   Ra.rq,{Rb.rq          If Rav < Rbv Then
                                /#b.ib},Rc.wq         Rc< - 1 Else Rc< - 0
        CMPTEQ          16.0A5  Fa.rt,Fb.rt,Fc.wq     If Fav = Fbv Then
                                                      Fc< - 2.0 Else
                                                      Fc< - 0.0
        CMPTEQ/SU       16.5A5
        CMPTLE          16.0A7  Fa.rt,Fb.rt,Fc.wq     If Fav   Fbv Then
                                                      Fc< - 2.0 Else
                                                      Fc< - 0.0
        CMPTLE/SU       16.5A7
        CMPTLT          16.0A6  Fa.rt,Fb.rt,Fc.wq     If Fav < Fbv Then
                                                      Fc< - 2.0 Else
                                                      Fc< - 0.0
        CMPTLT/SU       16.5A6

                                                 (continued on next page)




        A-26

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        CMPTUN          16.0A4  Fa.rt,Fb.rt,Fc.wq     If Fav Unordered
                                                      Fbv Then Fc< - 2.0
                                                      Else Fc< - 0.0
        CMPTUN/SU       16.5A4
        CMPULE          10.3D   Ra.rq,{Rb.rq          If Rav U  Rbv Then
                                /#b.ib},Rc.wq         Rc< - 1 Else Rc< - 0
        CMPULT          10.1D   Ra.rq,{Rb.rq          If Rav U< Rbv Then
                                /#b.ib},Rc.wq         Rc< - 1 Else Rc< - 0
        CPYS            17.020  Fa.rq,Fb.rq,Fc.wq     Fc< - Fav<63> ||
                                                      Fbv<62:0>
        CPYSE           17.022  Fa.rq,Fb.rq,Fc.wq     Fc< - Fav<63:52> ||
                                                      Fbv<51:0>
        CPYSN           17.021  Fa.rq,Fb.rq,Fc.wq     Fc< - NOT Fav<63>
                                                      || Fbv<62:0>
        CVTDG           15.09E  Fb.rd,Fc.wg           Fc< - D_Float to
                                                      G_Float of Fbv
        CVTDG/C         15.01E
        CVTDG/S         15.49E
        CVTDG/SC        15.41E
        CVTDG/SU        15.59E
        CVTDG/SUC       15.51E
        CVTDG/U         15.19E
        CVTDG/UC        15.11E
        CVTGD           15.0AD  Fb.rg,Fc.wd           Fc< - G_Float to
                                                      D_Float of Fbv
        CVTGD/C         15.02D
        CVTGD/S         15.4AD
        CVTGD/SC        15.42D
        CVTGD/SU        15.5AD
        CVTGD/SUC       15.52D
        CVTGD/U         15.1AD
        CVTGD/UC        15.12D
        CVTGF           15.0AC  Fb.rg,Fc.wf           Fc< - G_Float to
                                                      F_Float of Fbv
        CVTGF/C         15.02C
        CVTGF/S         15.4AC
        CVTGF/SC        15.42C

                                                 (continued on next page)


                                                                     A-27

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        CVTGF/SU        15.5AC
        CVTGF/SUC       15.52C
        CVTGF/U         15.1AC
        CVTGF/UC        15.12C
        CVTGQ           15.0AF  Fb.rg,Fc.wq           Fc< - G_Float to
                                                      quad of Fbv
        CVTGQ/C         15.02F
        CVTGQ/S         15.4AF
        CVTGQ/SC        15.42F
        CVTGQ/SV        15.5AF
        CVTGQ/SVC       15.52F
        CVTGQ/V         15.1AF
        CVTGQ/VC        15.12F
        CVTLQ           17.010  Fb.rl,Fc.wq           Fc< - SEXT(Fbv<63:62>||Fbv<58:29>)
        CVTQF           15.0BC  Fb.rq,Fc.wf           Fc< - Quad to F_
                                                      Float of Fbv
        CVTQF/C         15.03C
        CVTQG           15.0BE  Fb.rq,Fc.wg           Fc< - Quad to G_
                                                      Float of Fbv
        CVTQG/C         15.03E
        CVTQL           17.030  Fb.rq,Fc.wl           Fc< - Quad to long
                                                      of Fbv
        CVTQL/SV        17.530
        CVTQL/V         17.130
        CVTQS           16.0BC  Fb.rq,Fc.ws           Fc< - Quad to S_
                                                      Float of Fbv
        CVTQS/C         16.03C
        CVTQS/D         16.0FC
        CVTQS/M         16.07C
        CVTQS/SUI       16.7BC
        CVTQS/SUIC      16.73C
        CVTQS/SUID      16.7FC
        CVTQS/SUIM      16.77C
        CVTQT           16.0BE  Fb.rq,Fc.wt           Fc< - Quad to T_
                                                      Float of Fbv
        CVTQT/C         16.03E
        CVTQT/D         16.0FE

                                                 (continued on next page)


        A-28

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        CVTQT/M         16.07E
        CVTQT/SUI       16.7BE
        CVTQT/SUIC      16.73E
        CVTQT/SUID      16.7FE
        CVTQT/SUIM      16.77E
        CVTST           16.2AC  Fb.rs,Fc.wt           Fc< - S_Float to
                                                      T_Float of Fbv
        CVTST/S         16.6AC
        CVTTQ           16.0AF  Fb.rt,Fc.wq           Fc< - T_Float to
                                                      quad of Fbv
        CVTTQ/C         16.02F
        CVTTQ/D         16.0EF
        CVTTQ/M         16.06F
        CVTTQ/SV        16.5AF
        CVTTQ/SVC       16.52F
        CVTTQ/SVD       16.5EF
        CVTTQ/SVI       16.7AF
        CVTTQ/SVIC      16.72F
        CVTTQ/SVID      16.7EF
        CVTTQ/SVIM      16.76F
        CVTTQ/SVM       16.56F
        CVTTQ/V         16.1AF
        CVTTQ/VC        16.12F
        CVTTQ/VD        16.1EF
        CVTTQ/VM        16.16F
        CVTTS           16.0AC  Fb.rt,Fc.ws           Fc< - T_Float to
                                                      S_Float of Fbv
        CVTTS/C         16.02C
        CVTTS/D         16.0EC
        CVTTS/M         16.06C
        CVTTS/SU        16.5AC
        CVTTS/SUC       16.52C
        CVTTS/SUD       16.5EC
        CVTTS/SUI       16.7AC
        CVTTS/SUIC      16.72C
        CVTTS/SUID      16.7EC
        CVTTS/SUIM      16.76C

                                                 (continued on next page)


                                                                     A-29

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        CVTTS/SUM       16.56C
        CVTTS/U         16.1AC
        CVTTS/UC        16.12C
        CVTTS/UD        16.1EC
        CVTTS/UM        16.16C
        DIVF            15.083  Fa.rf,Fb.rf,Fc.wf     Fc< - Fav / Fbv
        DIVF/C          15.003
        DIVF/S          15.483
        DIVF/SC         15.403
        DIVF/SU         15.583
        DIVF/SUC        15.503
        DIVF/U          15.183
        DIVF/UC         15.103
        DIVG            15.0A3  Fa.rg,Fb.rg,Fc.wg     Fc< - Fav / Fbv
        DIVG/C          15.023
        DIVG/S          15.4A3
        DIVG/SC         15.423
        DIVG/SU         15.5A3
        DIVG/SUC        15.523
        DIVG/U          15.1A3
        DIVG/UC         15.123
        DIVS            16.083  Fa.rs,Fb.rs,Fc.ws     Fc< - Fav / Fbv
        DIVS/C          16.003
        DIVS/D          16.0C3
        DIVS/M          16.043
        DIVS/SU         16.583
        DIVS/SUC        16.503
        DIVS/SUD        16.5C3
        DIVS/SUI        16.783
        DIVS/SUIC       16.703
        DIVS/SUID       16.7C3
        DIVS/SUIM       16.743
        DIVS/SUM        16.543
        DIVS/U          16.183
        DIVS/UC         16.103
        DIVS/UD         16.1C3
        DIVS/UM         16.143

                                                 (continued on next page)


        A-30

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        DIVT            16.0A3  Fa.rt,Fb.rt,Fc.wt     Fc< - Fav / Fbv
        DIVT/C          16.023
        DIVT/D          16.0E3
        DIVT/M          16.063
        DIVT/SU         16.5A3
        DIVT/SUC        16.523
        DIVT/SUD        16.5E3
        DIVT/SUI        16.7A3
        DIVT/SUIC       16.723
        DIVT/SUID       16.7E3
        DIVT/SUIM       16.763
        DIVT/SUM        16.563
        DIVT/U          16.1A3
        DIVT/UC         16.123
        DIVT/UD         16.1E3
        DIVT/UM         16.163
        EQV             11.48   Ra.rq,{Rb.rq          Rc< - Rav XOR {NOT
                                /#b.ib},Rc.wq         Rbv}
        EXCB            18.0400                       Exception barrier
        EXTBL           12.06   Ra.rq,{Rb.rq          Rc< - Byte extract
                                /#b.ib},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        EXTLH           12.6A   Ra.rq,{Rb.rq          Rc< - Long extract
                                /#b.ib},Rc.wq         high from Rav at
                                                      Rbv<2:0>
        EXTLL           12.26   Ra.rq,{Rb.rq          Rc< - Long extract
                                /#b.ib},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        EXTQH           12.7A   Ra.rq,{Rb.rq          Rc< - Quad extract
                                /#b.ib},Rc.wq         high from Rav at
                                                      Rbv<2:0>
        EXTQL           12.36   Ra.rq,{Rb.rq          Rc< - Quad extract
                                /#b.ib},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        EXTWH           12.5A   Ra.rq,{Rb.rq          Rc< - Word extract
                                /#b.ib},Rc.wq         high from Rav at
                                                      Rbv<2:0>

                                                 (continued on next page)


                                                                     A-31

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        EXTWL           12.16   Ra.rq,{Rb.rq          Rc< - Word extract
                                /#b.ib},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        FBEQ            31      Fa.rq,disp.al         If Fav = 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        FBGE            36      Fa.rq,disp.al         If Fav   0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        FBGT            37      Fa.rq,disp.al         If Fav > 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        FBLE            33      Fa.rq,disp.al         If Fav   0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        FBLT            32      Fa.rq,disp.al         If Fav < 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        FBNE            35      Fa.rq,disp.al         If Fav /= 0
                                                      Then PC< - PC +
                                                      {4*SEXT(disp)}
        FCMOVEQ         17.02A  Fa.rq,Fb.rq,Fc.wq     If Fav = 0 Then
                                                      Fc< - Fbv
        FCMOVGE         17.02D  Fa.rq,Fb.rq,Fc.wq     If Fav   0 Then
                                                      Fc< - Fbv
        FCMOVGT         17.02F  Fa.rq,Fb.rq,Fc.wq     If Fav > 0 Then
                                                      Fc< - Fbv
        FCMOVLE         17.02E  Fa.rq,Fb.rq,Fc.wq     If Fav   0 Then
                                                      Fc< - Fbv
        FCMOVLT         17.02C  Fa.rq,Fb.rq,Fc.wq     If Fav < 0 Then
                                                      Fc< - Fbv
        FCMOVNE         17.02B  Fa.rq,Fb.rq,Fc.wq     If Fav /= 0 Then
                                                      Fc< - Fbv
        FETCH           18.8000 0(Rb.ab)              Prefetch around
                                                      (Rbv)

                                                 (continued on next page)




        A-32

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        FETCH_M         18.A000 0(Rb.ab)              Prefetch around
                                                      (Rbv), modify
                                                      intent
        INSBL           12.0B   Ra.rq,{Rb.rq          Rc< - Byte insert
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        INSLH           12.67   Ra.rq,{Rb.rq          Rc< - Long insert
                                /#b.iq},Rc.wq         high from Rav at
                                                      Rbv<2:0>
        INSLL           12.2B   Ra.rq,{Rb.rq          Rc< - Long insert
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        INSQH           12.77   Ra.rq,{Rb.rq          Rc< - Quad insert
                                /#b.iq},Rc.wq         high from Rav at
                                                      Rbv<2:0>
        INSQL           12.3B   Ra.rq,{Rb.rq          Rc< - Quad insert
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        INSWH           12.57   Ra.rq,{Rb.rq          Rc< - Word insert
                                /#b.iq},Rc.wq         high from Rav at
                                                      Rbv<2:0>
        INSWL           12.1B   Ra.rq,{Rb.rq          Rc< - Word insert
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        JMP             1A.0    [Ra.wq],(Rb.ab),hint  Ra< - PC; PC< - Rbv
                                                      AND {NOT 3}
        JSR             1A.1    Ra.wq,(Rb.ab),hint    Ra< - PC; PC< - Rbv
                                                      AND {NOT 3}
        JSR_COROUTINE   1A.3    Ra.wq,(Rb.ab),hint    Ra< - PC; PC< - Rbv
                                                      AND {NOT 3}
        LDA             08      Ra.wq,disp.ab(Rb.ab)  Ra< - Rbv +
                                                      SEXT(disp)
        LDAH            09      Ra.wq,disp.ab(Rb.ab)  Ra< - Rbv +
                                                      SEXT(disp*65536)
        LDF             20      Fa.wf,disp.ab(Rb.ab)  Fa< - ({Rbv +
                                                      SEXT(disp)})

                                                 (continued on next page)



                                                                     A-33

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        LDG             21      Fa.wg,disp.ab(Rb.ab)  Fa< - ({Rbv +
                                                      SEXT(disp)})
        LDL             28      Ra.wq,disp.ab(Rb.ab)  Ra< - SEXT(({Rbv +
                                                      SEXT(disp)})<31:0>)
        LDL_L           2A      Ra.wq,disp.ab(Rb.ab)  Ra< - SEXT(({Rbv +
                                                      SEXT(disp)})<31:0>)
        LDQ             29      Ra.wq,disp.ab(Rb.ab)  Ra< - ({Rbv +
                                                      SEXT(disp)})
        LDQ_L           2B      Ra.wq,disp.ab(Rb.ab)  Ra< - ({Rbv +
                                                      SEXT(disp)})
        LDQ_U           0B      Ra.wq,disp.ab(Rb.ab)  Ra< - ({{Rbv +
                                                      SEXT(disp)} AND NOT
                                                      7})
        LDS             22      Fa.ws,disp.ab(Rb.ab)  Fa< - ({Rbv +
                                                      SEXT(disp)})
        LDT             23      Fa.wt,disp.ab(Rb.ab)  Fa< - ({Rbv +
                                                      SEXT(disp)})
        MB              18.4000                       Memory barrier
        MF_FPCR         17.025  Fa.rq,Fa.rq,Fa.wq     Fa< - FPCR
        MSKBL           12.02   Ra.rq,{Rb.rq          Rc< - Byte mask
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        MSKLH           12.62   Ra.rq,{Rb.rq          Rc< - Long mask
                                /#b.iq},Rc.wq         high from Rav at
                                                      Rbv<2:0>
        MSKLL           12.22   Ra.rq,{Rb.rq          Rc< - Long mask
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        MSKQH           12.72   Ra.rq,{Rb.rq          Rc< - Quad mask
                                /#b.iq},Rc.wq         high from Rav at
                                                      Rbv<2:0>
        MSKQL           12.32   Ra.rq,{Rb.rq          Rc< - Quad mask
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        MSKWH           12.52   Ra.rq,{Rb.rq          Rc< - Word mask
                                /#b.iq},Rc.wq         high from Rav at
                                                      Rbv<2:0>

                                                 (continued on next page)


        A-34

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        MSKWL           12.12   Ra.rq,{Rb.rq          Rc< - Word mask
                                /#b.iq},Rc.wq         low from Rav at
                                                      Rbv<2:0>
        MT_FPCR         17.024  Fa.rq,Fa.rq,Fa.wq     FPCR< - Fa
        MULF            15.082  Fa.rf,Fb.rf,Fc.wf     Fc< - Fav * Fbv
        MULF/C          15.002
        MULF/S          15.482
        MULF/SC         15.402
        MULF/SU         15.582
        MULF/SUC        15.502
        MULF/U          15.182
        MULF/UC         15.102
        MULG            15.0A2  Fa.rg,Fb.rg,Fc.wg     Fc< - Fav * Fbv
        MULG/C          15.022
        MULG/S          15.4A2
        MULG/SC         15.422
        MULG/SU         15.5A2
        MULG/SUC        15.522
        MULG/U          15.1A2
        MULG/UC         15.122
        MULL            13.00   Ra.rl,{Rb.rl          Rc< - SEXT((Rav *
                                /#b.ib},Rc.wq         Rbv)<31:0>)
        MULL/V          13.40
        MULQ            13.20   Ra.rq,{Rb.rq          Rc< - Rav * Rbv
                                /#b.ib},Rc.wq
        MULQ/V          13.60
        MULS            16.082  Fa.rs,Fb.rs,Fc.ws     Fc< - Fav * Fbv
        MULS/C          16.002
        MULS/D          16.0C2
        MULS/M          16.042
        MULS/SU         16.582
        MULS/SUC        16.502
        MULS/SUD        16.5C2
        MULS/SUI        16.782
        MULS/SUIC       16.702
        MULS/SUID       16.7C2
        MULS/SUIM       16.742

                                                 (continued on next page)


                                                                     A-35

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        MULS/SUM        16.542
        MULS/U          16.182
        MULS/UC         16.102
        MULS/UD         16.1C2
        MULS/UM         16.142
        MULT            16.0A2  Fa.rt,Fb.rt,Fc.wt     Fc< - Fav * Fbv
        MULT/C          16.022
        MULT/D          16.0E2
        MULT/M          16.062
        MULT/SU         16.5A2
        MULT/SUC        16.522
        MULT/SUD        16.5E2
        MULT/SUI        16.7A2
        MULT/SUIC       16.722
        MULT/SUID       16.7E2
        MULT/SUIM       16.762
        MULT/SUM        16.562
        MULT/U          16.1A2
        MULT/UC         16.122
        MULT/UD         16.1E2
        MULT/UM         16.162
        ORNOT           11.28   Ra.rq,{Rb.rq          Rc< - Rav OR {NOT
                                /#b.ib},Rc.wq         Rbv}
        RC              18.E000 Ra.wq                 Ra< - intr_flag;
                                                      intr_flag< - 0
        RET             1A.2    [Ra.wq],(Rb.ab),hint  Ra< - PC; PC< - Rbv
                                                      AND {NOT 3}
        RPCC            18.C000 Ra.wq                 Ra< - Process cycle
                                                      counter
        RS              18.F000 Ra.wq                 Ra< - intr_flag;
                                                      intr_flag< - 1
        S4ADDL          10.02   Ra.rl,{Rb.rl          Rc< - SEXT(((SLL(Rav,2))
                                /#b.ib},Rc.wq         + Rbv)<31:0>)
        S4ADDQ          10.22   Ra.rq,{Rb.rq          Rc< - SLL(Rav,2) +
                                /#b.ib},Rc.wq         Rbv
        S4SUBL          10.0B   Ra.rl,{Rb.rl          Rc< - SEXT(((SLL(Rav,2))
                                /#b.ib},Rc.wq         - Rbv)<31:0>)

                                                 (continued on next page)


        A-36

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        S4SUBQ          10.2B   Ra.rq,{Rb.rq          Rc< - SLL(Rav,2) -
                                /#b.ib},Rc.wq         Rbv
        S8ADDL          10.12   Ra.rl,{Rb.rl          Rc< - SEXT(((SLL(Rav,3))
                                /#b.ib},Rc.wq         + Rbv)<31:0>)
        S8ADDQ          10.32   Ra.rq,{Rb.rq          Rc< - SLL(Rav,3) +
                                /#b.ib},Rc.wq         Rbv
        S8SUBL          10.1B   Ra.rl,{Rb.rl          Rc< - SEXT(((SLL(Rav,3))
                                /#b.ib},Rc.wq         - Rbv)<31:0>)
        S8SUBQ          10.3B   Ra.rq,{Rb.rq          Rc< - SLL(Rav,3) -
                                /#b.ib},Rc.wq         Rbv
        SLL             12.39   Ra.rq,{Rb.rq          Rc< - SLL(Rav,Rvb<5:0>)
                                /#b.ib},Rc.wq
        SRA             12.3C   Ra.rb,{Rb.rq          Rc< - SRA(Rav,Rvb<5:0>)
                                /#b.ib},Rc.wq
        SRL             12.34   Ra.rq,{Rb.rq          Rc< - SRL(Rav,Rvb<5:0>)
                                /#b.ib},Rc.wq
        STF             24      Fa.rf,disp.ab(Rb.ab)  ({Rbv +
                                                      SEXT(disp)})< - Fav
        STG             25      Fa.rg,disp.ab(Rb.ab)  ({Rbv +
                                                      SEXT(disp)})< - Fav
        STL             2C      Ra.rl,disp.ab(Rb.ab)  ({Rbv + SEXT(disp)})<31:0>< - Rav<31:0>
        STL_C           2E      Ra.ml,disp.ab(Rb.ab)  ({Rbv + SEXT(disp)})<31:0>< - Rav<31:0>
        STQ             2D      Ra.rq,disp.ab(Rb.ab)  ({Rbv +
                                                      SEXT(disp)})< - Rav
        STQ_C           2F      Ra.mq,disp.ab(Rb.ab)  ({Rbv +
                                                      SEXT(disp)})< - Rav
        STQ_U           0F      Ra.rq,disp.ab(Rb.ab)  ({{Rbv +
                                                      SEXT(disp)} AND
                                                      NOT 7})< - Rav
        STS             26      Fa.rs,disp.ab(Rb.ab)  ({Rbv +
                                                      SEXT(disp)})< - Fav
        STT             27      Fa.rt,disp.ab(Rb.ab)  ({Rbv +
                                                      SEXT(disp)})< - Fav
        SUBF            15.081  Fa.rf,Fb.rf,Fc.wf     Fc< - Fav - Fbv
        SUBF/C          15.001
        SUBF/S          15.481
        SUBF/SC         15.401

                                                 (continued on next page)


                                                                     A-37

 



        MACRO-64 Alpha AXP Architecture Quick Reference
        A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        SUBF/SU         15.581
        SUBF/SUC        15.501
        SUBF/U          15.181
        SUBF/UC         15.101
        SUBG            15.0A1  Fa.rg,Fb.rg,Fc.wg     Fc< - Fav - Fbv
        SUBG/C          15.021
        SUBG/S          15.4A1
        SUBG/SC         15.421
        SUBG/SU         15.5A1
        SUBG/SUC        15.521
        SUBG/U          15.1A1
        SUBG/UC         15.121
        SUBL            10.09   Ra.rl,{Rb.rl          Rc< - SEXT((Rav -
                                /#b.ib},Rc.wq         Rbv)<31:0>)
        SUBL/V          10.49
        SUBQ            10.29   Ra.rq,{Rb.rq          Rc< - Rav - Rbv
                                /#b.ib},Rc.wq
        SUBQ/V          10.69
        SUBS            16.081  Fa.rs,Fb.rs,Fc.ws     Fc< - Fav - Fbv
        SUBS/C          16.001
        SUBS/D          16.0C1
        SUBS/M          16.041
        SUBS/SU         16.581
        SUBS/SUC        16.501
        SUBS/SUD        16.5C1
        SUBS/SUI        16.781
        SUBS/SUIC       16.701
        SUBS/SUID       16.7C1
        SUBS/SUIM       16.741
        SUBS/SUM        16.541
        SUBS/U          16.181
        SUBS/UC         16.101
        SUBS/UD         16.1C1
        SUBS/UM         16.141
        SUBT            16.0A1  Fa.rt,Fb.rt,Fc.wt     Fc< - Fav - Fbv
        SUBT/C          16.021
        SUBT/D          16.0E1

                                                 (continued on next page)


        A-38

 



                          MACRO-64 Alpha AXP Architecture Quick Reference
                                     A.9 Common Architecture Instructions


        Table_A-10_(Cont.)_Common_Architecture_Instructions______________

        Mnemonic________Code____Operands______________Operation__________

        SUBT/M          16.061
        SUBT/SU         16.5A1
        SUBT/SUC        16.521
        SUBT/SUD        16.5E1
        SUBT/SUI        16.7A1
        SUBT/SUIC       16.721
        SUBT/SUID       16.7E1
        SUBT/SUIM       16.761
        SUBT/SUM        16.561
        SUBT/U          16.1A1
        SUBT/UC         16.121
        SUBT/UD         16.1E1
        SUBT/UM         16.161
        TRAPB           18.0000                       Drain any pending
                                                      traps
        UMULH           13.30   Ra.rq,{Rb.rq          Rc< - {Rav *U
                                /#b.ib},Rc.wq         Rbv}<127:64>
        WMB             18.4400                       Write memory
                                                      barrier
        XOR             11.40   Ra.rq,{Rb.rq          Rc< - Rav XOR Rbv
                                /#b.ib},Rc.wq
        ZAP             12.30   Ra.rq,{Rb.rq          Rc< - Zap from Rav,
                                /#b.iq},Rc.wq         byte mask Rbv<7:0>
        ZAPNOT          12.31   Ra.rq,{Rb.rq          Rc< - Zap from
                                /#b.iq},Rc.wq         Rav, byte mask NOT
        ______________________________________________Rbv<7:0>___________















                                                                     A-39

 










                                                                        B
        _________________________________________________________________

                                               Programming with MACRO-64


              This appendix contains information to help you program more
              effectively using the MACRO-64 assembly language within the
              framework of the OpenVMS Calling Standard. It discusses the
              following information:

              o  The OpenVMS Calling Standard

              o  Accessing Memory with Base Registers

              o  Types of Data Structures

              o  Types of Routines

              o  Example Program

              o  Self Addressability

              o  Optimization and Automatic Alignment

              For more information on the AXP environment, you should
              become familiar with the following manuals:

              o  Alpha Architecture Reference Manual

              o  OpenVMS Calling Standard

              o  Alpha AXP architecture

        B.1 OpenVMS Calling Standard

              All OpenVMS languages supplied by Digital support the
              OpenVMS Calling Standard. With most compiled AXP languages,
              the OpenVMS Calling Standard is invisible to you as the
              programmer. However, when programming with the MACRO-
              64 assembly language, you are responsible for defining
              the appropriate data structures and using appropriate
              instruction sequences in order to implement routines that
              comply with the OpenVMS Calling Standard.

                                                                      B-1

 



        Programming with MACRO-64
        B.1 OpenVMS Calling Standard


              Refer to Chapter 6 for a description of several library
              macros that are supplied with the MACRO-64 Assembler.

              An important role of the OpenVMS Calling Standard is
              support for debugging, exception handling, and traceback
              routines. These routines are aided by the OpenVMS Calling
              Standard data structures and conventions to determine the
              current routine and the source of its call. In addition,
              these structures and conventions enable the debugger to
              interpret other information, such as data stored on the
              stack or in registers.

              Again, when programming in MACRO-64 assembly language, it
              is important that you as the programmer correctly define
              the data structures and adhere to the conventions defined
              by the OpenVMS Calling Standard.

        B.2 Accessing Memory with Base Registers

              The Alpha AXP architecture is a base-register architecture.
              Memory locations can only be accessed relative to a base
              address stored in one of the base registers.

              The Alpha AXP architecture has 31 general, base registers,
              R0 through R30. R31 is a special base register, which
              always reads as zero. Any attempt to store a value in R31
              is ignored.

              Since memory-reference instructions use a 16-bit, signed
              displacement relative to the base address, elevated-mode
              programs may access the low and high 32K bytes of the
              virtual address space relative to R31. See Figure B-1.

              However, these areas of virtual memory are typically not
              accessible to user-mode programs.

              Base Register Architecture

              Base-register architectures use different methods to
              obtain an initial base address for a routine. Typically,
              base-register architectures load the current program
              counter (PC) into a base register. Thus, data can be
              accessed relative to a location in the code. This method
              is inconsistent with the high performance objectives of the
              Alpha AXP architecture for the following reasons:

        B-2

 



                                               Programming with MACRO-64
                                 B.2 Accessing Memory with Base Registers


              o  It requires placing data areas adjacent to code areas,
                 which results in inefficient use of the instruction and
                 data caches.

              o  The memory locations near the boundary of the data
                 area and code would likely be duplicated in both the
                 instruction cache and the data cache, thus diminishing
                 the effectiveness of the caching algorithms.

              Procedure Value

              The OpenVMS Calling Standard simplifies obtaining a base
              address without requiring the data and code areas to be
              adjacent. When a program or routine needs to call another
              routine, it must load R27 with a procedure value. The
              procedure value is a special base address which is the
              address of the procedure descriptor of the routine it is
              calling.

              Procedure Descriptor

              The procedure value for a given routine is the address of
              the procedure descriptor for that routine. Section B.3.1
              describes the procedure descriptor in more detail.

              The procedure descriptor is a data block that resides in
              a special data area owned by the routine. This data area
              called the linkage section.

              Unlike VAX VMS external routine names, which reference
              its entry point, AXP external routine names reference
              the procedure descriptor which contains the entry point's
              address.

              Since the called routine has the address of its own
              procedure descriptor in R27, it can access not only its
              own procedure descriptor, but more importantly, it can
              use that address as a base address and access any data
              that is within 32K bytes on either side of its procedure
              descriptor.

              Linkage Section

              The special data area where the procedure descriptor
              resides is called the linkage section. The linkage section
              is actually a program section (psect) that contains
              the routine's procedure descriptor. The linkage section
              performs the following function:

                                                                      B-3

 



        Programming with MACRO-64
        B.2 Accessing Memory with Base Registers


              o  Allows other routines to link to the routine using the
                 procedure descriptor.

              o  Uses it to link to other areas of memory in order to
                 receive and store data.

              o  Stores the addresses of other routines, allowing the
                 routine to call those routines.

              Figure B-2 illustrates how you access memory using base
              addresses:

              1  The called routine can access memory in its own linkage
                 section relative to R27 since R27 contains a base
                 address within its linkage section, specifically, the
                 address of its procedure descriptor.

              2  Since memory-reference instructions use a 16-bit
                 displacement relative to the base address, the linkage
                 section can be up to 64K bytes in size with direct
                 access relative to R27.

                 In addition, the linkage section psect typically has the
                 NOWRT attribute and contains only address constants and
                 possibly other constants in order to facilitate placing
                 the linkage section in a shared section in a sharable
                 image.

              3  If the called routine needs to access memory beyond
                 its own linkage section, it can store additional base
                 addresses in its linkage section, load them into base
                 registers as needed, and thereby access any legitimate
                 location in memory.

              4  To access read/write data, a separate read/write data
                 section is defined in a different psect with the WRT
                 attribute and the address of the read/write section is
                 stored in the linkage section.

              As shown in Figure B-2, the special base address passed
              in R27 provides the called routine with a seed of
              addressability from which it can directly access its own
              linkage section and from which it can indirectly access all
              of memory. Each routine in a call chain receives its seed
              of addressability from its caller.

        B-4

 



                                               Programming with MACRO-64
                                 B.2 Accessing Memory with Base Registers


              MAIN Program Call Chain

              The main routine in a program works in the same way. The
              operating system passes it a base address within its
              own linkage section in R27 just like any other calling
              standard-conforming routine. The operating system can
              establish its own seed of addressability in a variety of
              ways. The important programming consideration is that the
              main routine is given its requisite seed of addressability
              via the base address passed in R27 when the operating
              system calls the main routine. The main routine must in
              turn pass a seed of addressability in R27 to any routines
              that it calls, and so on down the call chain.

              Figure B-3 illustrates program start up and the program
              call chain.

              The call chain shown in Figure B-3 illustrates a typical
              program's call chain originating with the transfer to the
              program's entry point (MAIN) from the operating system. The
              MAIN routine calls routine A, which in turn calls B. A full
              prologue and epilogue are required for routines MAIN and
              A since they both make standard calls. The full prologue
              allocates the fixed stack area and saves the return address
              (R26), procedure value (R27), frame pointer (R29), and any
              preserved registers that are to be used by the routine.
              Finally, the full prologue establishes the routine's frame
              as the current frame. If MAIN or A need to access their
              respective linkage sections after making a standard call,
              they would save a preserved register in the prologue, move
              R27 to that register before using R27 in a standard call,
              use that register to access the linkage section after the
              call, and restore that register in the epilogue. Since B
              does not make any standard calls, its prologue and epilogue
              can be significantly streamlined.

              Note that all three routines access data in their
              respective linkage sections relative to the base address
              that is in R27 on entry. The caller refers to the callee
              by the address of the callee's procedure descriptor. The
              procedure-descriptor address is also called the procedure
              value (PV), and it is this address that is passed to the
              callee in R27. To make a call, the caller must store the
              address of the callee's procedure descriptor in its own
              linkage section. The caller can then load R27 from its
              own linkage section prior to the call. The caller then

                                                                      B-5

 



        Programming with MACRO-64
        B.2 Accessing Memory with Base Registers


              goes on to obtain the address of the callee's code from
              the callee's procedure descriptor. With the callee's code
              address (CA) in R26 and the callee's procedure-descriptor
              address in R27, the caller can transfer control to the
              callee with a jump-to-subroutine (JSR) instruction through
              R26, storing the return address in R26. A more optimal call
              sequence using a linkage pair is shown in Section B.3.3.

        B.3 Data Structures

              This section describes the OpenVMS Calling Standard data
              structures, and how to use them in practical applications.

              There are three data structures defined by the OpenVMS
              Calling Standard that you should be familiar with:

              o  Procedure descriptor

              o  Signature block

              o  Linkage pair

        B.3.1 Procedure Descriptor

              The procedure descriptor contains information that
              describes the routine. More importantly, it contains
              the address of the code for the routine. It includes the
              following information:

              o  Stack usage (if any)

              o  Register save/restore masks

              o  Exception handlers

              Usually, a routine's name references the routine's
              procedure descriptor, rather than the address of its
              code. For example, a global name for an external routine
              represents the address where the procedure descriptor
              resides, not the address of the routine's code. Programs
              which call the routine obtain the address of its code from
              its procedure descriptor or using a linkage pair.

              The .PROCEDURE_DESCRIPTOR and .LOCAL_PROCEDURE_DESCRIPTOR
              assembler directives define the name of the procedure
              descriptor, and indicates that the block of storage
              that follows is the procedure descriptor for the
              specified routine. .PROCEDURE_DESCRIPTOR and
              .LOCAL_PROCEDURE_DESCRIPTOR also associate the code

        B-6

 



                                               Programming with MACRO-64
                                                      B.3 Data Structures


              addresss of the routine's entry point with the procedure
              name. The association between the code address and the
              procedure name allows the assembler and linker to process
              the .CODE_ADDRESS and .LINKAGE_PAIR directives. For more
              information on linkage pairs, see Section B.3.3.

              You need to declare the correct amount of storage,
              and specify the correct initial values. The
              .PROCEDURE_DESCRIPTOR and .LOCAL_PROCEDURE_DESCRIPTOR
              directives do not create the storage for the procedure
              descriptor. Instead, they mark the storage that follows
              as a procedure descriptor, resulting in a special object-
              module record. Use the $ROUTINE and $PROCEDURE_DESCRIPTOR
              macros to both mark the procedure descriptor and define
              the storage for the procedure descriptor. For information
              on these macros, see Chapter 6. For information on the
              procedure descriptor format, see the OpenVMS Calling
              Standard.

        B.3.2 Signature Block

              The signature block describes the parameters, parameter
              passing methods, and return value used by the routine.
              Using the signature block is optional. If it is used,
              the procedure descriptor references it. $ROUTINE and
              $PROCEDURE_DESCRIPTOR macros can by used to define the
              signature block. For information on these macros, see
              Chapter 6.

        B.3.3 Linkage Pair

              You can make calls to routines more efficient by using the
              .LINKAGE_PAIR and .LOCAL_LINKAGE directives. .LINKAGE_PAIR
              and .LOCAL_LINKAGE store both the address of the specified
              routine's code and procedure descriptor (a total of two
              quad-words).

              For example, the assembler provides the .CODE_ADDRESS and
              .LOCAL_CODE_ADDRESSS directives to obtain the address of a
              routine's code (a quadword). To obtain the address of the
              routine's code and procedure descriptor, you can use either
              the .CODE_ADDRESS or .LOCAL_CODE_ADDRESSS in conjunction
              with the .ADDRESS directive. The following example shows
              how you would use these directives to obtain the code
              address and and procedure descriptor of routine X:

                                                                      B-7

 



        Programming with MACRO-64
        B.3 Data Structures


                  .CODE_ADDRESS X         ; Store address of X's code (entry point)
                  .ADDRESS      X         ; Store address of X's procedure descriptor

              .LINKAGE_PAIR performs the same function as using
              .CODE_ADDRESS and .ADDRESS together, as shown in the
              following example:

                  .LINKAGE_PAIR X

              Using Linkage Pairs in Routines

              Another example of how you can use linkage pairs is shown
              in Example B-1 and Example B-2. Example B-1 shows a code
              sequence that does not use a linkage pair:

              Example B-1 Routine Without Linkage Pairs

                      .enable local_block

                      .psect $LINKAGE,noexe
              LS:     .procedure_descriptor MY_PROC, MY_CODE
                      ; MY_PROC procedure descriptor details...
              X_ADDR: .address X                      ; Store address of X's proc desc

                      .psect $CODE,exe
              MY_CODE: ; R27 -> LS upon entry
                      ; Prologue omitted for clarity...
                      LDQ     R27,X_ADDR-LS(R27)      ; R27 -> proc desc for X
                      LDQ     R26,8(R27)              ; R26 -> code for X  1
                      JSR     R26,(R26)               ; CALL X             2
                      ; Epilogue omitted for clarity...

              While the previous code sequence works correctly, it has
              two immediate stalls in the instruction sequence:

              1  The first stall occurs when the second LDQ instruction
                 must wait for the preceding load to R27 to complete.

              2  The second stall occurs when the JSR instruction must
                 wait for the preceding load to R26 to complete.

              Since routine calls occur frequently, these stalls would
              significantly increase the amount of time for the routine
              to execute.

        B-8

 



                                               Programming with MACRO-64
                                                      B.3 Data Structures


              The following example is similar to Example B-1, except it
              uses a linkage pair to call routine X.

              Example B-2 Routine With Linkage Pairs

                      .enable local_block

                      .psect $LINKAGE,noexe
              LS:     .procedure_descriptor MY_PROC, MY_CODE
                      ;MYPROC procedure descriptor details...
              X_LP:   .LINKAGE_PAIR X                 ; Store address of X's code
                                                      ; followed by address of X's
                                                      ; proc desc

                      .psect $CODE,exe
              MY_CODE: ; R27 -> LS upon entry
                      ; Prologue omitted for clarity...
                      LDQ     R26,<X_LP+0>-LS(R27)    ; R26 -> code for X
                      LDQ     R27,<X_LP+8>-LS(R27)    ; R27 -> proc desc for X
                      JSR     R26,(R26)               ; CALL X
                      ; Epilogue omitted for clarity...

              Although the same number of instructions are required,
              the two immediate stalls in the instruction sequence are
              eliminated.

              You can also use the $LINKAGE_PAIR macro or the $CALL
              macro. For more information on these macros, see Chapter 6.
              Note that the $CALL macro generates an instruction sequence
              similar to that shown in Example B-2.

        B.4 Types of Routines

              The OpenVMS Calling Standard defines four different
              types of routines with four different kinds of procedure
              descriptors.

              The format varies slightly for each kind of procedure
              descriptor. The four types of routines are:

              o  Null frame

              o  Register frame

              o  Stack frame (fixed and variable)

              o  Bound frame

                                                                      B-9

 



        Programming with MACRO-64
        B.4 Types of Routines


              A null frame routine is a light-weight routine similar
              in concept to a JSB-linkage routine on VAX. A null-frame
              routine executes in the context of its caller and is
              therefore restricted in the operations that it can perform.
              As shown in Table B-1, a null-frame routine requires the
              least overhead and offers the least capabilities.

              A register frame routine creates its own frame and
              therefore executes in its own context. A register-
              frame routine is an intermediate-weight routine, with
              intermediate capabilities and overhead. A register-frame
              routine maintains the context of its callers in registers.

              A stack frame routine has two categories: fixed and
              variable.

              o  With the fixed frame stack, the stack frame size does
                 not vary. A fixed stack frame routine creates its own
                 frame and stores the context of its caller on the stack.
                 A fixed stack frame routine is also an intermediate
                 weight routine with intermediate capabilities and
                 overhead. The only significant capability lacking
                 with a fixed stack frame routine is the ability to make
                 standard calls.

              o  With the variable frame stack, the stack frame size
                 may vary. A variable stack frame routine is the full
                 function, heavyweight type of routine. It creates its
                 own stack frame and stores the context of its caller on
                 the stack. The variable stackframe routine is the only
                 type of routine that can make standard calls.

              A bound frame routine is generally used in compiled
              languages such as Ada and Pascal that require a dynamic,
              up level link to data in an outer routine. Most assembly-
              language programming does not involve bound frame routines.

        B.4.1 Routine Capabilities

              The types of operations that a routine may perform and the
              amount of required overhead in the routine's prologue and
              epilogue instruction sequences are different for each type
              of routine.


        B-10

 



                                               Programming with MACRO-64
                                                    B.4 Types of Routines


              The capabilities and overhead requirements of null frame,
              register frame, fixed stack frame, and variable stack frame
              routines are summarized in Table B-1:

        Table_B-1_Frame_Attributes_______________________________________

                                              Variable
                                      Fixed
                                      RegisterRegisterFixed   Variable
                              Null                    Stack   Stack
        ______________________Frame___Frame___Frame___Frame___Frame______

        Executes in Frame of  Yes     No      No      No      No
        Caller

        Where Caller's        -       RegisterRegisterstack   Stack
        Context is Kept

        Can Allocate Stack    -       Yes     Yes     Yes     Yes
        in Proloque

        Must Allocate Stack   -       No      No      Yes     Yes
        in Prologue

        Can Allocate Stack    RestrictNo      Yes     No      Yes
        in Routine Body

        Can Have an           No      Yes     Yes     Yes     Yes
        Exception Handler

        Can Save/Restore      RestrictNo      No      Yes     Yes
        Registers

        Can Make Standard     RestrictNo      No      No      Yes
        Calls____________________________________________________________

              For more information on routines, see the OpenVMS Calling
              Standard.

        B.4.2 Entry Prologue and Exit Epilogue Sequences

              In general, a standard sequence of instructions are used
              when a routine first starts and when it completes. The
              following code example shows a typical entry prologue
              sequence for a variable stack-frame procedure. Several
              elements of the prologue may be omitted for less complex
              routines.

                                                                     B-11

 



        Programming with MACRO-64
        B.4 Types of Routines


              ENTRY:  LDA     SP, -32(SP)     ; Allocate fixed stack area  1
                      STQ     R27, (SP)       ; Save procedure value
                      STQ     R26, 8(SP)      ; Save return address
                      STQ     R2, 16(SP)      ; Save any preserved regs that are used
                      STQ     FP, 24(SP)      ; Save old FP
                      MOV     SP, FP          ; Establish current frame
                      $END_PROLOGUE           ; Marks the end of the proloque 2

              1  The ENTRY label marks the code entry point for the
                 routine.

              2  The $END_PROLOGUE macro is used to mark the end of the
                 proloque.

              The following code example shows a typical exit epilogue
              sequence for a variable stack frame procedure. Several
              elements of the epilogue may be omitted for routines of
              less complexity.

                      $BEGIN_EPILOGUE         ; Mark the beginning of the epilogue 1
                      MOV     FP, SP          ; Release the variable stack area
                      LDQ     R28, 8(FP)      ; Fetch return address
                      LDQ     R2, 16(FP)      ; Restore preserved registers
                      LDQ     FP, 24(FP)      ; Reestablish caller's frame
                      LDA     SP, 32(SP)      ; Release the fixed stack area
                      RET     R28             ; Return to caller
                      $END_EPILOGUE           ; Mark the end of the epilogue 1

              1  In this example, the $BEGIN_EPILOGUE and $END_EPILOGUE
                 macros are used to begin and end the epilogue sequence.

              The $ROUTINE macro optionally generates a standard prologue
              instruction sequence at the beginning of the routine. In
              addition, you can also use the $RETURN macro to generate a
              standard epilogue sequence. For more information on these
              macros, see Chapter 6.

        B.5 Example Program

              The following example shows a simple routine, ROUTINE1,
              that does the following:

              o  Takes a single, longword parameter as input.

              o  Calls another function, ROUTINE2, passing its own
                 parameter as a parameter to ROUTINE2.

        B-12

 



                                               Programming with MACRO-64
                                                      B.5 Example Program


              o  Adds the return value from ROUTINE2 and the value of an
                 external longword, I, storing the result in a register.

              o  Returns the result of the addition to its caller in R0.

                      $ROUTINE ROUTINE1, KIND=STACK, SAVED_REGS=<R2,FP>
                      $LINKAGE_SECTION
                      I_ADDR: .address I              ; Linkage to external I
                      $CODE_SECTION
                                                      ; The prologue instruction sequence
                                                      ; is generated by $ROUTINE by
                                                      ; default

                      ; Routine body
                      .BASE   R27,$LS                 ; Inform assembler that
                                                      ; R27 -> linkage section
                      LDQ     R0, I_ADDR              ; R0 -> I
                      LDL     R2, (R0)                ; R2 <- I
                      MOV     1, R25                  ; AI <- 1 (R16 already contains
                                                      ;  the argument)
                      $CALL   ROUTINE2                ; Call ROUTINE2, R27->linkage sect
                      ADDL    R2, R0, R0              ; retval <- retval + I
                      $RETURN                         ; $RETURN generates the epilogue
                                                      ; sequence.
                      $END_ROUTINE ROUTINE1

        B.6 Establishing Self-Addressability

              A MACRO-64 routine can establish addressability to its own
              linkage section without the help of its caller (the calling
              routine). In this case, the caller does not pass the
              procedure value in R27, as in a standard call. Therefore,
              the routine must establish its own base address within its
              linkage section.

              To accomplish self-addressability, the code and linkage
              sections must be adjacent to each other. This requires them
              to reside in the same psect. Because the assembler does not
              allow placement of data in a EXE/NOMIX psect, instructions
              must be placed in an EXE/MIX psect. When debugging, the
              debugger views execution to have transferred into a data
              area, because the debugger views all MIX psects as data.



                                                                     B-13

 



        Programming with MACRO-64
        B.6 Establishing Self-Addressability


                ________________________ NOTE ________________________

                The debugger can correctly display decoded
                instructions in a MIX psect, but it cannot achieve
                source line /program-counter correlation and source
                line scrolling.

                ______________________________________________________

              Example B-3 represents the CLEAR_X_ARRAY routine, which has
              no procedure descriptor.

              Example B-3 Establishing a Base Address

                      .psect CLEAR_X_ARRAY_CODE,exe,mix,quad
              X_ARRAY_ADDR:
                      .address X_ARRAY
              X_ARRAY_SIZE:
                      .long <X_ARRAY_END - X_ARRAY> / 8

              CLEAR_X_ARRAY::
                      BSR     R1,10$                  ; R1 -> 10$
              10$:    LDQ     R22,X_ARRAY_ADDR-10$(R1); R22 -> X_ARRAY
                      LDL     R23,X_ARRAY_SIZE-10$(R1); R23 <- REMAINING
              20$:    CLR     R31,(R22)               ; [X_ARRAY_PTR] <- 0
                      LDA     R22,8(R22)              ; X_ARRAY_PTR<-X_ARRAY_PTR+8
                      LDA     R23,-1(R23)             ; REMAINING<-REMAINING-1
                      BGT     R23,20$                 ; Branch if REMAINING > 0
                      RET     (R26)                   ; Return
                      .end

              Other routines may call the CLEAR_X_ARRAY routine using
              only its code address and a nonstandard linkage. The
              CLEAR_X_ARRAY routine executes in the context of its
              caller, it does not create its own frame. It establishes
              a base address in its code section and because its linkage
              section is adjacent to its code section, it can access data
              in its linkage section.







        B-14

 



                                               Programming with MACRO-64
                                 B.7 Optimization and Automatic Alignment


        B.7 Optimization and Automatic Alignment

              MACRO-64 provides the following optimizations:

              o  Automatic data alignment

              o  Automatic code alignment

              o  Scheduling

              o  Peepholing

              All optimizations and automatic alignment are off, by
              default. When invoking MACRO-64, the default qualifiers
              are /NOOPTIMIZE and /NOALIGNMENT.

              You can control optimization and automatic alignment using
              the following qualfiers and directives:

              o  The /OPTIMIZE and /ALIGNMENT qualifiers

              o  The .ENABLE and .DISABLE directives

              o  The .BEGIN_EXACT and .END_EXACT directives

              The .ENABLE and .DISABLE directives control optimization
              and automatic code alignment for an assembly unit; you
              cannot use these directives to control optimization and
              automatic code alignment for a range of statements. Use
              .BEGIN_EXACT and .END_EXACT to suppress optimization for a
              range of statements.

        B.7.1 Automatic Data Alignment

              Access to naturally aligned data is faster than access
              to unaligned data. MACRO-64 does not align data by
              default. Instead, it places data exactly as specified,
              with no padding. With automatic data alignment selected,
              data directives are automatically aligned on a natural
              boundary. Pad bytes are added as necessary to achieve
              natural alignment. Labels that occur with the data are
              automatically aligned with the data.



                                                                     B-15

 



        Programming with MACRO-64
        B.7 Optimization and Automatic Alignment


        B.7.1.1 Controlling Data Alignment

              You can control when you want to have data alignment in
              your program. You do this by using the .ENABLE ALIGN_DATA
              and .DISABLE ALIGN_DATA directives. Note that automatic
              data alignment is disabled by default. Example B-4 shows
              how to enable and disable data alignment.

              Example B-4 Enabling and Disabling Data Alignment

              .PSECT D1,DATA,NONEXE
              .DISABLE ALIGN_DATA     ; This is the default state 1
              .BYTE   1               ; offset = 0
              .QUAD   2               ; offset = 1
              .PSECT D2,DATA,NOEXE
              .ENABLE ALIGN_DATA      ; Turn on automatic alignment 2
              .BYTE   1               ; offset = 0
              .QUAD   2               ; offset = 8 (pad bytes are added at offsets 1 - 7)

              1  The .DISABLE_ALIGN_DATA directive causes the assembler
                 to allocate data at the current location with padding,
                 regardless of whether it is within a natural boundary.

              2  The .ENABLE_ALIGN_DATA directive causes the assembler
                 to align data objects on natural rather than byte
                 boundaries.

        B.7.1.2 Directives for Automatic Data Alignment

              The following MACRO-64 data storage directives provide
              optional, automatic alignment. See Table B-2.

              Table_B-2_Directives_Using_Automatic_Alignment_____________

              Directive_____________Alignment_Boundary___________________

              .WORD                 word (2)

              .SIGNED_WORD          word (2)

              .LONG                 longword (4)

              .ADDRESS              quadword (8)

              .OCTA                 octaword (16)

              .QUAD                 quadword (8)

                                                 (continued on next page)

        B-16

 



                                               Programming with MACRO-64
                                 B.7 Optimization and Automatic Alignment


              Table_B-2_(Cont.)_Directives_Using_Automatic_Alignment_____

              Directive_____________Alignment_Boundary___________________

              .CODE_ADDRESS         quadword (8)

              .LOCAL_CODE_ADDRESS   quadword (8)

              .LINKAGE_PAIR         octaword (16)

              .LOCAL_LINKAGE_PAIR   octaword (16)

              .PROCEDURE_           quadword (8)
              DESCRIPTOR

              .LOCAL_PROCEDURE_     quadword (8)
              DESCRIPTOR

              .F_FLOATING (.FLOAT)  longword (4)

              .D_FLOATING           quadword (8)
              (.DOUBLE)

              .G_FLOATING           quadword (8)

              .S_FLOATING           longword (4)

              .T_FLOATING           quadword (8)

              .BLKA                 quadword (8)

              .BLKD                 quadword (8)

              .BLKF                 longword (4)

              .BLKG                 quadword (8)

              .BLKL                 longword (4)

              .BLKO                 octaword (16)

              .BLKQ                 quadword (8)

              .BLKS                 longword (4)

              .BLKT                 quadword (8)

              .BLKW                 word (2)

              .ASCID                quadword (8)

              .INSTRUCTION__________longword_(4)_________________________

              Specify a .PSECT directive alignment attribute that aligns
              the psect on a boundary that is at least as stringent as
              the automatically aligned data items.

                                                                     B-17

 



        Programming with MACRO-64
        B.7 Optimization and Automatic Alignment


        B.7.2 Automatic Code Label Alignment

              Automatic code label alignment improves I-cache utilization
              and multi-instruction issue. This optimization aligns
              certain code labels to a quadword boundary by padding with
              NOP and FNOP instructions. Use the /ENVIRONMENT=NOFLOAT
              qualifier to suppress FNOP instructions.

              Code labels that are the target of backward branches are
              aligned. Also, labels that are the target of forward
              branches that are not also the target of a fall through
              are aligned.

              Use the /ALIGNMENT=CODE qualifier or the .ENABLE ALIGN_CODE
              directive to select automatic code label alignment.

        B.7.3 Scheduling Optimization

              Scheduling reorders instructions to reduce pipeline stalls
              and increases the chances for multi-instruction issue.
              It only reorders instructions; it does not change the
              instructions or the registers used in the instructions.
              In addition, instructions are not scheduled across labels.
              Therefore, the structure of your program is retained.

                ________________________ Note ________________________

                If you use the same register for two or more logically
                distinct actions, the scheduler schedules these
                actions serially in the sequence you specify. If you
                use different registers for two or more logically
                distinct actions, the scheduler schedules the actions
                in parallel, providing faster execution performance.

                ______________________________________________________

              Use the /OPTIMIZE=SCHEDULE qualifier or the .ENABLE
              SCHEDULE directive to select scheduling optimization.

        B.7.4 Peephole Optimization

              Peephole optimization restructures your program for faster
              execution. To do so, it reduces the number of instructions
              executed and replaces long-executing instructions with
              instructions that require less execution time. Although
              this optimization may increase the number of instructions
              in memory, the number actually executed, as you follow
              the code paths, decreases or remains the same. Peephole

        B-18

 



                                               Programming with MACRO-64
                                 B.7 Optimization and Automatic Alignment


              optimization matches short code patterns and replaces them
              with more optimal sequences. It also eliminates dead code.
              (Note that dead code is often created by the code changes
              made by peephole optimization. This dead code is eliminated
              by successive iterations where peephole optimization is
              selected.) Peephole optimization eliminates some branches
              by inlining or replicating short sequences from the branch
              target.

              Use the /OPTIMIZE=PEEPHOLE qualifier or the .ENABLE
              PEEPHOLE directive to select peephole optimization.

        B.7.5 Using MACRO-64 for Performance

              High-order language compilers do optimizations called
              loop unrolling and inlining. MACRO-64 allows you to
              perform these optimizations manually through coding
              techniques, although it does not offer specific qualifiers
              or directives for these optimizations.

              Loop unrolling reduces the number of branches that must be
              executed. You can unroll loops using the .REPEAT directive.
              The following example shows manual loop unrolling:

              10$:                          ; Copy loop
              .repeat 10                    ; Unroll the loop, factor=10
                  LDA     R18, -1(R18)      ; Decrement quad-word count
                  BLT     R18, 20$          ; Branch if quad-word count < 0
                  LDQ     R0, (R17)         ; Load a quad-word
                  STQ     R0, (R16)         ; Store the quad-word
                  LDA     R16, 8(R16)       ; Increment the target address
                  LDA     R17, 8(R17)       ; Increment the source address
                  BR 10$
              20$:
              .endr

              Loop unrolling complimented with MACRO-64 shcheduling
              and peephole optimizations can significantly increase
              performance. For better loop scheduling, you can make the
              counter decrement and the loop exit separable.





                                                                     B-19

 



        Programming with MACRO-64
        B.7 Optimization and Automatic Alignment


              10$:                          ; Copy loop
              .repeat 10                    ; Unroll the loop, factor=10
                  LDA     R18, -1(R18)      ; Decrement quad-word count
                  LDQ     R0, (R17)         ; Load a quad-word
                  BLT     R18, 20$          ; Branch if quad-word count < 0
                  STQ     R0, (R16)         ; Store the quad-word
                  LDA     R16, 8(R16)       ; Increment the target address
                  LDA     R17, 8(R17)       ; Increment the source address
                  BR 10$
              20$:
              .endr

              High oder language compilers often inline a routine call
              if the called routine is small and is defined in the same
              module from which it is called. To inline a routine call,
              the compiler replaces the routine call with the body of
              the called routine. You can use macros to manually inline
              short, local routines with MACRO-64..

        B.7.6 Viewing Optimization Results

              You can view the results of optimization by comparing
              code from before and after optimization. Use the /LIST
              and /MACHINE_CODE command line qualifiers described in
              Section 1.2.1. Using these qualifiers provides you with a
              binary machine code listing.



















        B-20

 










                                                                        C
        _________________________________________________________________

                                                  Using LSE with MACRO-64


              This appendix explains how to use the Language-Sensitive
              Editor (LSE) with the MACRO-64 language. For LSE to
              function correctly, LSE must be installed prior to the
              MACRO-64 assembler.

        C.1 Invoking LSE

              To use LSE with the MACRO-64 language, you must name
              your program source file with a .M64 file extension. For
              example, to edit a file named TEST.M64, enter the following
              command:

              $ LSE TEST.M64

              Using the .M64 file extension invokes the LSE editor and
              places you in the MACRO-64 language environment.

              If you choose to use a different file extension, you can
              still use LSE in the MACRO-64 language environment. For
              example, to edit a file named TEST.ASM, enter the following
              command:

                   $ LSE/LANGUAGE=MACRO64 TEST.ASM

        C.2 Running Diagnostics

              You can run diagnostics in LSE to debug programs without
              leaving the LSE editor. For more information, see the
              Guide to Language-Sensitive Editor for VMS Systems and
              the MACRO-64 release notes.

              When running diagnostics in an LSE editing session, MACRO-
              64 displays error messages of different severity levels.
              For more information on error messages, see Appendix E.


                                                                      C-1

 










                                                                        D
        _________________________________________________________________

                                               Differences from VAX MACRO


              MACRO-64 is a new product that provides a macro assembly
              language for the native Alpha AXP instruction set. The
              MACRO-64 instruction set is completely different from the
              VAX MACRO instruction set. Although many of the directives
              are the same between VAX MACRO and MACRO-64, it would not
              be practical to share instruction sequences between the two
              assembly languages.

              While MACRO-64 is compatible with VAX MACRO, even allowing
              shared source modules between VAX MACRO and MACRO-64
              using common assembler directives and through conditional
              assembly, several differences exist. This appendix contains
              two sections describing the differences in assembly
              directives and features:

              o  Section D.1 describes new features in MACRO-64 that are
                 not present in VAX MACRO.

              o  Section D.2 describes features in VAX MACRO that are not
                 present in MACRO-64.

        D.1 Assembler Features in MACRO-64

              This section describes MACRO-64 features not present in
              VAX MACRO.

              o  .BASE directive

                 The .BASE directive is provided for implicit base
                 register support.

              o  .PROCEDURE_DESCRIPTOR and .LOCAL_PROCEDURE_DESCRIPTOR
                 directives



                                                                      D-1

 



        Differences from VAX MACRO
        D.1 Assembler Features in MACRO-64


                 These directives mark the specified identifier as a
                 procedure descriptor. .PROCEDURE_DESCRIPTOR declares
                 an identifier as a global label that defines the
                 address of the procedure's description (a data
                 address) and associate the procedure's entry point
                 (a code address) with the name of the procedure.
                 .LOCAL_PROCEDURE_DESCRIPTOR performs a similar function,
                 defining a local label rather than a global label. No
                 storage is allocated. For more information on these
                 directives, see Chapter 5.

              o  .LINKAGE_PAIR and .LOCAL_LINKAGE_PAIR directives

                 These directives cause a linkage pair to be stored
                 at the current psect and current location counter. A
                 linkage pair consists of a code address and the address
                 of the specified identifier. For more information on
                 these directives, see Chapter 5.

              o  .CODE_ADDRESS AND .LOCAL_CODE_ADDRESS directives

                 These directives cause the code address(es) of the
                 specified identifier(s) to be placed at the current
                 psect and current location counter. See Chapter 5 for
                 more information.




















        D-2

 



                                               Differences from VAX MACRO
                                       D.1 Assembler Features in MACRO-64


              o  .ELSE directive

                 MACRO-64 introduces a new conditional-assembly
                 directive, .ELSE. It can be used in conjunction with
                 the .IF and .ENDC directives (common to VAX MACRO and
                 MACRO-64) to specify a sequence of statements to be
                 assembled when the condition in the controlling .IF
                 directive is false. While the .ELSE directive is similar
                 to VAX MACRO's .IF_FALSE directive, it differs in that
                 you may specify at most one .ELSE directive within a .IF
                 /.ENDC block. .IF_FALSE is also provided for VAX MACRO
                 compatibility. See Chapter 5 for more information.

              o  .INCLUDE directive

                 MACRO-64 provides a new .INCLUDE directive that causes a
                 specified file to be textually included in the assembly.
                 The format of this directive is as follows:

                 .INCLUDE "file_specification" ["Directory_search_list"]

                 The effect of the .INCLUDE directive is similar to that
                 of the #include directive in C or the REQUIRE statement
                 in BLISS.

              o  Optional case sensitivity in identifiers

                 You can specify the /NAMES=AS_IS command-line qualifier
                 to cause the assembler to distinguish between uppercase
                 and lowercase letters in identifiers and external symbol
                 names. The default is /NAMES=UPPERCASE; uppercase
                 and lowercase letters are not distinguished, as with
                 VAX MACRO. See Chapter 1 for more information.

              o  Lexical operator support for 10 lexical operators.

                 MACRO-64 provides 10 lexical operators, three of which
                 are compatible with VAX MACRO's three macro string
                 operators. MACRO-64 lexical operators can be used in any
                 context, and are not restricted to macros. See Chapter 3
                 for more information.

              o  Lexical string symbols

                 See Chapter 3 for more information.

              o  Lexical escape operator (%%)

                 See Chapter 3 for more information.

              o  Lexical substitution operator (%lexsym_name%)

                                                                      D-3

 



        Differences from VAX MACRO
        D.1 Assembler Features in MACRO-64


                 See Chapter 3 for more information.

              o  More liberal use of value-of operator (\)

                 MACRO-64 as well as VAX MACRO recognizes the value-of
                 operator (\) in macro invocations and in default-
                 value strings for parameters in .MACRO directives. In
                 addition, MACRO-64 recognizes the value-of operator (\)
                 in the following contexts:

                 -  With either or both of the two arguments in the .IF
                    DIFFERENT and .IF IDENTICAL directives.

                 -  With the argument to the .IF BLANK and .IF NOT_BLANK
                    directives.

                 -  With the second argument to the .NCHR and .IRPC
                    directives.

                 -  With the second and subsequent arguments to the .IRP
                    directive.

                 -  With arguments to lexical operators. See Chapter 4
                    for more information.





















        D-4

 



                                               Differences from VAX MACRO
                                       D.1 Assembler Features in MACRO-64


              o  MACRO64$ symbol

                 MACRO-64 implicitly defines a new symbol, MACRO64$, for
                 use in conditional assembly. This symbol is defined
                 in all uppercase and all lowercase letters when
                 /NAMES=AS_IS is specified on the command line. This
                 symbol might be used as follows:

                 .MACRO ADDRESS32 EXPR_LIST
                     .IF DEFINED MACRO64$
                     .LONG EXPR_LIST
                     .IF_FALSE
                     .ADDRESS EXPR_LIST
                     .ENDC
                 .ENDM ADDRESS32
                 ADDRESS32 <A,B,C>

              o  Automatic data alignment

                 .ENABLE_ALIGN_DATA causes data to be naturally aligned.
                 See Chapter 5.

              o  Optimizations

                 The assembler optionally performs a number of
                 optimizations. See Chapter 2 (command line) and
                 Chapter 5 (.ENABLE).

              o  $OPDEF macro

                 $OPDEF is supplied in place of VAX MACRO's .OPDEF
                 directive.

              o  OpenVMS Calling Standard Macros:

                 $ROUTINE              $SEND_PROLOGUE

                 $CALL                 $LINKAGE_SECTION

                 $CODE_SECTION         $DATA_SECTION

                 $LINKAGE_PAIR         $BEGIN_EPILOGUE

                 $RETURN               $END_EPILOGUE

                 $PROCEDURE_
                 DESCRIPTOR

              o  .INSTRUCTION directive

                 For more information on the .INSTRUCTION directive, see
                 Chapter 5.

              o  .BEGIN_EXACT and .END_EXACT directives

                                                                      D-5

 



        Differences from VAX MACRO
        D.1 Assembler Features in MACRO-64


                 For more information on these directives, see Chapter 5.

        D.2 VAX MACRO Features Not Present in MACRO-64

              This section contains features in VAX MACRO that are not
              present in MACRO-64.

              o  EXE/NOEXE restriction

                 MACRO-64 allows only instructions to be placed in a
                 psect with either the EXE or MIX attributes, or both.
                 Data can be placed in a psect with either the NOEXE or
                 MIX attributes, or both. VAX MACRO allows instructions
                 and or data to be arbitrarily placed in psects.

              o  Setting the current location in an EXE/NOMIX psect

                 MACRO-64 does not permit the current location counter to
                 be changed in a psect with the EXE and NOMIX attributes.
                 VAX MACRO does not have this restriction.

























        D-6

 



                                               Differences from VAX MACRO
                           D.2 VAX MACRO Features Not Present in MACRO-64


              o  Radix unary operators

                 VAX MACRO allows unary radix operators on expressions.
                 MACRO-64 allows unary radix operators only to specify
                 the radix of numeric constants. The octal constant ^O123
                 is valid with both VAX MACRO and MACRO-64. The octal
                 expression ^O(10 + 10) is valid with VAX MACRO; it is
                 not valid with MACRO-64.

              o  The Register mask operator

                 The VAX MACRO ^M operator is not supported on MACRO-64.
                 Because register masks are not needed by any MACRO-64
                 instructions or directives, there is no need for this
                 operator.

              o  .ALIGN does not support PAGE

                 Because the Alpha architecture has variable page sizes,
                 MACRO-64 does not support PAGE as an argument to the
                 .ALIGN directive.

              o  No count specifiers on data storage directives

                 MACRO-64 does not allow a repeat count expression on
                 any data storage directive such as .BYTE or .WORD. The
                 %REPEAT lexical function can be used for this purpose.

              o  No support for .CROSS/.NOCROSS

                 There is no support for these directives in MACRO-64.

              o  No support for .DEBUG

                 There is no support for this directive in MACRO-64.
                 However, even though this directive is not supported,
                 MACRO-64 provides symbolic information in the object
                 module for use by the debugger.

              o  No .DEFAULT directive

                 This directive in not applicable on MACRO-64.

              o  .ENABLE/.DISABLE directive arguments

                 The MACRO-64 assembler does not support the following
                 arguments to the .ENABLE or .DISABLE directives:

                 -  ABSOLUTE-Not applicable on MACRO-64

                 -  DEBUG

                 -  SUPPRESSION

                                                                      D-7

 



        Differences from VAX MACRO
        D.2 VAX MACRO Features Not Present in MACRO-64


                 -  TRACEBACK

                 -  TRUNCATION

              o  .END directive differences

                 VAX MACRO requires the .END directive. MACRO-64 does not
                 require this directive. MACRO-64 requires the optional
                 identifier that follows the .END directive to be a
                 previously declared procedure descriptor.

              o  .ENTRY directive not supported

                 Instead, a $ROUTINE macro that accomplishes a similar
                 function is used.

              o  No .GLOBAL directive

                 There is no support for this directive. VAX MACRO
                 provided this directive for MACRO-11 compatibility only.

























        D-8

 



                                               Differences from VAX MACRO
                           D.2 VAX MACRO Features Not Present in MACRO-64


              o  No .H_FLOATING directive

                 Since this data type is not a native MACRO-64 type, this
                 directive is not supported.

              o  Changes to .IDENT

                 The argument to the .IDENT directive must be a quoted
                 literal.

              o  No .LINK directive

                 There is no support for this directive.

              o  No .MASK directive

                 This directive is not applicable to MACRO-64.

              o  No .NTYPE directive

                 This directive is not supported by MACRO-64. The %TYPE
                 lexical operator provides a similar function.

              o  No .OPDEF directive

                 There is no support for this directive. The $OPDEF macro
                 provides a similar function.

              o  Differences in .PSECT directive

                 The following .PSECT arguments are not supported: PAGE,
                 LIB, and USR.

              o  No .REFn directives

                 There is no support for these directives.

              o  Differences in .RESTORE directive

                 On successive .RESTOREs for the same psect, VAX MACRO
                 restores the current location counter value as the
                 last location counter value saved for the psect being
                 restored. MACRO-64 restores the current location counter
                 value as the location counter value saved for the
                 matching .SAVE directive.

              o  No .TRANSFER directive

                 There is no support for this directive.

              o  Differences with .ENDM and .ENDR

                                                                      D-9

 



        Differences from VAX MACRO
        D.2 VAX MACRO Features Not Present in MACRO-64


                 VAX MACRO considers the .ENDM and .ENDR directives to
                 be synonyms of each other. MACRO-64 considers .ENDM and
                 .ENDR to be distinct. You must end macro definitions
                 with .ENDM and you must end repeat ranges with .ENDR.









































        D-10

 










                                                                        E
        _________________________________________________________________

                                                           Error Messages


              This appendix describes the messages produced by the Alpha
              MACRO-64 assembler.

              The description of each message gives the severity,
              followed by additional explanatory text and suggested
              action.

         ADDTRUNC,  Storing an address expression into a storage
            allocation less than the size of an address will result
            in data truncation.

            Informational: The assembler has stored a value too large
            for the allocated space. Data truncation has occurred.

            User Action: Allocate more storage.

         ALIGNFILLIGN,  The optional .ALIGN fill pattern is being
            ignored. It is only valid for psects that do not possess
            the EXE and NOMIX attributes.

            Warning: The optional fill pattern specified is ignored
            since it is only valid for psects that do not possess the
            EXE and NOMIX attributes.

            User Action: Omit the fill pattern or specify the MIX psect
            attribute.

         ALIGNFILLTRUNC,  The value specified for the .ALIGN optional
            fill pattern should be an integer in the range of 0 . . . 255.
            Data truncation will occur with the currently specified fill
            pattern in a byte storage location.

            Warning: The value specified as the fill pattern for the
            .ALIGN directive should be in the range 0 . . . 255. Data
            truncation occurs when the specified value is out of this
            range.

            User Action: Specify a smaller value for the fill pattern.

                                                                      E-1

 



        Error Messages



         ALIGNLABELIGN,  The ALIGN_LABEL option has been replaced by the
            ALIGN_CODE option.

            Error: The ALIGN_LABEL option has been replaced by the
            ALIGN_CODE option.

            User Action: Use the recommended new option.

         ALIGNTOBIG,  Specified alignment too large for PSECT.

            Error: The requested alignment is too large for the current
            psect.

            User Action: Check the psect attributes and insure that
            the psect alignment is greater than or equal to what is
            requested.

         ASCIITRUNC,  ASCII constant contains too many characters; value
            truncated.

            Error: Your ASCII constant contains more than eight
            characters with the ^A or ^a radix specifier. The assembler
            deletes the extra characters.

            User Action: Check your source code. Use eight or less
            characters.

         BADALIGN,  Alignment specifier out of range.

            Error: The alignment specifier used with the .PSECT or
            .ALIGN directive is out of range.

            User Action: Consult the documentation description of the
            .PSECT or .ALIGN directive.

         BADENDARG,  Bad argument to .END directive.

            Error: The optional argument to the .END directive is
            invalid.

            User Action: The argument, if specified, must reference a
            procedure descriptor within the module. Specify a valid
            procedure descriptor name or omit the argument.

         BADINSARG,  Argument N invalid for this instruction.

            Error: The argument number shown is invalid for the
            instruction.

            User Action: Check the argument and required format as
            specified in the documentation.

        E-2

 



                                                           Error Messages



         BADLIB,  Error opening library file XXXXX.

            Error: The assembler encountered an error when attempting to
            open the indicated library file.

            User Action: Check the file format and file protections.

         BADMACPARAMNAME,  Illegal macro parameter name.

            Error: The indicated macro parameter name is illegal.

            User Action: Examine your source code and consult Chapter 1.

         BADMACRONAME,  Illegal macro name.

            Error: The indicated macro name is illegal.

            User Action: Check your source code and consult Chapter 2.

         BADOPERAND,  Invalid operand type for operator.

            Error: The resolved operand type is invalid for the
            specified operator.

            User Action: Consult the documentation descriptions of
            operators, operands, and expressions.

         BADPARAMSTR,  Illegal parameter string.

            Error: The string specified as a macro parameter is invalid.

            User Action: Check your source code and consult the
            documentation.

         BASEFAIL,  Argument N invalid. The assembler failed to find a
            base register specified with a previous .BASE directive to
            form a register expression of the form offset(Rn).

            Error: The assembler failed to find a base register
            specified with a previous .BASE directive to form a valid
            register expression of the form offset(Rn).

            User Action: Check the use of .BASE directives and the
            instruction in the source code.

         BEGEXPSC,  .BEGIN_EXACT is not valid in a psect with the NOEXE
            and NOMIX attributes.

            Error: A .BEGIN_EXACT directive is not valid in a psect with
            the NOEXE and NOMIX attributes.

            User Action: Check your source code.

                                                                      E-3

 



        Error Messages



         BYTEALIGNIGN,  The BYTE_ALIGN option has been replaced by the
            ALIGN_DATA option.

            Error: The BYTE_ALIGN option has been replaced by the ALIGN_
            DATA option.

            User Action: Use the recommended new option.

         CONPSECTATTR,  Contradictory PSECT attribute.

            Error: A previously specified psect attribute conflicts with
            the flagged psect attribute.

            User Action: Consult the documentation description of the
            .PSECT directive and psect attributes.

         CONTEOF,  End of file encountered after line continuation.

            Error: The assembler encountered end of file when the
            previous line encountered specified a continuation.

            User Action: Check your source code.

         DATAALIGNTOBIG,  Data requires alignment too large for PSECT.

            Error: The alignment required for a specified data item is
            too large for the psect.

            User Action: Check the psect attributes and insure that the
            psect alignment is greater than or equal to the required
            alignment of the data items.

         DATANOTINNOEXE,  Data declarations must be in a psect with the
            MIX, or NOEXE attribute.

            Error: A data declaration, such as a data storage directive,
            has been specified in a psect with incorrect psect
            attributes.

            User Action: Make sure the psect has the MIX, or NOEXE
            attribute set.

         DIRNOTINNOEXE,  Directive must be in a psect with the MIX, or
            NOEXE attribute.

            Error: The directive specified must appear in a psect with
            the MIX or NOEXE attribute set.

            User Action: Check to insure that a psect with the
            appropriate attributes has been specified.

        E-4

 



                                                           Error Messages



         DISPTOOLGE,  Branch offset is too large for this instruction.

            Error: The specified offset is too large for this
            instruction.

            User Action: Check the range of the specified target. It
            must be in the inclusive range -1048576 . . . +1048575.

         DUPLEXTERN,  EXTERN item is multiply defined.

            Error: The item declared as externally defined with
            the .EXTERNAL attribute also has a conflicting multiple
            definition within this assembly unit.

            User Action: Check the definitions of the specified item.

         DUPLGLOBAL,  Duplicate global name detected.

            Warning: A duplicate global has been detected by the
            assembler.

            User Action: Check all references in your source code to
            this name.

         DUPMACPARAMNAME,  Duplicate macro parameter name.

            Error: The indicated macro parameter name has been
            duplicated.

            User Action: Check your source code.

         ENDEXPSC,  .END_EXACT is not valid in a psect with the NOEXE and
            NOMIX attributes.

            Error: A .END_EXACT directive is not valid in a psect with
            the NOEXE and NOMIX attributes.

            User Action: Check your source code.

         EOLEXP,  End of line expected.

            Error: The assembler expected no more input from the current
            line.

            User Action: Check your source code.

         ESCAPE,  Illegal escape sequence in string literal; expected \,
            ", x, or X.

            Error: The specified escape sequence specified in the string
            literal is illegal.

            User Action: Check your source code.

                                                                      E-5

 



        Error Messages



         EXP32BITTRUNC,  Expected an integer in the range 0 . . . (2^32)-1
            for unsigned expression OR -(2^31) . . . +(2^31)-1 for signed
            expression. Data truncation to 32 bits.

            Warning: Integer found was not in the expected range.

            User Action: Check your source code. The literal must be in
            the range 0 . . . (2^32)-1 for an unsigned expression OR -
            (2^31) . . . +(2^31)-1 for signed expression. Data truncation
            to 32 bits will occur.

         EXP32BITTYPE,  Expected an integer in the range 0 . . . (2^32)-1
            for unsigned expression OR -(2^31) . . . +(2^31)-1 for signed
            expression.

            Error: Expected an unsigned integer value in the range
            0 . . . (2^32)-1 or a signed integer value in the range -
            (2^31) . . . +(2^31)-1.

            User Action: Check your source code.

         EXPBINEXPTERM,  Found XXXXX when expecting a binary operator or
            expression terminator.

            Error: The assembler expected a binary operator, such as the
            plus sign (+)  for binary addition, or an item to end the
            expression, such as the right bracket (>).

            User Action: Check the flagged item in the source statement.

         EXPFPREG,  Argument N invalid. Expected a floating point
            register.

            Error: The instruction argument cited is invalid. A floating
            point register is expected.

            User Action: Check your source code and the instruction
            documentation.

         EXPGENREG,  Argument N invalid. Expected a general register.

            Error: The instruction argument cited is invalid. A general
            register is expected.

            User Action: Check your source code and the instruction
            documentation.

        E-6

 



                                                           Error Messages



         EXPIDPROC,  Argument N invalid. Expected an identifier
            representing a procedure value.

            Error: The argument cited is invalid. The assembler expected
            a user identifier which represents a procedure value.

            User Action: Check your source code and the instruction
            documentation.

         EXPINTPAL,  Expected integer expression or PAL opcode.

            Error: Integer expession or PAL opcode missing.

            User Action: Replace the flagged item with an integer or PAL
            opcode.

         EXPLAB,  Argument N invalid. Expected a label defined in the
            same psect.

            Error: The cited argument is invalid. The assembler expected
            a label definition to occur in the same psect as its
            reference.

            User Action: Check your source code and the instruction
            documentation.

         EXPLITVAL,  Argument N invalid. Expected an integer literal
            value in the inclusive range 0 . . . 255.

            Error: The instruction argument cited is invalid. The
            assembler expected an integer literal in the range 0 . . .
            255.

            User Action: Check your source code and the instruction
            documentation.

         EXPMACRONAME,  Expected a valid macro name.

            Error: A valid macro name was expected in this context.

            User Action: Check your source code to insure that the
            item flagged is a user identifier, opcode, or non-macro
            directive.

         EXPPALOPLIT,  Argument N invalid. Expected an integer literal
            value in the inclusive range 0 . . . 67108863.

            Error: The instruction argument cited is invalid. The
            assembler expected an integer literal.

            User Action: Check your source code and the instruction
            documentation.

                                                                      E-7

 



        Error Messages



         EXPREGOFF,  Argument N invalid. Expected a general register
            expression of the form offset(Rn).

            Error: The cited argument is invalid. The assembler expected
            a general register expression of the form integer_offset(Rn)
            for this argument.

            User Action: Check the source code and the instruction
            documentation.

         EXPRESEXP,  Argument N invalid. Expected an expression with no
            forward references resolvable to psect +/- offset.

            Error: The argument cited is invalid. The assembler expected
            an expression with no forward references.

            User Action: Check your source code and the instruction
            documentation.

         EXPSTACKOVER,  Internal SEM expression stack overflow.

            Fatal: An internal error has occurred.

            User Action: Gather as much information as possible about
            the circumstances under which the error occurred, and submit
            an SPR.

         EXPTOOCMPLX,  Expression is too complex to evaluate.

            Error: The expression is too complex for the assembler to
            evaluate.

            User Action: Try grouping the expression components using
            angle brackets (< >). The most complex expression form
            handled by the assembler resolves to the form: <psect
            /symbol +/- offset> OPERATOR <psect/symbol +/- offset> where
            OPERATOR is one of: +, -, *, /, @, \, &, or !. Consult the
            documentation for further descriptions of the assembler
            evaluation of expressions.

         EXPZEROFF,  Argument N invalid. Expected a general register
            expression of the form 0(Rn) or (Rn).

            Error: The cited argument is invalid. The assembler expected
            a general register expression of the form 0(Rn).

            User Action: Check your source code and the instruction
            documentation.

        E-8

 



                                                           Error Messages



         FOUNDEXP,  Found XXXXX when expecting one of the following:
            XXXXX.

            Error: An unexpected item was found in a location where
            something else was expected.

            User Action: Check the unexpected item found in the
            source statement. Examine those items cited as expected
            as alternatives for the unexpected item.

         GENERROR,  Generated ERROR:

            Error: This was generated using the .ERROR directive.

            User Action: Examine your source code.

         GENPRINT,  Generated PRINT:

            Informational: This statement was generated with a .PRINT
            directive.

            User Action: Examine your source code.

         GENWARN,  Generated WARNING:

            Warning: This was generated using the .WARNING directive.

            User Action: Examine your source code.

         HEXSTR,  Illegal hexadecimal escape sequence in string literal.

            Error: The specified hexadecimal escape sequence is invalid.

            User Action: Check your source code and the documentation.

         IDFOUND,  Found identifier in the opcode field when expecting
            one of the following: opcode, directive, macro invocation,
            or symbol definition.

            Error: The identifier cited was unexpected. Rather, an
            opcode, directive, macro invocation, or symbol definition
            was expected.

            User Action: Check your source code.

         IDTOOLONG,  Identifier is longer than 31 characters.

            Error: The identifier exceeds the 31 character maximum size.

            User Action: Check your source code and rename or truncate
            the identifier.

                                                                      E-9

 



        Error Messages



         ILLASCII,  Illegal ASCII constant.

            Error: The assembler found an illegal ASCII constant with
            the 6A or ^a radix specifier.

            User Action: Check your source code.

         ILLBIN,  Illegal binary constant.

            Error: The assembler found an illegal binary constant with
            the ^B or ^b radix specifier.

            User Action: Check your source code.

         ILLDEC,  Illegal decimal constant.

            Error: The assembler found an illegal binary constant with
            the ^D or ^d radix specifier.

            User Action: Check your source code.

         ILLEXPON,  Illegal exponent in floating point constant.

            Error: The specified exponent of the floating point constant
            is illegal.

            User Action: Check your source code and the documentation.

         ILLFLOAT,  Illegal floating point constant.

            Error: The specified floating point constant is illegal.

            User Action: Check your source code and the documentation.

         ILLHEX,  Illegal hexadecimal constant.

            Error: The assembler found an illegal binary constant with
            the ^X or ^x radix specifier.

            User Action: Check your source code.

         ILLIFOP,  Illegal .IF operator.

            Error: An illegal operator was encountered as a .IF
            operator.

            User Action: Check your source code and the documentation
            for the .IF directive.

         ILLINCL,  Illegal .INCLUDE file specification.

            Error: An illegal .INCLUDE directive was encountered.

            User Action: Check the use of the .INCLUDE directive by your
            source code.

        E-10

 



                                                           Error Messages



         ILLOCT,  Illegal octal constant.

            Error: The assembler found an illegal binary constant with
            the ^O or ^o radix specifier.

            User Action: Check your source code.

         ILLOPERANDMIX,  Illegal operand mixing for operator.

            Error: The resolved operand types are invalid when used
            together with the specified operator.

            User Action: Consult the documentation descriptions of
            operators, operands, and expressions.

         ILLPROCRET,  Illegal procedure return; linkage register
            (argument 1) must be R31 when software hint (argument 3)
            is 1.

            Error: Illegal procedure return.

            User Action: Check the instruction arguments. When argument
            3, software hint, is 1, the first argument specifying the
            linkage register must be R31.

         ILLRADIX,  Illegal radix specifier in numeric constant; specify
            A, B, C, D, O, or X.

            Error: The assembler found an illegal radix specifier.

            User Action: Check your source code and use one of A, B, C,
            D, O, or X.

         INCLDEPTH,  .INCLUDE nest depth exceeds N - check for circular
            .INCLUDE.

            Error: The maximum level of include file depth has been
            exceeded.

            User Action: Check your source code for circular file
            inclusion.

         INCLOPEN,  .INCLUDE file open error.

            Error: Included file could not be opened.

            User Action: Check the file attributes, etc. of the
            specified .INCLUDE file.

                                                                     E-11

 



        Error Messages



         INSNOTINPSC,  Instructions must be in a MIX, NOEXE; MIX,EXE; or
            NOMIX,EXE PSECT.

            Error: An instruction has been specified in a psect with
            incorrect psect attributes.

            User Action: Make sure the psect has MIX, or EXE and NOMIX
            attributes set.

         INTERNAL,  Internal assembler error. Please submit an SPR.

            Fatal: An internal error has occurred.

            User Action: Gather as much information as possible about
            the circumstances under which the error occurred, and submit
            an SPR.

         INTERR,  Internal processing error in the SYN facility.

            Fatal: An internal error has occurred.

            User Action: Gather as much information as possible about
            the circumstances under which the error occurred, and submit
            an SPR.

         INVALIGNFILL,  Invalid optional fill pattern specified with
            .ALIGN directive.

            Error: An invalid fill pattern was specified.

            User Action: Check the second argument to the .ALIGN
            directive which is the alignment fill specifier. The
            argument must resolve to an integer. Check your source code
            and the .ALIGN documentation.

         INVBASEEXP,  Invalid expression for .BASE directive.

            Error: The expression is not valid for .BASE directive.

            User Action: The expression specified for a base register
            with the .BASE directive should contain no forward
            references and resolve to one of the following at this point
            in assembly: psect +/- offset, external symbol reference +/-
            offset, integer, label +/- offset where the label is defined
            in a psect with the EXE and NOMIX attributes. Consult the
            documentation for further description of the assembler
            evaluation of expressions.

        E-12

 



                                                           Error Messages



         INVBASEREG,  Invalid base register specified. Base register must
            be one of R0 through R30.

            Error: Invalid base register specified.

            User Action: Specify a base register as a general register
            from the range R0 . . . R30. R31 cannot be specified as a base
            register and is implicitly defined as .BASE R31, 0.

         INVBRTGT,  Invalid branch target. Branch target label must
            be defined in same psect as the branch instruction which
            references the label.

            Error: The specified label referenced as the target of a
            branch instruction must be defined in the same psect in
            which it is referenced.

            User Action: Consult the documentation for more information
            on labels.

         INVCA,  Invalid code address specified with procedure
            descriptor. Code address must be a non-temporary label
            defined in a psect with the EXE or MIX attribute after its
            use with .PROCEDURE_DESCRIPTOR.

            Error: The code address specified as the second argument to
            the .PROCEDURE_DESCRIPTOR directive is invalid.

            User Action: The code address must be a non-temporary label
            defined in a psect with the EXE or NOMIX attribute. Check
            your source code.

         INVEXP,  Found XXXXX when expecting a valid expression.

            Error: One of the following was expected by the assembler:
            integer, floating point constant, identifier, register,
            period (.),  left bracket (<), unary operator.

            User Action: Check the unexpected item found in the source
            statement.

         INVEXPRFORDIR,  Invalid expression type for directive.

            Error: The assembler resolved value for the expression in
            the cited directive is invalid.

            User Action: Consult the documentation for further
            explanation of the directive arguments and types.

                                                                     E-13

 



        Error Messages



         INVEXPRFORSYM,  Invalid expression type for symbol.

            Error: The assembler resolved value for the expression which
            is assigned to a local or global symbol is invalid.

            User Action: Expressions assigned to a symbol must contain
            no forward references and resolve to an integer or psect
            /label +/- offset. Consult the documentation for further
            descriptions of how the assembler determines symbol and
            expression values.

         INVFPCONST,  Invalid floating point value detected. Check value
            range for floating point data type.

            Error: An invalid floating point value has been detected.

            User Action: Check the specified range for the directive
            type.

         INVINSQUAL,  Instruction qualifier list specified is invalid for
            the opcode.

            Error: The instruction qualifier(s) specified with the
            opcode is/are invalid.

            User Action: Consult the documentation for a complete list
            of opcodes and valid instruction qualifiers.

         INVLCA,  Invalid or undefined code address found for procedure
            descriptor.

            Error: An invalid or undefined code address corresponds to
            the specified procedure descriptor.

            User Action: Check your source code for the specified code
            address.

         INVLISTOPT,  Invalid option specified with the .LIST or .SHOW
            directive.

            Error: An invalid option has been specified with the .LIST
            or .SHOW directive.

            User Action: Consult the documentation for valid directive
            options.

         INVLPD,  Invalid procedure descriptor specified.

            Error: An invalid procedure descriptor has been specified.
            There was no definition of a procedure descriptor by the
            specified name.

            User Action: Check your source code.

        E-14

 



                                                           Error Messages



         INVNLISTOPT,  Invalid option specified with the .NLIST or
            .NOSHOW directive.

            Error: An invalid option has been specified with the .NLIST
            or .NO_SHOW directive.

            User Action: Consult the documentation for valid directive
            options.

         INVOFF,  Attempting to specify data intialization with current
            psect offset that is outside the range of 0 to 2147483647.

            Error: The current psect offset is invalid for specifying a
            data initialization.

            User Action: Check your source code and the value of the
            current psect offset.

         INVREPCOUNT,  The integer value of the .REPEAT expression is not
            within the inclusive range of 0 . . . 65535. A zero value is
            assumed.

            Warning: The value of the .REPEAT expression must be in the
            inclusive range of 0 . . . 65535. Therefore, a zero expression
            value is assumed.

            User Action: Specify a repetition count between 0 and 65535.

         INVSAVEOPT,  Invalid option specified with the .SAVE_PSECT
            directive.

            Error: An invalid option has been specified with the .SAVE_
            PSECT directive.

            User Action: Consult the documentation for valid directive
            options.

         INVTEMPLAB,  Invalid use of temporary label.

            Error: A temporary label reference is not allowed in this
            context.

            User Action: Consult the documentation on use of temporary
            labels for a further description.

         INVTERM,  Found N when expecting a valid expression term.

            Error: An unexpected item was found where an expression was
            expected. It expected one of the following: floating point
            number, integer, register, decimal point (.),  identifier, or
            left bracket (<).

            User Action: Check the item flagged by the assembler.

                                                                     E-15

 



        Error Messages



         LABELNOTDEF,  Undefined label encountered.

            Error: The specified label is undefined.

            User Action: Consult the documentation for descriptions of
            the valid labels.

         LABELREDECL,  Illegal redefinition of label.

            Error: The label is being illegally defined in multiple
            places in this assembly unit.

            User Action: Check all references to this label in your
            source code.

         LABNOTINPSECT,  Label must be declared in a PSECT.

            Error: A temporary, local, or global label declaration is
            being made and no psect has been established.

            User Action: Make sure the a .PSECT directive has been
            issued prior to the appearance of the label declaration
            in the source stream.

         LEXOPEDITSPEC,  Unrecognized edit specifier:

            Error: The edit specifier for the %EDIT lexical operator is
            unrecognized.

            User Action: Check your source code and consult the
            documentation on lexical operators.

         LEXOPENDM,  Illegal modification of .ENDM directive keyword by
            lexical operation.

            Error: While your macro definition contains a .ENDM
            directive that ends the macro definition, the .ENDM
            directive is modified by a lexical operator such that it
            can no longer be recognized as a .ENDM directive keyword
            after lexical processing.

            User Action: Change the statement to avoid modifying the
            .ENDM directive keyword with lexical operator processing.


        E-16

 



                                                           Error Messages



         LEXOPENDR,  Illegal modification of .ENDR directive keyword by
            lexical operation.

            Error: While your repeat range contains a .ENDR directive
            that ends the repeat block, the .ENDR directive is modified
            by a lexical operator such that it can no longer be
            recognized as a .ENDR directive keyword after lexical
            processing.

            User Action: Change the statement to avoid modifying the
            .ENDR directive keyword with lexical operator processing.

         LEXOPSYNTAX,  Illegal lexical operator syntax (missing left or
            right parenthesis, missing comma, etc.).

            Error: The indicated lexical operator has a syntax error.

            User Action: Check the source code to insure correct syntax
            and placement of parenthesis.

         LEXSYM,  XXXXX is already a lexical string symbol name; it
            cannot also be a numeric symbol.

            Error: You cannot have a lexical and numeric symbol by this
            same name.

            User Action: Check your source code and remove either the
            lexical or numeric symbol definition.

         LIBMOD_BADFORMAT,  Library module XXXXX contains illegal syntax
            (missing .MACRO or label preceding .MACRO, missing or not
            matching .ENDM, or other macro syntax error).

            Error: Illegal syntax was encountered.

            User Action: Check the syntax of the macro.

         LIBMOD_EMPTY,  Library module XXXXX is empty.

            Warning: The assembler encountered an empty library module.

            User Action: Replace the library module.

         LIBMOD_EXTRA,  Library module XXXXX contains extraneous text
            after .ENDM; extra text ignored.

            Warning: The assembler encountered extraneouse text after a
            .ENDM directive in a library module. This text is ignored.

            User Action: Correct the library module.

                                                                     E-17

 



        Error Messages



         LIBMOD_NOT_FOUND,  Library module XXXXX not found.

            Error: The indicated library module was not found.

            User Action: Check the spelling of the macro library and
            module names.

         LOCCTRNOTDATA,  Location counter cannot be set in an EXE,NOMIX
            PSECT.

            Error: The location counter cannot be modified in a psect
            with the EXE and NOMIX attributes.

            User Action: If you need to modify the location counter,
            specify the MIX psect attribute. Consult the documentation
            for a complete description of the MIX psect attribute.

         MACCASEMATCH,  Library macro name is spelled using different
            alphabetic case than in .MCALL directive or macro
            invocation.

            Error: There is an alphabetic case difference between that
            specified in the macro library and the alphabetic case of
            the macro name.

            User Action: Check the case of the macro name in your
            source code and the case of the macro in the specified macro
            library.

         MACEXPNEST,  Macro expansion exceeds maximum nesting depth
            (macro recursion not detected).

            Error: The macro is not recursive but exceeds the maximum
            allowable expansion depth.

            User Action: Check your source code for possible
            restructuring.

         MACPARAMGENDEF,  You may specify a generated label default
            value, or a default string value, but not both.

            Error: A default string value AND a generated label default
            value have both been specified, when only one may be
            specified.

            User Action: Examine your source code.

        E-18

 



                                                           Error Messages



         MACPARAMSYNTAX,  Illegal macro parameter syntax: Found XXXXX
            when expecting one of XXXXX.

            Error: Macro parameter syntax is invalid.

            User Action: Try replacing the unexpected argument with one
            of those items cited as expected.

         MACRECURSE,  Recursive macro exceeds maximum macro expansion
            nesting depth.

            Error: The macro is recursive and exceeds the maximum
            expansion nesting depth.

            User Action: Check your source code for a missing basis step
            in the recursive macro.

         MACZERO,  Cannot evaluate expression. A zero expression value is
            assumed.

            Informational: The assembler cannot evaluate this expression
            due to errors encountered. Therefore, a zero value is
            assumed.

            User Action: Check the expression for forward or external
            references.

         MAXIF,  Maximum nesting of .IF directives exceeded.

            Error: The maximum depth nesting of .IF directives has been
            exceeded.

            User Action: Check your source code for possible
            restructuring.

         MISSENDC,  Missing .ENDC directive(s).

            Warning: The assembler did not find a terminating .ENDC
            conditional directive.

            User Action: Check your source code.

         MISSINGENDM,  Missing .ENDM directive.

            Error: No terinating .ENDM directive was found to match a
            .MACRO directive.

            User Action: Check your source code.

         MISSINGENDR,  Missing .ENDR directive.

            Error: The assembler expected to encounter a .ENDR directive
            to terminate a .IRP or .REPEAT block.

            User Action: Check your source code.

                                                                     E-19

 



        Error Messages



         MISSQUOTE,  Missing closing double-quote character in string
            literal.

            Error: The closing double-quote is missing from the string
            literal.

            User Action: Check your source code and insert a closing
            double-quote for a string literal.

         MODCODLOCCTR,  Restoring the location counter in the current
            context causes an illegal modification of the location
            counter for an EXE, NOMIX psect.

            Error: The location counter cannot be modified in a psect
            with the EXE and NOMIX attributes.

            User Action: If you need to modify the location counter,
            specify the MIX psect attribute. Consult the documentation
            for a complete description of the MIX psect attribute.

         NOBEGEX,  Unmatched .END_EXACT directive encountered.

            Error: A .END_EXACT directive was encountered prior to a
            .BEGIN_EXACT directive.

            User Action: Check your source code.

         NOCA,  No code address specified as argument 2 with
            .PROCEDURE_DESCRIPTOR.

            Error: No code address was specified as the second argument
            to the .PROCEDURE_DESCRIPTOR directive.

            User Action: The code address must be a non-temporary label
            defined in a psect with the EXE or NOMIX attribute. Check
            your source code.

         NOQUAL,  Instruction qualifiers are not valid with this opcode.

            Error: No instruction qualifiers may be specified with this
            opcode.

            User Action: Consult the documentation for a complete list
            of opcodes and valid instruction qualifiers.

         NOTAQUAL,  An item specified in the qualifier list is not a
            valid qualifier.

            Error: The instruction qualifier(s) specified with the
            opcode is/are invalid.

            User Action: Consult the documentation for a complete list
            of opcodes and valid instruction qualifiers.

        E-20

 



                                                           Error Messages



         NOTENOUGHARGS,  Not enough arguments for instruction.

            Error: The instruction needs one or more arguments than
            specified.

            User Action: Check the argument numbers and required formats
            as specified in the documentation.

         NOTINMACRO,  This statement must only occur within a macro.

            Error: The statement specified is only allowed within a
            macro.

            User Action: Consult the documentation description of the
            statement specified.

         NOTINSEM,  Missing functionality in assembler.

            Error: Missing functionality in assembler.

            User Action: Please submit an SPR.

         NUMSYM,  XXXXX is already a numeric symbol name; it cannot also
            be a lexical string symbol.

            Error: You cannot have a lexical and numeric symbol by this
            same name.

            User Action: Check your source code and remove either the
            lexical or numeric symbol definition.

         OPTIGN,  VAX MACRO-32 option(s) being ignored.

            Informational: A VAX MACRO-32 option has been detected and
            is ignored.

            User Action: Remove the VAX MACRO options from your Alpha
            MACRO-64 program.

         OVERLAP,  Overlapping initializers detected at offset NN.
            Multiple initial values are specified for the same PSECT
            offset.

            Error: You are trying to statically initialize the same
            location more than once.

            User Action: Check your source code.

                                                                     E-21

 



        Error Messages



         PSECTALIGNCON,  PSECT alignment conflicts with earlier
            declaration.

            Error: A previously specified psect alignment attribute
            conflicts with the flagged psect attribute.

            User Action: Check all declarations of the psect. Consult
            the documentation description of the .PSECT directive and
            psect attributes.

         PSECTATTRCON,  PSECT attribute conflicts with earlier
            declaration.

            Error: A previously specified psect attribute conflicts with
            the flagged psect attribute.

            User Action: Check all declarations of the psect. Consult
            the documentation description of the .PSECT directive and
            psect attributes.

         REDUNDELSE,  You cannot specify more than one .ELSE directive
            within a single .IF block.

            Error: More than one .ELSE directive has been encountered
            within a single .IF block.

            User Action: Check your source code.

         RESTOREWOSAVE,  PSECT .RESTORE without .SAVE.

            Error: A .RESTORE_PSECT directive was issued without a
            previous corresponding .SAVE_PSECT directive.

            User Action: Check uses of .SAVE_PSECT and .RESTORE_PSECT in
            your source code.

         SAVESTACKOVER,  Internal SEM PSECT .SAVE stack overflow.

            Fatal: An internal error has occurred.

            User Action: Gather as much information as possible about
            the circumstances under which the error occurred, and submit
            an SPR.

         SRCREAD,  Error reading source file.

            Error: The assembler encountered an error in reading your
            source file.

            User Action: Check file specifications, protections, etc.

        E-22

 



                                                           Error Messages



         SYMBOLREDECL,  Illegal redefinition of symbol.

            Error: The symbol is already defined as a label or
            explicitly declared as externally defined with the .EXTERNAL
            directive.

            User Action: Check all uses of this item.

         TOOMANYARGS,  Too many arguments for instruction.

            Error: The instruction contains one or more arguments than
            necessary.

            User Action: Check the argument numbers and required formats
            as specified in the documentation.

         TOOMANYMACARG,  More arguments specified than defined for this
            macro.

            Error: More arguments have been specified on the macro call
            than were specified for its definition.

            User Action: Check the macro definition and point of call in
            your source code.

         TOOMANYMACPARAMS,  Too many macro parameters.

            Error: Too many macro parameters are specified.

            User Action: Check your source code.

         TRUNCDATA,  Data truncation warning.

            Warning: The specified data value is out of range for the
            specified directive. Data truncation will occur.

            User Action: Specify a smaller value.

         UNDCA,  Undefined code address specified with procedure
            descriptor.

            Error: The code address specified as the second argument to
            the .PROCEDURE_DESCRIPTOR directive is undefined.

            User Action: The code address must be a non-temporary label
            defined in a psect with the EXE or NOMIX attribute. Check
            your source code.

                                                                     E-23

 



        Error Messages



         UNDEFSYM,  Undefined symbol or label. Assuming .EXTERNAL
            definition.

            Warning: The referenced label or symbol does not have an
            explicit definition and an external definition is assumed.

            User Action: Use the .EXTERNAL directive to declare the
            symbol.

         UNEXPELSE,  Unexpected .ELSE directive.

            Error: An unexpected .ELSE directive was encountered.

            User Action: Check the use of the .ELSE directive in your
            source code to insure proper positioning with a .IF and
            .ENDC directive.

         UNEXPENDC,  Unexpected .ENDC directive.

            Error: The assembler never encountered a terminating .ENDC
            for a macro conditional directive, such as .IF.

            User Action: Check your source code.

         UNEXPENDM,  Unexpected .ENDM directive.

            Error: The assembler encountered an unexpected .ENDM
            directive.

            User Action: Check your source code for matching .MACRO
            /.ENDM pairs.

         UNEXPENDR,  Unexpected .ENDR directive.

            Error: An unexpected .ENDR directive was encountered.

            User Action: Check your source code for matching .REPEAT
            /.ENDR and .IRP/.ENDR directive pairs.

         UNEXPIFF,  Unexpected .IF_FALSE (.IFF) directive.

            Error: The assembler encountered an unexpected .IF_FALSE
            directive.

            User Action: Check your source code to insure that this
            directive occurs within a .IF block.

         UNEXPIFT,  Unexpected .IF_TRUE (.IFT) directive.

            Error: The assembler encountered an unexpected .IF_TRUE
            directive.

            User Action: Check your source code to insure that this
            directive occurs within a .IF block.

        E-24

 



                                                           Error Messages



         UNEXPIFTF,  Unexpected .IF_TRUE_FALSE (.IFTF) directive.

            Error: The assembler encountered an unexpected .IF_TRUE_
            FALSE directive.

            User Action: Check your source code to insure that this
            directive occurs within a .IF block.

         UNEXPMEXIT,  Unexpected .MEXIT directive.

            Error: The assembler encountered an unexpected .MEXIT
            directive.

            User Action: Check your source code.

         UNKDIR,  Unknown directive XXXXX found.

            Error: An internal error has occured.

            User Action: Gather as much information as possible about
            the circumstances under which the error occurred and please
            submit an SPR.

         UNKENDISOPTION,  Unknown .ENABLE/.DISABLE option specified.

            Error: The option specified for .ENABLE/.DISABLE is
            incorrect.

            User Action: Check the option specified with the .ENABLE
            /.DISABLE directive.

         UNKNOWNATTR,  Unknown PSECT attribute.

            Error: The specified psect attribute is not recognized by
            the assembler.

            User Action: Consult the documentation description of the
            .PSECT directive.

         UNTERMEX,  N Unterminated .BEGIN_EXACT directive(s) detected in
            psect XXXXX.

            Error: Unmatched .BEGIN_EXACT directive(s) occur for the
            indicated psect.

            User Action: Check your source code.

         VAXDIR,  VAX MACRO-32 directive(s) or option(s) being ignored.
            Continuing processing with next line.

            Informational: A VAX MACRO-32 directive or option has been
            specified and is ignored.

            User Action: Remove the VAX MACRO directives from your Alpha
            MACRO-64 program.

                                                                     E-25

 



        Error Messages



         VMACELSE,  You cannot specify .ELSE in the same .IF block with
            either .IF_FALSE (.IFF), .IF_TRUE (.IFT), or .IF_TRUE_FALSE
            (.IFTF).

            Error: A .ELSE directive was encountered within the same .IF
            block as a .IF_FALSE, .IF_TRUE, or .IF_FALSE directive.

            User Action: Check your source code and remove either the
            .ELSE directive or the .IF_x directive.

         WRONGMACID,  Macro name in .ENDM does not match corresponding
            .MACRO.

            Error: The macro name specified as the optional argument to
            the .ENDM directive does not match the name specified with
            the corresponding .MACRO directive.

            User Action: Check your souce code for matching .MACRO/.ENDM
            directive pairs.

         WRONGPL,  The code address specified in the .PROCEDURE_
            DESCRIPTOR directive must occur BEFORE its definition as
            a local or global label.

            Error: The code address specified as the second argument to
            the .PROCEDURE_DESCRIPTOR directive must occur BEFORE its
            definition as a non-temporary label defined in a psect with
            the EXE or NOMIX attribute.

            User Action: Check your source code.















        E-26

 














     _________________________________________________________________

                                                                 Index



     A                                 ASCII string storage directive
     _______________________________      (cont'd)
     Absolute expression,  2-23          string descriptor (.ASCID),
     Accessing memory,  B-2                 5-14
     Address                             zero-terminated (.ASCIZ),
       base register (.BASE), 5-18          5-17
       local code storage directive    .ASCIZ directive,  5-17
         (.LOCAL_CODE_ADDRESS),        Assembly termination directive
         5-83                             (.END),  5-44
       storage directive (.CODE_       Assignment statement,  1-2,
         ADDRESS),  5-28                  2-30
     .ADDRESS directive,  5-9, B-16    Automatic alignment directives
     Addressing                          See Table B-2
       controlling alignment, B-16
       to linkage section, B-13
     Address storage directive         B______________________________

        (.ADDRESS), 5-9                .BASE directive,  5-18, 6-9
     .ALIGN directive,  5-10           Base register,  B-2
     AND operator,  2-29                 defining address,  B-14
     Argument                          Base register directive
       actual, 4-2                        (.BASE),  5-18
       determining length, 5-99        $BEGIN_EPILOGUE macro,  6-6,
       formal, 4-2                        6-13
       in a macro, 4-2                 .BEGIN_EXACT directive,  5-22
       number of, 5-97                 Binary operator,  2-28
     Arithmetic shift operator,        .BLKA directive,  B-17
        2-29                           .BLKD directive,  B-17
     .ASCIC directive,  5-13           .BLKF directive,  B-17
     .ASCID directive,  5-14, B-17     .BLKG directive,  B-17
     .ASCII directive,  5-16           .BLKL directive,  B-17
     ASCII string storage directive    .BLKO directive,  B-17
       counted (.ASCIC), 5-13
       string (.ASCII), 5-16

                                                               Index-1

 







        .BLKQ directive, B-17             $DATA_SECTION macro,  6-23
        .BLKS directive, B-17             Date and time lexical
        .BLKT directive, B-17               %TIME, 3-21
        .BLKW directive, B-17             Delimiter
        .BLKx directive, 5-24               string argument, 4-5
        Block storage allocation          Direct assignment statement,
          directive (.BLKx),  5-24           1-2, 2-30
        .BYTE directive, 5-27             Directives,  1-2, 5-1
        Byte storage directive (.BYTE)      as operators, 2-4
          ,  5-27                           for auto alignment, B-16
                                            general assembler, 1-2, 5-1,
        C______________________________       5-4
        $CALL macro, 6-8, 6-9, 6-10,        macro, 1-2, 5-1, 5-7
          6-15                            Disable assembler functions
         instruction sequence,  6-11         directive (.DISABLE), 5-31
        Character set                     .DOUBLE directive,  5-29
         in source statement,  2-5        Double-precision IEEE
        Character string                     directive (.T_FLOATING),
         determining length,  5-99           5-132
        $CODE$ symbol, 6-52, 6-53         $DP symbol,  6-4, 6-52
        .CODE_ADDRESS directive, 5-28,    .DSABL, DISABLE directive,
          B-17                               5-31
        $CODE_SECTION macro, 6-22         $DS symbol,  6-4, 6-52
        Colon (:)                         .D_FLOATING directive,  5-29,
         in label field,  2-3                B-17

        Conditional assembly block
          directive                       E______________________________

         .ELSE,  5-32                     %EDIT lexical,  3-12
         .ENDC,  5-46                     Element extraction lexical
         .IF,  5-57                         %ELEMENT, 3-14
        Created temporary label, 4-10     %ELEMENT lexical,  3-14
         range,  2-16                     .ELSE directive,  5-32
        $CS symbol, 6-4, 6-51             .ENABL, ENABLE directive,  5-34
        Current location counter, 2-31    Enable assembler functions,

                                             5-34
        D______________________________   .ENDC directive,  5-46

        $DATA$ symbol, 6-52, 6-53         End conditional assembly
        Data Storage                         directive (.END), 5-46
         ALIGN_DATA,  5-34                .END directive,  5-44
        Data structures, B-6              End macro definition directive
         linkage pair,  B-7                  (.ENDM), 5-47
         procedure descriptor,  B-6       .ENDM directive,  5-47
         signature block,  B-7

        Index-2

 







        .ENDR directive, 5-48             Floating-point constants (.D_
        $END_EPILOGUE macro, 6-6, 6-24       FLOATING), 5-29
        .END_EXACT directive, 5-49        Floating-point number
        $END_PROLOGUE macro, 6-5, 6-26      arithmetic, 5-125, 5-132
        $END_ROUTINE macro, 6-27            format, 2-10
        Epilogue sequence, 6-41, B-5,       .F_FLOATING, 5-53
          B-10, B-11                        .G_FLOATING, 5-55
         beginning,  6-13                   in source statement, 2-9
        .ERROR directive, 5-50              storage, 5-29
        Error messages, E-1                 storing, 5-53, 5-55
        .EVEN directive, 5-51               .S_FLOATING, 5-125
        Exact Instruction block             .T_FLOATING, 5-132
         beginning,  5-22                 Floating-point storage
         ending,  5-49                       directive
        Exact Instruction block             .D_FLOATING, 5-29
          directive (.BEGIN_EXACT),         .F_FLOATING, 5-53
          5-22                              .G_FLOATING, 5-55
        Exclusive OR operator, 2-29       Formal argument,  4-2
        Expression, 2-22                  .F_FLOATING, FLOAT directive,
         absolute,  2-23                     5-53
         evaluation of,  2-22             .F_FLOATING directive,  B-17
         external,  2-23
         global,  2-22                    G______________________________
         relocatable,  2-22, 2-32         Global expression,  2-22
        .EXTERNAL, EXTRN directive,       Global label,  2-3
          5-52                            Global symbol,  2-15, 5-136
        External expression, 2-23           defining, 5-34
        External symbol, 5-136            .G_FLOATING directive,  5-55,
         attribute directive                 B-17
            (.EXTERNAL),  5-52
         defining,  5-34, 5-52            I
        %EXTRACT lexical, 3-15            _______________________________
                                          .IDENT directive,  5-56
        F______________________________   Identification directive
        Fields                               (.IDENT), 5-56
         comment,  2-2, 2-5               .IF directive,  5-57
         label,  2-2, 2-3                 .IFx directive,  5-63
         operand,  2-2, 2-4               .IF_FALSE directive,  5-63
         operator,  2-2, 2-4              .IF_TRUE directive,  5-63
        Floating-point arithmetic         .IF_TRUE_FALSE directive,  5-63
          directive                       .IIF directive,  5-67

         .S_FLOATING,  5-125
         .T_FLOATING,  5-132

                                                                  Index-3

 







        Immediate conditional assembly    Lexical operators,  3-1
          block directive (.IIF),           list, 3-11
          5-67                              processing, 3-1
        .INCLUDE directive, 5-69            syntax rules, 3-1
        Inclusive OR operator, 2-29       Lexical string symbol
        Indefinite repeat argument          with quoted string literal,
          directive (.IRP),  5-72             3-4
        Indefinite repeat character       Lexical string symbols,  3-4
          directive (.IRPC),  5-75        .LIBRARY directive,  5-78
        Instruction directive, 5-70       $LINK$ symbol,  6-52, 6-53
        .INSTRUCTION directive, 5-70,     .LINKAGE_PAIR directive,  5-80,
          B-17                               B-17
        Instructions                      $LINKAGE_PAIR macro,  6-28
         as operators,  2-4               $LINKAGE_SECTION macro,  6-30
        Integer                           Linking directive (.LINKAGE_
         in source statement,  2-9           PAIR), 5-80
        %INTEGER lexical, 3-16            .LIST directive,  5-82
        Invoking assembler, 1-3           Listing control directive
        .IRPC directive, 5-75               .IDENT, 5-56
        .IRP directive, 5-72                .LIST, 5-82
                                            .NLIST, 5-101
        K______________________________     .NOSHOW, 5-102
        Keyword argument, 4-3             Listing directive (.SHOW,
                                             NOSHOW), 5-126
        L                                 Listing table of contents,
        _______________________________      5-131
        Label                             Local address storage
         created temporary,  4-10            directive (.LOCAL_CODE_
         global,  2-3                        ADDRESS), 5-83
         local,  2-3                      Local label,  2-3
         temporary,  2-3                    saving, 5-124
         user-defined temporary,          Local label block
            2-15, 4-10                      ending, 5-34
        Labeling directive                  starting, 5-34
         .LOCAL_DESCRIPTOR,  5-85         Local linking directive
         .PROCEDURE_DESCRIPTOR,  5-109       (.LOCAL_LINKAGE_PAIR), 5-84
        Length Determining lexical        Local symbol,  2-14
         %LENGTH,  3-17                   .LOCAL_CODE_ADDRESS directive,
        %LENGTH lexical, 3-17                5-83, B-17
        %%-Lexical escape operator,       .LOCAL_LINKAGE_PAIR directive,
          3-5                                5-84, B-17
        Lexical escape operator (%%),     .LOCAL_PROCEDURE_DESCRIPTOR
          3-5                                directive, 5-85, B-17


        Index-4

 







        %LOCATE lexical, 3-18             Macro arguments (cont'd)
        Location control directive          SCRATCH_REGS, 6-11, 6-18
         .ALIGN,  5-10                      SET_ARG_INFO, 6-17
         .BLKx,  5-24                       SIGNATURE_BLOCK, 6-19
        Location counter                    SIZE, 6-4, 6-7
         current,  2-31                     STACK_RETURN_VALUE, 6-17
        Location counter alignment          STANDARD_PROLOGUE, 6-5
          directive (.ODD),  5-105          string, 4-5
        Location counter control            TIE, 6-18
          directive (.EVEN),  5-51          USES_VAX_ARGLIST, 6-19
        Logical AND operator              Macro call directive
         See AND operator                    (.LIBRARY), 5-92
        Logical exclusive OR operator     Macro calls,  4-1
         See Exclusive OR operator          as operators, 2-4
                                            nested, 5-89
        Logical inclusive OR operator       number of arguments, 5-97

         See Inclusive OR operator        MACRO command qualifiers,  1-3
        .LONG directive, 5-87, B-16       Macro definition,  4-1
        Longword storage directive          default value, 4-3
          (.LONG),  5-87                    ending, 5-47
        $LS symbol, 6-4, 6-10, 6-52         labeling in, 4-10
                                          Macro definition directive
        M______________________________      (.MACRO), 5-88
        MACRO-64 Assembler for OpenVMS    Macro deletion directive
          AXP Systems                        (.MDELETE), 5-93
         introduction,  1-1               .MACRO directive,  5-88
        Macro arguments, 4-2              Macro exit directive (.MEXIT),
         actual,  4-2                        5-94
         ARGS,  6-8, 6-16                 Macro expansion,  4-1
         ARGS parameters,  6-16             printing, 4-1
         concatenated,  4-9                 terminating, 5-94
         delimited,  4-5, 4-8             Macro include directive
         formal,  4-2                        (.INCLUDE), 5-69
         FUNC_RETURN,  6-19               Macro library directive
         keyword,  4-3                       (.LIBRARY), 5-78
         KIND,  6-5, 6-6                  Macro name,  2-13
         LOCAL,  6-10, 6-16               Macros,  4-1
         LS,  6-16                          calling routines, 6-8
         NAMES,  6-12                       $CALL instruction sequence,
         NONSTANDARD,  6-20                   6-8
         positional,  4-3                   defining a routine, 6-6
         Rls,  6-9, 6-15                    ending routines, 6-2
         RSA_END,  6-4                      for calling routines, 6-2
         RSA_OFFSET,  6-4                   in epilogue sections, 6-6

         SAVED_REGS,  6-6

                                                                  Index-5

 







        Macros (cont'd)                   Number of arguments directive
         in prologue sections,  6-5,         (.NARG), 5-97
            6-6                           Number of characters directive
         in source code,  6-9                (.NCHR), 5-99
         MACRO-64 supplied,  6-1          Numeric complement operator,
         MACRO-64 supplied library,          2-27
            6-1                           Numeric symbol
         making multiple calls,  6-11       with lexical string symbol,
         nested,  4-6, 5-89                   3-4
         passing numeric value to,        Numeric symbols,  3-4

            4-9
         recursive,  5-89                 O______________________________
         redefining,  5-89                Object module
         supplied,  6-12 to 6-53            identifying, 5-56
         switching psects,  6-3, 6-6        naming, 5-133
         syntax rules,  6-12                title, 5-133
         within routines,  6-2            Obtaining information lexical
         with same name as opcode,          %TYPE, 3-22
            5-89                          .OCTA directive,  5-103, B-16
        .MCALL directive, 5-92            Octaword storage directive
        .MDELETE directive, 5-93             (.OCTA), 5-103
        Memory                            .ODD directive,  5-105
         accessing,  B-2                  One's complement
        Message display directive           of expression, 2-27
         .ERROR,  5-50                    Opcode
         .PRINT,  5-108                     redefining, 5-89
        Messages                            with the same name as a macro
         errors,  E-1                         ,  5-89
        Message warning display           $OPDEF macro,  6-31
          directive (.WARN),  5-135       Operand,  2-4
        .MEXIT directive, 5-94            Operator,  2-4

                                            AND, 2-29
        N______________________________     arithmetic shift, 2-29

        .NARG directive, 5-97               binary, 2-28
        .NCHR directive, 5-99               complement, 2-27
        .NLIST directive, 5-101             exclusive OR, 2-29
        .NOSHOW directive, 5-102            inclusive OR, 2-29
        Number                              numeric complement, 2-27
         See also Integer, Floating-        radix control, 2-26
            point number, and Packed        unary, 2-25
            decimal string                Operator field,  2-4

         in source statement,  2-8

        Index-6

 








        P______________________________   Q______________________________

        .PACKED directive, 5-106          .QUAD directive,  5-118, B-16
        .PACKED macro, 6-37               Quadword storage directive
        Packed storage directive             (.QUAD), 5-118
          (.PACKED),  5-106               Quoted string literal
        .PAGE directive, 5-107              with lexical string symbol,
        Page ejection directive               3-4
          (.PAGE),  5-107
        Period (.)                        R______________________________
         current location counter,        Radix control operator,  2-26
            2-31                          Range extraction lexical
        Permanent symbol, 2-11, 2-13        %EXTRACT, 3-15
        Positional argument, 4-3          Register name,  2-11, 2-14
        .PRINT directive, 5-108           Relocatable expression,  2-22
        .PROCEDURE_DESCRIPTOR             Repeat block
          directive,  5-109, B-17           argument substitution, 5-72
        $PROCEDURE_DESCRIPTOR macro,        character substitution, 5-75
          6-40                              terminating repetition, 5-94
        Program section                   Repeat block directive
         attributes,  5-111                  (.REPEAT), 5-119
         code,  6-2                       .REPEAT directive,  5-119
         data,  6-2                       %REPEAT lexical,  3-19
         defining,  5-111                 Repeat range end directive
         directive                           (.ENDR), 5-48
            .PSECT,  5-111                .REPT directive,  5-119
            .RESTORE,  5-122              .RESTORE_PSECT, .RESTORE
            .SAVE,  5-124                    directive, 5-122
         linkage,  6-2                    $RETURN macro,  6-6, 6-41
         name,  5-116                     $ROUTINE macro,  6-5, 6-42
         restoring context of,  5-122       qualifiers, 6-42 to 6-51
         saving context of,  5-124        Routines,  B-9
         saving local label,  5-124         See Table B-1
        Prologues                           bound frame, B-10
         entry and exit,  B-11              defining type by macro, 6-5
        Prologue sequence, B-5, B-10,       null frame, B-10
          B-11                              performance, B-11
         ending,  6-26                      register frame, B-10
        .PSECT directive, 5-111             stack frame, B-10

                                          $RSA_END symbol,  6-4, 6-52
                                          $RSA_OFFSET symbol,  6-4, 6-5,
                                             6-52

                                                                  Index-7

 







                                          Strings (cont'd)
        S______________________________     extracting elements

        .SAVE_PSECT, .SAVE directive,         (%ELEMENT),  3-14
          5-124                             extracting range (%EXTRACT),
        Shift operator, 2-29                  3-15
        .SHOW, .NOSHOW directive,           locating lexical (%LOCATE),
          5-126                               3-18
        Signed byte data directive          obtaining information lexical
          (.SIGNED_BYTE),  5-129              (%TYPE),  3-22
        Signed word storage directive       obtaining value lexical
          (.SIGNED_WORD),  5-130              (%STRING),  3-20
        .SIGNED_BYTE directive, 5-129       repeating lexical (%REPEAT),
        .SIGNED_WORD directive, 5-130,        3-19
          B-16                            Subconditional assembly block
        Single-precision IEEE                directive
          directive                         .IF_FALSE, 5-63
         .S_FLOATING,  5-125                .IF_TRUE, 5-63
        $SIZE symbol, 6-4, 6-5, 6-52        .IF_TRUE_FALSE, 5-63
        $STACK_ARG_SIZE symbol, 6-4       .SUBTITLE, SBTTL directive,
        Statements                           5-131
         character set,  2-5              Subtitle listing control
         comment,  2-5                       directive (.SUBTITLE),
         continuation of,  2-2               5-131
         field,  2-1                      Symbol,  2-11
         format,  2-1                       defined by $CALL, 6-4
         label,  2-3                        defined by $ROUTINE, 6-4
         operand,  2-4                      determining value of, 2-13
         operator,  2-4                     external, 5-52, 5-136
         types,  1-1                        global, 2-15, 5-136
        String argument, 4-5                in operand field, 2-14
        String editing lexical              in operator field, 2-13
         %EDIT,  3-12                       local, 2-14
        %STRING lexical, 3-20               macro name, 2-13
        String locating lexical             permanent, 2-11, 2-13
         %LOCATE,  3-18                     register name, 2-11, 2-14
        String repeating lexical            undefined, 5-34
         %REPEAT,  3-19                     user-defined, 2-12, 2-14
        Strings                           Symbol attribute directive
         date/time lexical (%LEX),           (.WEAK), 5-136
            3-21                          .S_FLOATING directive,  5-125,
         determining length (%LENGTH),       B-17
            3-17
         editing lexical (%EDIT),
            3-12

        Index-8

 







                                          User-defined temporary label,
        T______________________________      2-15
        Tab stops                           range, 2-16

         in source statement,  2-2
        Temporary label, 2-3              V______________________________

         user-defined,  2-15              Value conversion lexical
        Term in MACRO statement, 2-22       %INTEGER, 3-16
        %TIME lexical, 3-21               Value obtaining lexical
        .TITLE directive, 5-133             %STRING, 3-20
        Title listing control             Values
          directive (.TITLE),  5-133        converting (%INTEGER), 3-16
        %TYPE lexical, 3-22
        .T_FLOATING directive, 5-132,     W______________________________
          B-17                            .WARN directive,  5-135

        U                                 .WEAK directive,  5-136
        _______________________________   .WORD directive,  5-138, B-16
        Unary operator, 2-25              Word storage directive (.WORD)
        User-defined symbol, 2-12,           , 5-138
          2-14























                                                                  Index-9
