	OPTIONS		/EXTEND_SOURCE
	SUBROUTINE	GETJPI_BASIC
C+
C
C FUNCTIONAL DESCRIPTION:
C
C       GETJPI_BASIC.FOR - To Retrive Process(es) informations, including
C	pid, process name, state, current priority, IO(buffer IO + direct IO)
C	CPU consume time, page faults, pages in memory, root job type.
C	process(es) context is supplied by calling program via common blocks.
C	
C FORMAL PARAMETERS:
C
C     {parameters}
C
C COMMON BLOCKS:
C
C     NODE_INFO
C     SORT_ORDER
C     PAGE_INFO
C
C AUTHOR:
C	
C     James Shen (jshen1@ford.com)
C
C CREATION DATE: Sept, 1995
C
C MODIFIED BY:
C
C        : VERSION
C 01    -  J.Shen  10/06/1995	Added JPI$_GETJPI_CONTROL_FLAGS item code.
C				Incresed process/node limit 512->2048. 
C
C-
	IMPLICIT	NONE

CDEC$ OPTIONS /ALIGN=COMMON=NATURAL

	COMMON	//	LUN, CONTEXT
	COMMON	/NODE_INFO/  NODENAME, NODENAME_LEN
	COMMON  /SORT_ORDER/ ORDER
	COMMON  /PAGE_INFO/  PAGE_PRESENT

CDEC$ END OPTIONS

	INCLUDE		'($DVIDEF)'
	INCLUDE		'($DCDEF)'
	INCLUDE		'($IODEF)'
	INCLUDE		'($TTDEF)'
	INCLUDE		'($JPIDEF)'
	INCLUDE		'($SSDEF)'
	INCLUDE		'($SYIDEF)'          
	INCLUDE		'($RMSDEF)'
	INCLUDE		'($LIBDEF)'
	INCLUDE		'($SYSSRVNAM)'
	INCLUDE		'SHSINC.FOR'

CDEC$	OPTIONS/ALIGN=(STRUCTURE=NATURAL)
	STRUCTURE  /PROCESS/
	  INTEGER*4	PID
	  CHARACTER*15	PRCNAM
	  BYTE		%FILL
	  INTEGER*4	PNAME_LEN
	  INTEGER*4	STATE,
	2		CURPRIORITY,
	2		BUFIOCNT,
	2		DIOCNT,
	2		CPUTIME,
	2		PAGEFAULT,
	2		PPAGES,
	2		GPAGES,
	2		PRCMODE
	END STRUCTURE
CDEC$	END OPTIONS

        RECORD /DVIITMLIST/     DVILIST(2)
        RECORD /CHARACTERISTICS/TTCHAR
	RECORD /JPIITMLIST/	JPILIST(13)
	RECORD /SYIITMLIST/	SYILIST(4)
        RECORD /IOSB_STAT/      TTIOSB
	RECORD /IOSB/		JPISTAT,
	2			SYISTAT
	RECORD /PROCESS/	PROCESS(2048)		!Maxium 2048 Proc/node

	EXTERNAL	SCH$C_COLPG,
	2        	SCH$C_MWAIT,
	2		SCH$C_CEF,
	2		SCH$C_PFW,
	2		SCH$C_LEF,
	2		SCH$C_LEFO,
	2		SCH$C_HIB,
	2		SCH$C_HIBO,
	2		SCH$C_SUSP,
	2		SCH$C_SUSPO,
	2		SCH$C_FPG,
	2		SCH$C_COM,
	2		SCH$C_COMO,
	2		SCH$C_CUR
C+
C DECLARE FUNCTIONS
C-
	INTEGER*4	LIB$SUBX
	INTEGER*4	LIB$GET_INPUT
	INTEGER*4	SHS_PROC_SORTBY_KEY_BASIC
C+
C LOCAL VARIALBES
C- 
	INTEGER*4	ORDER
	LOGICAL*4	PAGE_PRESENT
        INTEGER*4       DVI_CLASS, DVI_CLASS_LEN
	INTEGER*2	OUTPUT_CHAN
	INTEGER*4	LUN
	INTEGER*4	CONTEXT
	INTEGER*4	STATUS
	INTEGER*4	JPIFLAGS
	BYTE		PAGE_LENGTH
	CHARACTER*5	STATE_ASCII
	INTEGER*2	CPU_DAY, CPU_HOUR, CPU_MIN, CPU_SEC, CPU_MIL_SEC
	DATA		CPU_DAY, CPU_HOUR, CPU_MIN, CPU_SEC, CPU_MIL_SEC  /5*0/
	CHARACTER*1	PRCMODE_INDICATOR
        CHARACTER*(*)   ESC_BRACKET_NARROW
        PARAMETER       ( ESC_BRACKET_NARROW = CHAR(27)//'[?3l' )
        CHARACTER*(*)   HINT_LINE
        PARAMETER       ( HINT_LINE = '                            '//
	2		CHAR(27)//'[7m'//'Press RETURN to continue'//
	2		CHAR(27)//'[27m')

	CHARACTER*5	ARCHNAME
	BYTE		ARCH_LEN
	INTEGER*2	HWMODEL
	CHARACTER*6	NODENAME
	INTEGER*2	NODENAME_LEN
	CHARACTER*4	VERSION
	INTEGER*2	VERSION_LEN
	INTEGER*4	BOOTIME(2), UPTIME(2), CURTIME(2)
	CHARACTER*13    UPTIME_ASCII
	CHARACTER*23	CURTIME_ASCII
	CHARACTER*1	RESPONSE
	BYTE		RESPONSE_LENGTH
	INTEGER*4	ZERO(2)
	DATA		ZERO /0,0/

	LOGICAL*4	DONE /.FALSE./
	LOGICAL*4	DCTERM /.TRUE./
	LOGICAL*4	CLR_SCREEN /.TRUE./
	INTEGER*4	Q, P /0/
	SAVE		P, CLR_SCREEN
	LOGICAL*4	POST_HEADER
	INTEGER*4	RESULT, PROC_INDEX, I
	INTEGER*4	LOWER, UPPER, STEP
	
        !
        ! Find out device class of SYS$OUTPUT
        !
        !********************************************
        ! Initialize DVI item list
        !********************************************
        DVILIST(1).BUFLEN    = 4
        DVILIST(1).CODE      = DVI$_DEVCLASS
        DVILIST(1).BUFADR    = %LOC(DVI_CLASS)
        DVILIST(1).RETLENADR = %LOC(DVI_CLASS_LEN)
        DVILIST(2).END_LIST  = 0

        STATUS = SYS$GETDVIW  ( ,,
	2                       'SYS$OUTPUT',
	2                       DVILIST,,,,,)
        IF ((.NOT. STATUS) .AND. ( STATUS .NE. SS$_IVDEVNAM)
	2       .AND. (STATUS .NE. SS$_NOSUCHDEV )) THEN
          CALL LIB$SIGNAL(%VAL(STATUS))
        END IF

        IF (( STATUS .NE. SS$_IVDEVNAM) .AND. (DVI_CLASS .EQ. DC$_TERM)) THEN
          DCTERM = .TRUE.
        ELSE
          DCTERM = .FALSE.
        END IF

	POST_HEADER = .TRUE.
	DONE = .FALSE.
	PROC_INDEX = 0
	DO WHILE (.NOT. DONE)	
	  PROC_INDEX = PROC_INDEX + 1
	  !*************************************
	  ! CONSTRUCT & INITIALIZE JPI ITEM LIST
	  !*************************************
	  JPILIST(1).BUFLEN	= 4
	  JPILIST(1).CODE	= IAND('FFFF'X, JPI$_GETJPI_CONTROL_FLAGS)
	  JPILIST(1).BUFADR	= %LOC(JPIFLAGS)
	  JPILIST(1).RETLENADR	= 0
	  JPILIST(2).BUFLEN	= 4
	  JPILIST(2).CODE	= JPI$_PID
	  JPILIST(2).BUFADR	= %LOC(PROCESS(PROC_INDEX).PID)
	  JPILIST(2).RETLENADR	= 0
	  JPILIST(3).BUFLEN	= LEN(PROCESS(PROC_INDEX).PRCNAM)
	  JPILIST(3).CODE	= JPI$_PRCNAM
	  JPILIST(3).BUFADR	= %LOC(PROCESS(PROC_INDEX).PRCNAM)
	  JPILIST(3).RETLENADR	= %LOC(PROCESS(PROC_INDEX).PNAME_LEN)
	  JPILIST(4).BUFLEN	= 4
	  JPILIST(4).CODE	= JPI$_STATE
	  JPILIST(4).BUFADR	= %LOC(PROCESS(PROC_INDEX).STATE)
	  JPILIST(4).RETLENADR	= 0
	  JPILIST(5).BUFLEN	= 4
	  JPILIST(5).CODE	= JPI$_PRI
	  JPILIST(5).BUFADR	= %LOC(PROCESS(PROC_INDEX).CURPRIORITY)
	  JPILIST(5).RETLENADR	= 0
	  JPILIST(6).BUFLEN	= 4
	  JPILIST(6).CODE	= JPI$_BUFIO
	  JPILIST(6).BUFADR	= %LOC(PROCESS(PROC_INDEX).BUFIOCNT)
	  JPILIST(6).RETLENADR	= 0
	  JPILIST(7).BUFLEN	= 4
	  JPILIST(7).CODE	= JPI$_CPUTIM
	  JPILIST(7).BUFADR	= %LOC(PROCESS(PROC_INDEX).CPUTIME)
	  JPILIST(7).RETLENADR	= 0
	  JPILIST(8).BUFLEN	= 4
	  JPILIST(8).CODE	= JPI$_PAGEFLTS
	  JPILIST(8).BUFADR	= %LOC(PROCESS(PROC_INDEX).PAGEFAULT)
	  JPILIST(8).RETLENADR	= 0
	  JPILIST(9).BUFLEN	= 4
	  JPILIST(9).CODE	= JPI$_PPGCNT
	  JPILIST(9).BUFADR	= %LOC(PROCESS(PROC_INDEX).PPAGES)
	  JPILIST(9).RETLENADR	= 0
	  JPILIST(10).BUFLEN	= 4
	  JPILIST(10).CODE	= JPI$_GPGCNT
	  JPILIST(10).BUFADR	= %LOC(PROCESS(PROC_INDEX).GPAGES)
	  JPILIST(10).RETLENADR	= 0
	  JPILIST(11).BUFLEN	= 4
	  JPILIST(11).CODE	= JPI$_MODE
	  JPILIST(11).BUFADR	= %LOC(PROCESS(PROC_INDEX).PRCMODE)
	  JPILIST(11).RETLENADR	= 0
	  JPILIST(12).BUFLEN	= 4
	  JPILIST(12).CODE	= JPI$_DIRIO
	  JPILIST(12).BUFADR	= %LOC(PROCESS(PROC_INDEX).DIOCNT)
	  JPILIST(12).RETLENADR	= 0
	  JPILIST(13).END_LIST	= 0

	  JPIFLAGS = JPI$M_IGNORE_TARGET_STATUS
  
	  STATUS = SYS$GETJPIW( ,	
	2			CONTEXT,,
	2			JPILIST,
	2			JPISTAT,,)

	  IF (STATUS) THEN
	    IF ( .NOT. JPISTAT.STATUS) THEN
	      IF ( JPISTAT.STATUS .EQ. SS$_NOMOREPROC) THEN
		DONE = .TRUE.
	      ELSE
	        CALL LIB$SIGNAL(%VAL( JPISTAT.STATUS))
	      END IF
	    ELSE
	      IF (POST_HEADER) THEN
		IF (DCTERM) THEN
                  !
                  ! Sense the Termainal Terminal Page Length
                  !
                  STATUS = SYS$ASSIGN('SYS$OUTPUT', OUTPUT_CHAN,,)
                  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

                  STATUS = SYS$QIOW( ,
	2                           %VAL(OUTPUT_CHAN),
	2                           %VAL(IO$_SENSEMODE),
	2                           TTIOSB,,,
	2                           TTCHAR,
	2                           %VAL(8),,,,)        ! TTCHAR buffer size
                  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
                  IF ( .NOT. TTIOSB.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

                  PAGE_LENGTH = TTCHAR.LENGTH(4)

                  IF ( PAGE_PRESENT .AND. CLR_SCREEN) CLR_SCREEN = .TRUE.
                  IF ( .NOT. PAGE_PRESENT) CLR_SCREEN = .FALSE.

                  IF ( CLR_SCREEN) THEN
                    WRITE( LUN, 1000) ESC_BRACKET_NARROW
1000                FORMAT ( 1X, A )
                    CLR_SCREEN = .FALSE.
                  END IF
                END IF

		!******************************
		! CONSTRUCT ITEM LIST FOR SYI	
		!******************************	  
	        SYILIST(1).BUFLEN    = 2
		SYILIST(1).CODE	     = SYI$_HW_MODEL
		SYILIST(1).BUFADR    = %LOC(HWMODEL)
		SYILIST(1).RETLENADR = 0	
	        SYILIST(2).BUFLEN    = 4
		SYILIST(2).CODE	     = SYI$_NODE_SWVERS
		SYILIST(2).BUFADR    = %LOC(VERSION)
		SYILIST(2).RETLENADR = %LOC(VERSION_LEN)	
	        SYILIST(3).BUFLEN    = 8
		SYILIST(3).CODE	     = SYI$_BOOTTIME
		SYILIST(3).BUFADR    = %LOC(BOOTIME)
		SYILIST(3).RETLENADR = 0
		SYILIST(4).END_LIST  = 0

		STATUS = SYS$GETSYIW(,,
	2			     NODENAME(1:NODENAME_LEN),
	2			     SYILIST,
	2			     SYISTAT,
	2			     ,)

		IF ( .NOT. STATUS) THEN
		  CALL LIB$SIGNAL(%VAL(STATUS))
		ELSE IF ( .NOT. SYISTAT.STATUS) THEN
		  CALL LIB$SIGNAL(%VAL(JPISTAT.STATUS))
		ELSE
		  STATUS = SYS$GETTIM(CURTIME)
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

		  STATUS = SYS$ASCTIM(, CURTIME_ASCII,
	2				CURTIME,
	2				0)
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

		  STATUS = LIB$SUBX( CURTIME,
	2			     BOOTIME,
	2			     UPTIME)	

		  ! If resultant time is is absolute format (positive value
		  ! means nost significant bit is not set), convert to 
		  ! delta time
		  IF ( .NOT. ( BTEST( UPTIME(2),31 ))) THEN
		    STATUS = LIB$SUBX(  ZERO,
	2				UPTIME,
	2				UPTIME)
		    IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	          END IF	

		  STATUS = SYS$ASCTIM(, UPTIME_ASCII,
	2				UPTIME,
	2				0)
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

		  IF (HWMODEL .EQ. 0  .OR. HWMODEL .GE. 1024) THEN
		    ARCHNAME = 'Alpha'
 		    ARCH_LEN = 5
	 	  ELSE
		    ARCHNAME = 'VAX'
	  	    ARCH_LEN = 3
		  END IF

                  IF (PAGE_PRESENT .AND.
	2               (P .EQ. PAGE_LENGTH-4 .OR. P .EQ. PAGE_LENGTH-3 .OR.
	2               P .EQ. PAGE_LENGTH-2 .OR. P .EQ. PAGE_LENGTH-1)) THEN
                    P = PAGE_LENGTH - P - 1
                    DO Q = 1, P                 ! Pad nice several lines
                        TYPE *,' '
                    END DO
                    P = 0
	    	     STATUS = LIB$GET_INPUT( RESPONSE, 
	2				     HINT_LINE, 
	2				     RESPONSE_LENGTH)
	    	    IF ( STATUS .EQ. SS$_NORMAL .OR. STATUS .EQ. LIB$_INPSTRTRU) THEN
	      	      IF (RESPONSE_LENGTH .NE. 0 ) CALL SYS$EXIT(%VAL(1))
            	    ELSE IF ( STATUS .EQ. RMS$_EOF .OR. STATUS .EQ. RMS$_TNS) THEN
	      	      CALL SYS$EXIT(%VAL(1))
		    ELSE 
		      CALL LIB$SIGNAL(%VAL(STATUS))
	    	    END IF
                  END IF

		  WRITE( LUN, 1005) ARCHNAME(1:ARCH_LEN), VERSION, 
	2		NODENAME(:NODENAME_LEN), CURTIME_ASCII, UPTIME_ASCII
1005		  FORMAT (1X , /, 1X, A,'/VMS ', A5, ' on node ', A, 1X, A,
	2		'   Uptime ', A)
		  WRITE( LUN, 1006)
1006		  FORMAT ( '   Pid    Process Name    State  Pri      I/O       CPU       Page flts Ph.Mem' )

		  P = P + 3

		END IF
	      	POST_HEADER = .FALSE.
	      END IF	
	    END IF
	  ELSE IF ( STATUS .EQ. SS$_NOMOREPROC) THEN
	    DONE = .TRUE.
	  END IF
	END DO

C+
C  CALL FUNCTION SHS_PROC_SORTBY_KEY ENTRY SHS_PROC_SORTBY_KEY_BASIC
C-
	IF ( PROC_INDEX .GT. 2) THEN
	  STATUS = SHS_PROC_SORTBY_KEY_BASIC ( 	PROCESS,
	2				 	PROC_INDEX-1)
	  IF ( .NOT. STATUS ) CALL LIB$STOP(%VAL(STATUS))
	END IF

	IF (ORDER .EQ. SHS_ASCENDING) THEN
	  LOWER = 1
	  UPPER = PROC_INDEX - 1	
	  STEP  = 1
	ELSE IF ( ORDER .EQ. SHS_DESCENDING) THEN
	  LOWER = PROC_INDEX - 1
	  UPPER = 1
	  STEP  = -1
	END IF

	DO 2000, I = LOWER, UPPER, STEP

          IF ((PAGE_PRESENT) .AND. (P .EQ. PAGE_LENGTH - 1)) THEN
            P = 0
	    STATUS = LIB$GET_INPUT(RESPONSE, 
	2			   HINT_LINE, 
	2			   RESPONSE_LENGTH)
	    IF ( STATUS .EQ. SS$_NORMAL .OR. STATUS .EQ. LIB$_INPSTRTRU) THEN
	      IF (RESPONSE_LENGTH .NE. 0 ) CALL SYS$EXIT(%VAL(1))
            ELSE IF ( STATUS .EQ. RMS$_EOF .OR. STATUS .EQ. RMS$_TNS) THEN
	      CALL SYS$EXIT(%VAL(1))
	    ELSE 
	      CALL LIB$SIGNAL(%VAL(STATUS))
	    END IF
          END IF        

	  CPU_MIL_SEC = JMOD(PROCESS(I).CPUTIME, 100)	     
	  RESULT = PROCESS(I).CPUTIME/100
	  IF ( RESULT .GE. 1) THEN
	    CPU_SEC = JMOD( RESULT, 60)
	    RESULT = RESULT/60
	    IF ( RESULT .GE. 1) THEN
	      CPU_MIN = JMOD( RESULT, 60)
	      RESULT = RESULT/60
	      IF ( RESULT .GE. 1) THEN
		CPU_HOUR = JMOD( RESULT, 24)
		CPU_DAY  = RESULT/24
 	      END IF
	    END IF
	  END IF

	  DO WHILE ( PROCESS(I).PNAME_LEN .LT. 15)
	    PROCESS(I).PNAME_LEN = PROCESS(I).PNAME_LEN +1
	    PROCESS(I).PRCNAM(PROCESS(I).PNAME_LEN:PROCESS(I).PNAME_LEN) = ' '	
          END DO		    

	  IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_COLPG))  THEN
	    STATE_ASCII = 'COLPG'
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_MWAIT)) THEN 
	    STATE_ASCII = 'MWAIT'
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_CEF))  THEN  	 
	    STATE_ASCII = 'CEF  '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_PFW))  THEN 
	    STATE_ASCII = 'PFW  '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_LEF))  THEN
	    STATE_ASCII = 'LEF  '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_LEFO)) THEN
	    STATE_ASCII = 'LEFO '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_HIB))  THEN
	    STATE_ASCII = 'HIB  '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_HIBO)) THEN
	    STATE_ASCII = 'HIBO '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_SUSP)) THEN
	    STATE_ASCII = 'SUSP '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_SUSPO)) THEN
	    STATE_ASCII = 'SUSPO'
          ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_FPG))  THEN
	    STATE_ASCII = 'FPG  '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_COM))  THEN
	    STATE_ASCII = 'COM  '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_COMO)) THEN
	    STATE_ASCII = 'COMO '
	  ELSE IF (PROCESS(I).STATE .EQ. %LOC(SCH$C_CUR))  THEN
	    STATE_ASCII = 'CUR  '
	  ELSE 
	    STATE_ASCII = '*****'	! Should never happened
	  END IF
		
	  IF (PROCESS(I).PRCMODE .EQ. JPI$K_OTHER   )  THEN
	    PRCMODE_INDICATOR = 'O'
	  ELSE IF (PROCESS(I).PRCMODE .EQ. JPI$K_NETWORK )  THEN    
	    PRCMODE_INDICATOR = 'N'
	  ELSE IF (PROCESS(I).PRCMODE .EQ. JPI$K_BATCH   ) THEN   
	    PRCMODE_INDICATOR = 'B'
	  ELSE IF (PROCESS(I).PRCMODE .EQ. JPI$K_INTERACTIVE) THEN 
	    PRCMODE_INDICATOR = 'I'
	  ELSE
	    PRCMODE_INDICATOR = '*' 	!Should never happened
	  END IF

	  WRITE( LUN, 1010 )  PROCESS(I).PID, PROCESS(I).PRCNAM , 
	2		STATE_ASCII, PROCESS(I).CURPRIORITY,
	2	 	PROCESS(I).BUFIOCNT+PROCESS(I).DIOCNT, 
	2		CPU_DAY, CPU_HOUR, CPU_MIN, CPU_SEC, CPU_MIL_SEC, 
	2		PROCESS(I).PAGEFAULT, 
	2		PROCESS(I).PPAGES+PROCESS(I).GPAGES, PRCMODE_INDICATOR
1010	  FORMAT (1X, Z8.8, 1X, A, 1X, A , 3X , I2, 1X , I8 , 
	2	I4, 1X , I2.2,':', I2.2,':', I2.2 ,'.', I2.2,
	2	1X, I9 , 1X , I6, 2X , A)

          IF (PAGE_PRESENT) P = P + 1
	  !*************************************
	  ! RESET THE CPU TIME FOR EACH PROCESS
	  !*************************************
	  CPU_DAY  	= 0 
	  CPU_HOUR 	= 0
	  CPU_MIN	= 0
	  CPU_SEC	= 0
	  CPU_MIL_SEC  	= 0
	  RESULT	= 0

2000	CONTINUE	! END DO 2000
	RETURN
	END
