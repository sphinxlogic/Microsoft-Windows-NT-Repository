C++
C
C FUNCTIONAL DESCRIPTION:
C
C       SHS_QSORT.FOR - To sort the processes by different array fields.
C			Uses QuickSort algorithim.
C	
C FORMAL PARAMETERS:
C
C     PROCESS - Adjustable Array of Records, each record is holding
C		a single process' information.
C     PROC_INDEX - Array dimension.
C     LOWBND  - Lower bound of subarray\ Make up a pair to be sorted.
C     UPBND   - Upper bound of subarray/ 	
C
C
C COMMON BLOCKS:
C 
C	-NONE -
C
C--
	OPTIONS		/CHECK/EXTEND_SOURCE/RECURSIVE
	SUBROUTINE	QSORT(PROCESS, PROC_INDEX, LOWBND, UPBND)
	IMPLICIT	INTEGER(A-Z)

	INTEGER*4	PROC_INDEX, LOWBND, UPBND	
CDEC$	OPTIONS/ALIGN=(STRUCTURE=NATURAL)
	STRUCTURE  /PROCESS_BASIC/
	  INTEGER*4	PID
	  CHARACTER*15	PRCNAM
	  BYTE		%FILL
	  INTEGER*4	PNAME_LEN
	  INTEGER*4	STATE,
	2		CURPRIORITY,
	2		BUFIOCNT,
	2		DIOCNT,
	2		CPUTIME,
	2		PAGEFAULT,
	2		PPAGES,
	2		GPAGES,
	2		PRCMODE
	END STRUCTURE

	STRUCTURE  /PROCESS_EXTEND/
          INTEGER*4     PID
          CHARACTER*15  PRCNAM
          BYTE          %FILL
          INTEGER*4     PNAME_LEN,
	2               STATE,
	2               CURPRIORITY,
	2               BUFIOCNT,
	2               DIOCNT,
	2               CPUTIME,
	2               PAGEFAULT,
	2               PPAGES,
	2		GPAGES,
	2               PRCMODE,
	2               WSSIZE,
	2               WSQUOTA,
	2               WSEXTENT
          CHARACTER*132 IMAGENAME
          INTEGER*4     IMAGE_LEN
          CHARACTER*8   TERMINAL
          INTEGER*4     TERMINAL_LEN
	END STRUCTURE
CDEC$	END OPTIONS

	RECORD /PROCESS_BASIC/  PROCESS(PROC_INDEX), TEMP
	RECORD /PROCESS_EXTEND/ PROCEXT(PROC_INDEX), TMP
C	STATIC		PROCESS, PROCEXT
	LOGICAL*4	EMPTY 

C***************************************************************************
C		Entries for sorting Process Name
C***************************************************************************
	ENTRY QSORT_BASIC_PROCNAME(PROCESS, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TEMP = PROCESS(LOWBND)
	    DO WHILE (I .NE. J)
	      IF ( PROCESS(J).PRCNAM(:PROCESS(J).PNAME_LEN) .GT.
	2	TEMP.PRCNAM(:TEMP.PNAME_LEN)) THEN
		J = J-1
	      ELSE
		PROCESS(I) = PROCESS(J)
		I = I + 1
		PROCESS(J) = PROCESS(I)
		PROCESS(I) = TEMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_BASIC_PROCNAME(PROCESS, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_BASIC_PROCNAME(PROCESS, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2	PROCESS(LOWBND).PRCNAM(:PROCESS(LOWBND).PNAME_LEN) .GT. 
	2	PROCESS(UPBND).PRCNAM(:PROCESS(UPBND).PNAME_LEN)) THEN
	    TEMP = PROCESS(LOWBND)
	    PROCESS(LOWBND) = PROCESS(UPBND)
	    PROCESS(UPBND) = TEMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN


	ENTRY QSORT_EXTEND_PROCNAME(PROCEXT, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TMP = PROCEXT(LOWBND)
	    DO WHILE (I .NE. J)
	      IF ( PROCEXT(J).PRCNAM(:PROCEXT(J).PNAME_LEN) .GT.
	2	TMP.PRCNAM(:TMP.PNAME_LEN)) THEN
		J = J-1
	      ELSE
		PROCEXT(I) = PROCEXT(J)
		I = I + 1
		PROCEXT(J) = PROCEXT(I)
		PROCEXT(I) = TMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_EXTEND_PROCNAME(PROCEXT, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_EXTEND_PROCNAME(PROCEXT, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2	PROCEXT(LOWBND).PRCNAM(:PROCEXT(LOWBND).PNAME_LEN) .GT. 
	2	PROCEXT(UPBND).PRCNAM(:PROCEXT(UPBND).PNAME_LEN)) THEN
	    TMP = PROCEXT(LOWBND)
	    PROCEXT(LOWBND) = PROCEXT(UPBND)
	    PROCEXT(UPBND) = TMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN

C***************************************************************************
C			Entries for sorting CPU time
C***************************************************************************
	ENTRY QSORT_BASIC_CPU(PROCESS, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TEMP = PROCESS(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCESS(J).CPUTIME .GT. TEMP.CPUTIME) THEN
		J = J-1
	      ELSE
		PROCESS(I) = PROCESS(J)
		I = I + 1
		PROCESS(J) = PROCESS(I)
		PROCESS(I) = TEMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_BASIC_CPU(PROCESS, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_BASIC_CPU(PROCESS, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2	PROCESS(LOWBND).CPUTIME .GT. PROCESS(UPBND).CPUTIME) THEN
	    TEMP = PROCESS(LOWBND)
	    PROCESS(LOWBND) = PROCESS(UPBND)
	    PROCESS(UPBND) = TEMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN


	ENTRY QSORT_EXTEND_CPU(PROCEXT, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TMP = PROCEXT(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCEXT(J).CPUTIME .GT. TMP.CPUTIME) THEN
		J = J-1
	      ELSE
		PROCEXT(I) = PROCEXT(J)
		I = I + 1
		PROCEXT(J) = PROCEXT(I)
		PROCEXT(I) = TMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_EXTEND_CPU(PROCEXT, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_EXTEND_CPU(PROCEXT, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2	PROCEXT(LOWBND).CPUTIME .GT. PROCEXT(UPBND).CPUTIME ) THEN
	    TMP = PROCEXT(LOWBND)
	    PROCEXT(LOWBND) = PROCEXT(UPBND)
	    PROCEXT(UPBND) = TMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN

C***************************************************************************
C		Entries for sorting IO(DIO+BUFIO)
C***************************************************************************
	ENTRY QSORT_BASIC_IO(PROCESS, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TEMP = PROCESS(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCESS(J).DIOCNT + PROCESS(J).BUFIOCNT .GT. 
	2	TEMP.DIOCNT + TEMP.BUFIOCNT) THEN
		J = J-1
	      ELSE
		PROCESS(I) = PROCESS(J)
		I = I + 1
		PROCESS(J) = PROCESS(I)
		PROCESS(I) = TEMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_BASIC_IO(PROCESS, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_BASIC_IO(PROCESS, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2	PROCESS(LOWBND).DIOCNT + PROCESS(LOWBND).BUFIOCNT  .GT. 
	2	PROCESS(UPBND).DIOCNT + PROCESS(UPBND).BUFIOCNT ) THEN
	    TEMP = PROCESS(LOWBND)
	    PROCESS(LOWBND) = PROCESS(UPBND)
	    PROCESS(UPBND) = TEMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN


	ENTRY QSORT_EXTEND_IO(PROCEXT, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TMP = PROCEXT(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCEXT(J).DIOCNT + PROCEXT(J).BUFIOCNT .GT. 
	2	TMP.DIOCNT + TMP.BUFIOCNT ) THEN
		J = J-1
	      ELSE
		PROCEXT(I) = PROCEXT(J)
		I = I + 1
		PROCEXT(J) = PROCEXT(I)
		PROCEXT(I) = TMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_EXTEND_IO(PROCEXT, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_EXTEND_IO(PROCEXT, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2	PROCEXT(LOWBND).DIOCNT + PROCEXT(LOWBND).BUFIOCNT .GT. 
	2	PROCEXT(UPBND).DIOCNT + PROCEXT(UPBND).BUFIOCNT ) THEN
	    TMP = PROCEXT(LOWBND)
	    PROCEXT(LOWBND) = PROCEXT(UPBND)
	    PROCEXT(UPBND) = TMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN

C***************************************************************************
C		Entries for sorting Current Priority
C***************************************************************************
	ENTRY QSORT_BASIC_CURPRIO(PROCESS, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TEMP = PROCESS(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCESS(J).CURPRIORITY .GT. TEMP.CURPRIORITY) THEN
		J = J-1
	      ELSE
		PROCESS(I) = PROCESS(J)
		I = I + 1
		PROCESS(J) = PROCESS(I)
		PROCESS(I) = TEMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_BASIC_CURPRIO(PROCESS, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_BASIC_CURPRIO(PROCESS, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2      PROCESS(LOWBND).CURPRIORITY .GT. PROCESS(UPBND).CURPRIORITY) THEN
	    TEMP = PROCESS(LOWBND)
	    PROCESS(LOWBND) = PROCESS(UPBND)
	    PROCESS(UPBND) = TEMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN


	ENTRY QSORT_EXTEND_CURPRIO(PROCEXT, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TMP = PROCEXT(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCEXT(J).CURPRIORITY .GT. TMP.CURPRIORITY) THEN
		J = J-1
	      ELSE
		PROCEXT(I) = PROCEXT(J)
		I = I + 1
		PROCEXT(J) = PROCEXT(I)
		PROCEXT(I) = TMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_EXTEND_CURPRIO(PROCEXT, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_EXTEND_CURPRIO(PROCEXT, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2      PROCEXT(LOWBND).CURPRIORITY .GT. PROCEXT(UPBND).CURPRIORITY) THEN
	    TMP = PROCEXT(LOWBND)
	    PROCEXT(LOWBND) = PROCEXT(UPBND)
	    PROCEXT(UPBND) = TMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN

C***************************************************************************
C		Entries for sorting Page Fault
C***************************************************************************
	ENTRY QSORT_BASIC_PAGEFAULT(PROCESS, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TEMP = PROCESS(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCESS(J).PAGEFAULT .GT. TEMP.PAGEFAULT) THEN
		J = J-1
	      ELSE
		PROCESS(I) = PROCESS(J)
		I = I + 1
		PROCESS(J) = PROCESS(I)
		PROCESS(I) = TEMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_BASIC_PAGEFAULT(PROCESS, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_BASIC_PAGEFAULT(PROCESS, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2      PROCESS(LOWBND).PAGEFAULT .GT. PROCESS(UPBND).PAGEFAULT) THEN
	    TEMP = PROCESS(LOWBND)
	    PROCESS(LOWBND) = PROCESS(UPBND)
	    PROCESS(UPBND) = TEMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN


	ENTRY QSORT_EXTEND_PAGEFAULT(PROCEXT, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TMP = PROCEXT(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCEXT(J).PAGEFAULT .GT. TMP.PAGEFAULT) THEN
		J = J-1
	      ELSE
		PROCEXT(I) = PROCEXT(J)
		I = I + 1
		PROCEXT(J) = PROCEXT(I)
		PROCEXT(I) = TMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_EXTEND_PAGEFAULT(PROCEXT, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_EXTEND_PAGEFAULT(PROCEXT, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2      PROCEXT(LOWBND).PAGEFAULT .GT. PROCEXT(UPBND).PAGEFAULT) THEN
	    TMP = PROCEXT(LOWBND)
	    PROCEXT(LOWBND) = PROCEXT(UPBND)
	    PROCEXT(UPBND) = TMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN

C***************************************************************************
C		Entries for sorting Pages in Memory
C***************************************************************************
	ENTRY QSORT_BASIC_PAGE(PROCESS, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TEMP = PROCESS(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCESS(J).PPAGES+PROCESS(J).GPAGES .GT. 
	2	TEMP.PPAGES+TEMP.GPAGES) THEN
		J = J-1
	      ELSE
		PROCESS(I) = PROCESS(J)
		I = I + 1
		PROCESS(J) = PROCESS(I)
		PROCESS(I) = TEMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_BASIC_PAGE(PROCESS, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_BASIC_PAGE(PROCESS, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2      	PROCESS(LOWBND).PPAGES+PROCESS(LOWBND).GPAGES .GT. 
	2 	PROCESS(UPBND).PPAGES+PROCESS(UPBND).GPAGES) THEN
	    TEMP = PROCESS(LOWBND)
	    PROCESS(LOWBND) = PROCESS(UPBND)
	    PROCESS(UPBND) = TEMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN


	ENTRY QSORT_EXTEND_PAGE(PROCEXT, PROC_INDEX, LOWBND, UPBND)

	EMPTY = .FALSE.
	DO WHILE (.NOT. EMPTY) 
	  IF ( UPBND - LOWBND .GE. 2 ) THEN
	    I = LOWBND
	    J = UPBND
	    TMP = PROCEXT(LOWBND)
	    DO WHILE (I .NE. J)
	      IF (PROCEXT(J).PPAGES+PROCEXT(J).GPAGES .GT. 
	2		TMP.PPAGES+TMP.GPAGES) THEN
		J = J-1
	      ELSE
		PROCEXT(I) = PROCEXT(J)
		I = I + 1
		PROCEXT(J) = PROCEXT(I)
		PROCEXT(I) = TMP
	      END IF
	    END DO

	    IF (I-1 .GT. LOWBND) CALL QSORT_EXTEND_PAGE(PROCEXT, PROC_INDEX, LOWBND, I-1)
	    IF (I+1 .LT. UPBND) CALL QSORT_EXTEND_PAGE(PROCEXT, PROC_INDEX, I+1, UPBND)

	    EMPTY = .TRUE.

	  ELSE IF ( LOWBND .LT. UPBND .AND. 
	2      	PROCEXT(LOWBND).PPAGES+PROCEXT(LOWBND).GPAGES .GT. 
	2	PROCEXT(UPBND).PPAGES+PROCEXT(UPBND).GPAGES) THEN
	    TMP = PROCEXT(LOWBND)
	    PROCEXT(LOWBND) = PROCEXT(UPBND)
	    PROCEXT(UPBND) = TMP
	    EMPTY = .TRUE.
	  ELSE
	    EMPTY = .TRUE.
	  END IF
	END DO
	RETURN

	END

