%!PS-Adobe-3.0
%%Title: (DisciplinedC)
%%Creator: (Microsoft Word: LaserWriter 8 F1-8.3.4)
%%CreationDate: (16:51 vendredi 6 novembre 1998)
%%For: (YN)
%%Pages: 10
%%DocumentFonts: Times-Bold Times-Roman Symbol Times-Italic Courier Courier-Bold
%%DocumentNeededFonts: Times-Bold Times-Roman Symbol Times-Italic Courier Courier-Bold
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 595 842 0 () ()
%ADO_ImageableArea: 29 31 567 812
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(DisciplinedC)def
/Creator(Microsoft Word: LaserWriter 8 F1-8.3.4)def
/CreationDate(16:51 vendredi 6 novembre 1998)def
/For(YN)def
/Pages 10 def
end def end
/md 204 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 83 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F1/setgray ld
/:F/setrgbcolor ld
/:F4/setcmykcolor where
{
pop
/setcmykcolor ld
}{
{
3
{
dup
3 -1 roll add
dup 1 gt{pop 1}if
1 exch sub
4 1 roll
}repeat
pop
setrgbcolor
}bd
}ifelse
/:Fx
{
counttomark
{0{G}0{:F}{:F4}}
exch get
exec
pop
}bd
/:rg{/DeviceRGB :ss}bd
/:sc{$cs :ss}bd
/:dc{/$cs xdf}bd
/:sgl{}def
/:dr{}bd
/:fCRD{pop}bd
/:ckcs{}bd
/:ss{/$c xdf}bd
/$cs Z
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
%%BeginFile: adobe_psp_derived_styles
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/wi
version(23.0)eq
{
{
gS 0 0 0 0 rC stringwidth gR
}bind
}{
/stringwidth load
}ifelse
def
/$o 1. def
/gl{$o G}bd
/ms{:M S}bd
/condensedmtx[.82 0 0 1 0 0]def
/:mc
{
condensedmtx :mf def
}bd
/extendedmtx[1.18 0 0 1 0 0]def
/:me
{
extendedmtx :mf def
}bd
/basefont Z
/basefonto Z
/dxa Z
/dxb Z
/dxc Z
/dxd Z
/dsdx2 Z
/bfproc Z
/:fbase
{
dup/FontType get 0 eq{
dup length dict begin
dup{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall
/FDepVector exch/FDepVector get[exch/:fbase load forall]def
}/bfproc load ifelse
/customfont currentdict end definefont
}bd
/:mo
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
basefont setfont
( )dup 0 4 -1 roll put
dup wi
setcharwidth
0 0 :M
gS
gl
dup show
gR
basefonto setfont
show
end
}def
}store :fbase
}bd
/:mso
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxa 1 ps div def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxa add exch
}if
setcharwidth
dup 0 0 ms
dup dxa 0 ms
dup dxa dxa ms
dup 0 dxa ms
gl
dxa 2. div dup ms
end
end
}def
}store :fbase
}bd
/:ms
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxb .05 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dxb add
}if
exch setcharwidth
dup dxb .01 add 0 ms
0 dxb :T
gS
gl
dup 0 0 ms
gR
basefonto setfont
0 0 ms
end
end
}def
}store :fbase
}bd
/:mss
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxc 1 ps div def
/dsdx2 .05 dxc 2 div add def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dsdx2 add
}if
exch setcharwidth
dup dsdx2 .01 add 0 ms
0 .05 dxc 2 div sub :T
dup 0 0 ms
dup dxc 0 ms
dup dxc dxc ms
dup 0 dxc ms
gl
dxc 2 div dup ms
end
end
}def
}store :fbase
}bd
/:msb
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxd .03 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxd add exch
}if
setcharwidth
dup 0 0 ms
dup dxd 0 ms
dup dxd dxd ms
0 dxd ms
end
end
}def
}store :fbase
}bd
/italicmtx[1 0 -.212557 1 0 0]def
/:mi
{
italicmtx :mf def
}bd
/:v
{
[exch dup/FontMatrix get exch
dup/FontInfo known
{
/FontInfo get
dup/UnderlinePosition known
{
dup/UnderlinePosition get
2 index 0
3 1 roll
transform
exch pop
}{
.1
}ifelse
3 1 roll
dup/UnderlineThickness known
{
/UnderlineThickness get
exch 0 3 1 roll
transform
exch pop
abs
}{
pop pop .067
}ifelse
}{
pop pop .1 .067
}ifelse
]
}bd
/$t Z
/$p Z
/$s Z
/:p
{
aload pop
2 index mul/$t xs
1 index mul/$p xs
.012 mul/$s xs
}bd
/:m
{gS
0 $p rm
$t lw
0 rl stroke
gR
}bd
/:n
{
gS
0 $p rm
$t lw
0 rl
gS
gl
stroke
gR
strokepath
$s lw
/setstrokeadjust where{pop
currentstrokeadjust true setstrokeadjust stroke setstrokeadjust
}{
stroke
}ifelse
gR
}bd
/:o
{gS
0 $p rm
$t 2 div dup rm
$t lw
dup 0 rl
stroke
gR
:n
}bd
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
1 dict dup /ManualFeed false put setpagedevice
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageSize A4Small

    2 dict dup /PageSize [595 842] put dup /ImagingBBox null put setpagedevice
%%EndFeature
}featurecleanup
(YN)setjob
/mT[1 0 0 -1 29 812]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
%%IncludeFont: Symbol
%%IncludeFont: Times-Italic
%%IncludeFont: Courier
%%IncludeFont: Courier-Bold
/f0_1/Times-Bold
:mre
/f0_14 f0_1 14 scf
/f0_10 f0_1 10 scf
/f1_1/Times-Roman
:mre
/f1_12 f1_1 12 scf
/f1_10 f1_1 10 scf
/f1_9 f1_1 9 scf
/f1_8 f1_1 8 scf
/f2_1/Symbol
:bsr
240/apple pd
:esr
/f2_10 f2_1 10 scf
/f2_9 f2_1 9 scf
/f3_1/Times-Italic
:mre
/f3_12 f3_1 12 scf
/f3_10 f3_1 10 scf
/f4_1 f2_1
:mi
/f4_10 f4_1 10 scf
/f5_1 f1_1
:v def
/f6_1 f2_1
:v def
/f7_1/Courier
:mre
/f7_10 f7_1 10 scf
/f7_9 f7_1 9 scf
/f8_1/Courier-Bold
:mre
/f8_9 f8_1 9 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(YN; page: 1 of 10)setjob
%%EndPageSetup
gS 0 0 538 781 rC
188 60 :M
f0_14 sf
4.274 .427(Disciplined C \(version 2.1h\))J
244 84 :M
f1_12 sf
-.069(Yves L. Noyelle)A
86 108 :M
f3_12 sf
-.101(\203cole Sup\216rieure d'\203lectricit\216, Plateau de Moulon, 91192 Gif/Yvette Cedex, France)A
203 120 :M
f1_12 sf
-.099(E-Mail: Yves.Noyelle@supelec.fr)A
31 160 :M
f0_10 sf
.543(Abstract)A
31 175 :M
f1_10 sf
.994 .099(Some proposals to render the C language a truly high)J
31 185 :M
2.037 .204(level language are presented, as well as a program)J
31 195 :M
1.668 .167(verifying that a given C program conforms to those)J
31 205 :M
.02(proposals.)A
31 235 :M
f0_10 sf
.506(Introduction)A
31 250 :M
f1_10 sf
.37 .037(Programming is, as every practitioner knows, a delicate)J
31 260 :M
.536 .054(art, where the main problem is not so much to obtain a)J
31 270 :M
.116 .012("working" program \(which is mandatory, of course\), but)J
31 280 :M
.764 .076(to have designed it in such a way that it is not fragile,)J
31 290 :M
3.162 .316(i.e. it can be modified/updated/debugged without)J
31 300 :M
.822 .082(breaking down. This means, for example, no \(manual\))J
31 310 :M
.229 .023(duplication of code or "parallel" data \(because, should a)J
31 320 :M
3.948 .395(modification occur, the odds are high that the)J
31 330 :M
.93 .093(duplicate\(s\) will not be modified\), or, more generally,)J
31 340 :M
1.464 .146(that the programmer has dumped in the program the)J
31 350 :M
1.124 .112(constraints set when he wrote it, so that they become)J
31 360 :M
-.115(apparent.)A
31 375 :M
.695 .069(In order to attain these goals, programmers need tools.)J
31 385 :M
.621 .062(These tools should be as easy as possible to use, while)J
31 395 :M
.733 .073(not hampering creativity. "Easy to use" means that the)J
31 405 :M
.665 .067(tool is explainable \(so its use is systematic\), natural \(it)J
31 415 :M
1.33 .133(does not disturb common sense\), and recognizes that)J
31 425 :M
.399 .04(human nature is fallible \(so it protects "gently" the user)J
31 435 :M
.138 .014(against himself\).)J
31 450 :M
.164 .016(Among the tools that allow a programmer to express his)J
31 460 :M
.304 .03(ideas are of course the programming languages, and the)J
31 470 :M
1.147 .115(compilers that go along, with their warning and error)J
31 480 :M
.007(mechanisms.)A
31 495 :M
.116 .012(One programming language much used these days is the)J
31 505 :M
.016 .002(\(ANSI\) C language, probably for the following reasons:)J
31 520 :M
(-)S
40 520 :M
.184 .018(it naturally supports modularity,)J
31 535 :M
(-)S
40 535 :M
1.085 .108(being very close to the architecture of most current)J
40 545 :M
-.02(computers, it can express a wide range of applications;)A
40 555 :M
2.312 .231(in fact, it is often called "the portable assembly)J
40 565 :M
-.075(language",)A
31 580 :M
(-)S
40 580 :M
1.45 .145(it offers many representations for the integer type,)J
40 590 :M
2.733 .273(which permits the best possible use of a given)J
40 600 :M
-.336(hardware,)A
31 615 :M
(-)S
40 615 :M
.607 .061(it offers a powerful macro mechanism, which can be)J
40 625 :M
-.061(used to prevent manual code duplication,)A
31 640 :M
(-)S
40 640 :M
.394 .039(the 'include' facility also works in the same direction,)J
40 650 :M
-.021(and allows some encapsulation of modules,)A
31 665 :M
(-)S
40 665 :M
.833 .083(the block concept makes it possible to minimize the)J
40 675 :M
1.693 .169(scope of identifiers \(which is always desirable, to)J
40 685 :M
-.082(prevent overflowing the reader's mind\),)A
31 700 :M
(-)S
40 700 :M
1.768 .177(it comes with a large set of predefined functions,)J
40 710 :M
1.852 .185(allowing the user to easily implement exceptions,)J
40 720 :M
1.547 .155(dynamic memory allocation, and so on; moreover,)J
40 730 :M
1.851 .185(many system interfaces, such as X-Window's, are)J
40 740 :M
.158 .016(meant to be used via C,)J
278 160 :M
(-)S
287 160 :M
1.028 .103(it is quite portable, along with its run time support;)J
287 170 :M
3.006 .301(besides, the conditional compilation mechanism)J
287 180 :M
3.912 .391(permits easy adaptation of programs to local)J
287 190 :M
-.016(conditions.)A
278 205 :M
.218 .022(But the usual C compiler \(or its fellow companion 'lint'\))J
278 215 :M
.21 .021(lacks most of the devices that allow a program not to be)J
278 225 :M
.492 .049(too brittle \(for example, to check that an array is of the)J
278 235 :M
2.159 .216(same size as an enum used to name its elements\);)J
278 245 :M
.601 .06(besides it is much too tolerant, even allowing things to)J
278 255 :M
.968 .097(work "by miracle" [MOD 91]. This is a pure disaster,)J
278 265 :M
1.309 .131(because it gives programmers reasons to use obscure)J
278 275 :M
.262 .026(tricks, with the sole justification that "it works"! \(on the)J
278 285 :M
.217 .022(local compiler, of course...\).)J
278 300 :M
.798 .08(C also is very tolerant, permitting programmers to fall)J
278 310 :M
1.04 .104(into various well-concealed traps, such as: ")J
f7_9 sf
.902 .09(if \(a =)J
278 320 :M
.236(b\)...)A
f1_10 sf
.541 .054(" \(instead of ")J
f7_9 sf
.787 .079(if \(a == b\)...")J
f1_10 sf
.211 .021(\),   ")J
f7_9 sf
.236(a[i,j])A
f1_10 sf
(")S
278 330 :M
.355 .035(\(instead of ")J
f7_9 sf
.129(a[i][j])A
f1_10 sf
.139 .014("\),   ")J
f7_9 sf
.541 .054(if \(array1 == array2\))J
278 340 :M
.526(...)A
f7_10 sf
.974 .097(" )J
f1_10 sf
1.176 .118(\(alas, it won't compare arrays !\),   or ... \(long)J
278 350 :M
.19(list\).)A
278 365 :M
.354 .035(But, on the positive side, this tolerance, well harnessed,)J
278 375 :M
-.002(can be turned into a great advantage; in other words, it is)A
278 385 :M
.181 .018(easy for C to be constrained into a disciplined language,)J
278 395 :M
.983 .098(with clean concepts, offering much syntatic and static)J
278 405 :M
.443 .044(semantic guidance to the programmer, and inciting him)J
278 415 :M
.428 .043(to dump in the code, rather naturally, the constraints he)J
278 425 :M
1.564 .156(chose to obey while writing it, all of which without)J
278 435 :M
.8 .08(loosing any efficiency. The purpose of this paper is to)J
278 445 :M
-.023(propose such a "harness".)A
278 460 :M
.655 .065(This harness is mainly designed to allow strong typing)J
278 470 :M
1.747 .175(\(especially between compilation units\), well defined)J
278 480 :M
2.869 .287(types, name equivalence for all types, reasonable)J
278 490 :M
1.551 .155(automatic conversion rules, easy to use arrays \(even)J
278 500 :M
2.79 .279(dynamically allocated ones\), limited use of casts,)J
278 510 :M
.275 .028(enhanced portability, and removal of most traps... It has)J
278 520 :M
-.051(been implemented as a C checker program.)A
278 535 :M
.161 .016(The following gets into greater detail; it assumes a good)J
278 545 :M
.75 .075(knowledge of C, but, beware, may come as a shock to)J
278 555 :M
-.071(seasoned C programmers.)A
278 580 :M
f0_10 sf
2.604 .26(Areas where C can be disciplined)J
278 595 :M
f1_10 sf
10 f5_1 :p
29 :m
.023(Typing)A
278 610 :M
1.447 .145(C offers a wealth of primitive types, plus very good)J
278 620 :M
1.617 .162(means to create new types. But it lacks the boolean)J
278 630 :M
.642 .064(type, and more generally allows a complete mixture of)J
278 640 :M
1.55 .155(all scalar types \(including characters and pointers\312!\),)J
278 650 :M
.853 .085(with little concern for information loss. Also, the type)J
278 660 :M
.086 .009(equivalence mechanism for arithmetic types is structural)J
278 670 :M
.259 .026(equivalence, which does not make it possible to enforce)J
278 680 :M
4.182 .418(the distinction between "information" type and)J
278 690 :M
-.038("representation" type \(see later, "parallel types"\).)A
278 705 :M
.154 .015(To remedy this, Disciplined C sets the following:)J
278 720 :M
(-)S
287 720 :M
1.921 .192('char' \()J
128.005 :m
3.065 .306(without signedness specifier)J
1.565 .156(\) is a specific)J
287 730 :M
2.116 .212(character type, whose constants are the character)J
287 740 :M
1.863 .186(constants of C; this type is a closed type, not an)J
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(YN; page: 2 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(2)S
69 74 :M
2.027 .203(arithmetic type, which means that the \(in\)famous)J
69 84 :M
-.023(idiom:)A
69 99 :M
f7_9 sf
-.367(int)A
f8_9 sf
-.367( )A
f7_9 sf
-.381(c;  /* notice the 'int' ! */)A
69 109 :M
-.409(while \(\( c = getchar\(\) \) !=  EOF\) {...})A
69 124 :M
f1_10 sf
-.026(is to be replaced by:)A
69 139 :M
f7_9 sf
-.256(char)A
f8_9 sf
-.256( )A
f7_9 sf
-.512(c;)A
69 149 :M
-.408(while \(c = getc\(stdin\), !feof\(stdin\)\) {...})A
69 164 :M
f1_10 sf
.022 .002(A 'char' constant must contain just one character,)J
60 179 :M
(-)S
69 179 :M
.173 .017(integral types are: \(un\)signed char, \(\(un\)signed\) short,)J
69 189 :M
1.074 .107(\(\(un\)signed\) int, \(\(un\)signed\) long; combinations of)J
69 199 :M
1.747 .175('signed' and 'unsigned' varieties that could lead to)J
69 209 :M
.038 .004(information loss or "unexpected" results \([K&R 88] p.)J
69 219 :M
.531 .053(198\) are pointed out. Besides, an attempt to compare)J
69 229 :M
1.493 .149(differences of 'unsigned' via relational operators is)J
69 239 :M
2.412 .241(flagged, because the underlying C compiler will)J
69 249 :M
-.015(generate an unsigned branch in such a case, fact which)A
69 259 :M
.998 .1(may not be obvious to all programmers. Consider a)J
69 269 :M
2.897 .29(graphic application where point coordinates are)J
69 279 :M
-.063(represented as unsigned; then )A
f7_9 sf
-.084(xPoint2 - xPoint1)A
f1_10 sf
-.071( is)A
69 289 :M
1.647 .165(still an unsigned \(from the underlying C compiler)J
69 299 :M
2.785 .279(point of view\), which means that )J
f7_9 sf
5.213 .521(xPoint2 -)J
69 309 :M
1.254 .125(xPoint1 > -1)J
f1_10 sf
.744 .074( will always be false ! It is strongly)J
69 319 :M
.17 .017(recommended to '#define' a "byte/ubyte" synonym for)J
69 329 :M
-.082('signed/unsigned char',)A
60 344 :M
(-)S
69 344 :M
.127 .013(floating types: no change,)J
60 359 :M
(-)S
69 359 :M
.526 .053(a boolean type is introduced, that is to be the type of)J
69 369 :M
.832 .083(the \(first\) argument\(s\) of 'if', 'while', '?:', '||', '&&' or)J
69 379 :M
.238 .024('!' operators, and the type of the second argument of a)J
69 389 :M
-.001('for' operator. It has to be defined by the following:)A
69 404 :M
f7_9 sf
-.415(typedef unsigned int bool;)A
69 419 :M
f1_10 sf
.55 .055(Relational and equality operators, as well as '||', '&&')J
69 429 :M
2.473 .247(and '!', yield a result of type 'bool'.  '&', '|', '^')J
69 439 :M
.664 .066(operators yield a result that can be used generally as)J
69 449 :M
.691 .069('bool', but , since its value is not guaranteed to be in)J
69 459 :M
.894 .089(the [0, 1] interval, a check is performed  to warn in)J
69 469 :M
1.503 .15(case of possible strange result \(e.g.:  )J
f7_9 sf
3.026 .303(if \(\(feof)J
69 479 :M
-.361(\(stdin\) & fclose\(stdin\)\) == TRUE\))A
f1_10 sf
-.279( \).)A
69 494 :M
.333 .033(The constants 'TRUE' and 'FALSE' \(which may carry)J
69 504 :M
.907 .091(any other name suitable to the programmer, such as)J
69 514 :M
1.008 .101(VRAI and FAUX\) are defined via constant boolean)J
69 524 :M
-.019(expressions, for example:)A
69 539 :M
f7_9 sf
-.419(# define TRUE  \(0==0\))A
69 549 :M
-.419(# define FALSE \(0!=0\))A
69 564 :M
f1_10 sf
.363 .036(Besides eliminating bad programming practices, such)J
69 574 :M
-.044(as \(excerpt from 'strcpy'\):)A
69 589 :M
f7_9 sf
-.399(while \()A
0 1 rm
-.399(*)A
0 -1 rm
-.399(s++ = )A
0 1 rm
-.399(*)A
0 -1 rm
-.498(t++\);)A
69 599 :M
f1_10 sf
-.186(\(instead of    )A
f7_9 sf
-.287(while \(\()A
0 1 rm
-.287(*)A
0 -1 rm
-.287(s++ = )A
0 1 rm
-.287(*)A
0 -1 rm
-.287(t++\) != '\\0'\);)A
f1_9 sf
-.279( \))A
69 614 :M
f1_10 sf
.234 .023(a side effect of the introduction of this type is that the)J
69 624 :M
-.255(standard error:)A
69 639 :M
f7_9 sf
-.189(if \(y = 0\)...)A
f1_10 sf
-.112(      \(instead of    )A
f7_9 sf
-.189(if \(y == 0\)...)A
f1_10 sf
<29>S
69 654 :M
.295 .029(is flagged by a "Boolean expected" warning \(warning)J
69 664 :M
(also for:)S
69 679 :M
f7_9 sf
-.239(if \(setOfBits & mask == Msk1\)... , )A
f1_10 sf
-.193(instead of)A
95 689 :M
-.156(   )A
f7_9 sf
-.337(if \(\(setOfBits & mask\) == Msk1\)... )A
f1_9 sf
<29>S
69 704 :M
f1_10 sf
.166 .017(Explicit comparison to zero is less cryptic, and entails)J
69 714 :M
1.054 .105(no loss of efficiency, the compiler testing against 0)J
69 724 :M
-.099(anyway,)A
60 739 :M
(-)S
69 739 :M
1.55 .155('enum' types are closed, i. e. they are not mixable)J
69 749 :M
.655 .065(between them, nor with arithmetic types \(in fact, the)J
69 759 :M
.766 .077('char' type seen previously is considered as an enum)J
69 769 :M
.193 .019(type\). However, some amount of mixing is allowed: a)J
316 74 :M
1.361 .136(\(signed\) int can be added to or subtracted from an)J
316 84 :M
1.5 .15(enum, yielding an enum of the same kind. This is)J
316 94 :M
.67 .067(because the notion of distance between two enum or)J
316 104 :M
1.329 .133(char is often useful \(for example, '9' - '0'\), so sub-)J
316 114 :M
.494 .049(tracting two enum \(of the same kind\) is allowed, and)J
316 124 :M
.292 .029(yields an 'int'.)J
316 139 :M
.398 .04(Enum constants can be initialized by signed 'int'. The)J
316 149 :M
.17 .017(constants of a given enum must have differing values,)J
316 159 :M
.584 .058(except if the /)J
0 2 rm
.24(*)A
0 -2 rm
0 -2 rm
.26(~)A
0 2 rm
.246(SameValue)A
0 2 rm
.24(*)A
0 -2 rm
.711 .071(/ d-pragma is used \("d-)J
316 169 :M
-.086(pragmas" will be described later\).)A
316 184 :M
2.724 .272(The only operations allowed on enums, besides)J
316 194 :M
1.248 .125(comparison, assignment and addition/subtraction of)J
316 204 :M
1.106 .111(distance, are '&', '|', '^', '~', '>>', '<<'; so enums can)J
316 214 :M
1.067 .107(be used as sets of bits, but not \(in the absence of a)J
316 224 :M
(/)S
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
.035(TypeCombination)A
0 2 rm
(*)S
0 -2 rm
.126 .013(/ d-pragma telling the contrary\))J
316 234 :M
-.01(as arithmetic quantities,)A
307 249 :M
(-)S
316 249 :M
.787 .079(a major innovation of Disciplined C is the notion of)J
316 259 :M
2.209 .221("parallel type", that allows a distinction between)J
316 269 :M
3.696 .37(information type and representation type. The)J
316 279 :M
.038(following:)A
316 294 :M
f7_9 sf
-.414(typedef  int  Tindex, Tval;)A
316 304 :M
-.413(typedef  Tindex  Trow, Tcol;)A
316 319 :M
f1_10 sf
1.153 .115(creates four )J
10 f5_1 :p
31.709 :m
.283(distinct)A
1.046 .105( types, but which all accept the)J
316 329 :M
2.925 .293(same operations and the same constants as the)J
316 339 :M
.634 .063("representation" type \('int' here\). Tindex, Tval, Trow)J
316 349 :M
-.023(and Tcol are examples of "information" types, because)A
316 359 :M
3.713 .371(they convey an idea of the semantics of the)J
316 369 :M
.464 .046(corresponding objects. For example, they may be put)J
316 379 :M
.356 .036(to use in a checkers playing program: Tval will name)J
316 389 :M
.004 0('int's that represent values of checkers, Trow and Tcol,)J
316 399 :M
.571 .057('int's that represent row and column indexes, Tindex,)J
316 409 :M
-.077(generic type for indexes.)A
316 424 :M
.15 .015(Tindex, Tval, Trow and Tcol are called parallel types;)J
316 434 :M
.274 .027(in fact, a type T is said to be )J
30.847 :m
.109(parallel)A
.287 .029( to a type xxx iff)J
316 444 :M
.129 .013(it is defined by a "typedef xxx T", with xxx parsing to)J
316 454 :M
1.662 .166(a naked 'baseType' \(no qualifier nor modifier; see)J
316 464 :M
.094 .009(grammar in Appendix A\). In other words, T must be a)J
316 474 :M
.125 .013(strict synonym of baseType.)J
316 489 :M
1.133 .113(This "parallel" relation is transitive but antisymme-)J
316 499 :M
.518 .052(trical. Other typedefs do not introduce parallel types;)J
316 509 :M
1.39 .139(they just name qualified/modified variations of the)J
316 519 :M
-.102(baseType.)A
316 534 :M
2.038 .204(The )J
88.42 :m
4.162 .416(representation type)J
1.745 .175( of a parallel type is the)J
316 544 :M
.356 .036(possibly qualified or modified nativeType associated,)J
316 554 :M
.214 .021(using traditional C rules, to its type identifier.)J
316 569 :M
.54 .054(Cascaded synonymous typedefs create a hierarchy of)J
316 579 :M
1.163 .116(parallel types, hierarchy used to set a compatibility)J
316 589 :M
.406 .041(rule, and to find the result type of an operator. Let us)J
316 599 :M
.721 .072(define that a type T1 is "higher" than a parallel type)J
316 609 :M
.973 .097(T2 if T1 is T2 or any ancestor of T2 \(including the)J
316 619 :M
.701 .07(representation type\), that is, T1 has been used in the)J
316 629 :M
2.646 .265(chain of typedefs needed to define T2 from its)J
316 639 :M
1.454 .145(representation type. For example, Tindex is higher)J
316 649 :M
.68 .068(than Trow, but not than Tval, and Tval is not higher)J
316 659 :M
.928 .093(than Tindex or Trow. If a parallel type meets a non)J
316 669 :M
.69 .069(parallel type compatible with its representation type,)J
316 679 :M
2.566 .257(the wider representation type is the higher type)J
316 689 :M
1.444 .144(\(unsigned varieties are considered wider than their)J
316 699 :M
.126 .013(signed counterpart; numeric constants are supposed to)J
316 709 :M
.07 .007(have the narrowest representation type possible, in the)J
316 719 :M
-.063(same variety if they are signed or U-suffixed\).)A
316 734 :M
2.469 .247(Then the compatibility rule is the following: an)J
316 744 :M
.806 .081(operator \(except shift operators, whose operands are)J
316 754 :M
-.01(deconnected\) can only combine operands such that the)A
316 764 :M
.79 .079(type of one operand is higher than all other operand)J
316 774 :M
.451 .045(types; for operators other than relational and equality)J
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(YN; page: 3 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(3)S
69 74 :M
2.03 .203(operators, the result type is this higher type. For)J
69 84 :M
.4 .04(assignments, the higher type has to be the type of the)J
69 94 :M
1.449 .145(left operand. For functions, see below \('Casts'\) the)J
69 104 :M
(/)S
0 2 rm
-.062(*)A
0 -2 rm
0 -2 rm
-.067(~)A
0 2 rm
-.057(ResultType)A
0 2 rm
-.062(*)A
0 -2 rm
-.057(/ d-pragma.)A
69 119 :M
.212 .021(Since these rules do not facilitate mixing of types, the)J
69 129 :M
.212(/)A
0 2 rm
.381(*)A
0 -2 rm
0 -2 rm
.412(~)A
0 2 rm
.369(TypeCombination)A
0 2 rm
.381(*)A
0 -2 rm
1.268 .127(/ d-pragma tells the allowed)J
69 139 :M
.651 .065(combinations of types \(e.g. Tohm )J
0 2 rm
.246 .025(* )J
0 -2 rm
.749 .075(Tamp -> Tvolt\).)J
69 149 :M
3.54 .354(Besides, there is a notion of 'coefficient', for)J
69 159 :M
2.718 .272(multiplication, division, modulo, whereby if the)J
69 169 :M
1.2 .12(coefficient is of representation type, then the result)J
69 179 :M
.308 .031(type is the type of the other operand. Also, a constant)J
69 189 :M
.185 .018(of representation type meeting a parallel type behaves)J
69 199 :M
.285 .029(as if it was of that type.)J
69 214 :M
1.111 .111(The special rules that apply to enums also apply to)J
69 224 :M
-.155(their descendants.)A
69 239 :M
.099 .01(The /)J
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
.036(RootType)A
0 2 rm
(*)S
0 -2 rm
.118 .012(/ d-pragma isolates the so qualified)J
69 249 :M
.726 .073(type from its ancestors \(renders invisible the subtree)J
69 259 :M
1.41 .141(headed by that type\); also, the constants of a such)J
69 269 :M
2.699 .27("root" type are compatible with all its \(visible\))J
69 279 :M
-.255(descendants.)A
69 294 :M
-.009(Let us consider the following example:)A
69 309 :M
f7_9 sf
-.41(typedef int Ti1, Tri1 /*~RootType*/;)A
69 319 :M
-.409(typedef Tri1 Trri2 /*~RootType*/, Tri2;)A
69 329 :M
-.409(Ti1 i1; Tri1 ri1; Tri2 ri2; Trri2 rri2;)A
69 349 :M
-.465(i1 = 0;)A
165 349 :M
-.456(/* OK */)A
69 359 :M
-.456(ri1 = 0;)A
165 359 :M
-.439(/* Wrong */)A
69 369 :M
-.429(ri1 = \(Tri1\)0;)A
165 369 :M
-.456(/* OK */)A
69 379 :M
-.456(ri2 = 0;)A
165 379 :M
-.439(/* Wrong */)A
69 389 :M
-.427(ri2 += \(Tri1\)1;)A
165 389 :M
-.418(/* OK \(generic cst\) */)A
69 399 :M
-.443(ri2 = ri1;)A
165 399 :M
-.439(/* Wrong */)A
69 409 :M
-.443(ri1 = ri2;)A
165 409 :M
-.456(/* OK */)A
69 419 :M
-.427(rri2 = \(Tri1\)0;)A
165 419 :M
-.439(/* Wrong */)A
69 429 :M
-.425(rri2 = \(Trri2\)0;)A
165 429 :M
-.456(/* OK */)A
69 439 :M
-.427(ri1 = \(Trri2\)0;)A
165 439 :M
-.439(/* Wrong */)A
69 449 :M
-.429(ri1 = \(Tri2\)0;)A
165 449 :M
-.456(/* OK */)A
69 479 :M
f1_10 sf
-.023(\(the created hierarchy is\312:)A
142 487 12 12 rC
143 496 :M
(int)S
gR
gS 112 502 15 12 rC
113 511 :M
f1_10 sf
(Ti1)S
gR
gS 171 502 64 12 rC
172 511 :M
f1_10 sf
-.013(Tri1 \(root type\))A
gR
gS 202 518 19 12 rC
203 527 :M
f1_10 sf
-.071(Tri2)A
gR
gS 128 518 67 12 rC
129 527 :M
f1_10 sf
-.032(Trri2 \(root type\))A
gR
gS 111 486 125 45 rC
-1 -1 122 503 1 1 146 499 @b
152 500 -1 1 178 502 1 152 499 @a
183 515 -1 1 209 517 1 183 514 @a
-1 -1 153 518 1 1 177 514 @b
gR
gS 29 30 538 781 rC
69 545 :M
f1_10 sf
<29>S
69 560 :M
2.473 .247(To ease up things, 'int' constants can be added/)J
69 570 :M
2.781 .278(subtracted uncasted to/from \(numeric\) root type)J
69 580 :M
.032(constants.)A
69 595 :M
.068 .007(As can be seen, the /)J
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
.03(RootType)A
0 2 rm
(*)S
0 -2 rm
.097 .01(/ d-pragma allows a)J
69 605 :M
.128 .013(\(leaf\) type to be closed \(not to accept constants of any)J
69 615 :M
-.051(of its ascendants\),)A
69 630 :M
2.569 .257(In short, the parallel type facility enables name)J
69 640 :M
.625 .063(equivalence instead of structural equivalence for any)J
69 650 :M
2.867 .287(type in C, and so fosters programmers to give)J
69 660 :M
.818 .082(differing names to the types of their different object)J
69 670 :M
-.037(classes.)A
60 685 :M
10 f5_1 :p
26 :m
-.24(Arrays)A
60 700 :M
-.068(Arrays are a common data structure, easily understood by)A
60 710 :M
3.115 .311(most programmers because of their mathematical)J
60 720 :M
-.17(background.)A
60 735 :M
.594 .059(But in C, arrays, especially dynamically defined arrays)J
60 745 :M
1.091 .109(\(by way of 'malloc'\), are very difficult to use without)J
60 755 :M
.383 .038(coming across the notion of pointers, an awful prospect)J
60 765 :M
1.779 .178(for many naive users. So, with the help of a set of)J
60 775 :M
.117 .012(macros \(predefined in a header file called "dynarray.h"\),)J
60 785 :M
.507 .051(Disciplined C makes it possible to use any array \(static)J
307 74 :M
1.452 .145(or dynamic\) without ever having to use pointers \(cf.)J
307 84 :M
-.13(Appendix B\).)A
307 99 :M
1.185 .118(On the other hand, the array concept being natural, a)J
307 109 :M
-.051(pointer can always be used as an array name.)A
307 124 :M
1.4 .14(There is no automatic conversion from an array to a)J
307 134 :M
.214 .021(pointer to its first element \(except for string literals, and)J
307 144 :M
1.034 .103(for function parameter passing: simulation of call "by)J
307 154 :M
.739 .074(reference"\), and one has to explicitly use the construct)J
307 164 :M
.542("&array)A
0 -1 rm
.39([)A
0 1 rm
.326(i)A
0 -1 rm
.39(])A
0 1 rm
.478(")A
f2_10 sf
.266 .027( )J
f1_10 sf
1.279 .128(to get a pointer on the i)J
f1_8 sf
0 -2 rm
.365(th)A
0 2 rm
f1_10 sf
0 -3 rm
.266 .027( )J
0 3 rm
2.975 .298(element. One)J
307 174 :M
.309 .031(consequence is that the construction   )J
f7_9 sf
.486 .049(if \(array1 ==)J
307 184 :M
(array2\) ...)S
f1_10 sf
.01 .001(  is not accepted, so programmers will not)J
307 194 :M
-.086(believe that arrays can be compared.)A
307 209 :M
.583 .058(Another feature of Disciplined C is that, at each use of)J
307 219 :M
.429 .043(an array, the type of the index expression \(any integral,)J
307 229 :M
1.014 .101(enum or bool type\) is checked against the type of the)J
307 239 :M
3.987 .399(bound; this last type can be specified via the)J
307 249 :M
.078(/)A
0 2 rm
.141(*)A
0 -2 rm
0 -2 rm
.153(~)A
0 2 rm
.807 .081(IndexType <type>)J
0 2 rm
.141(*)A
0 -2 rm
.517 .052(/ d-pragma \(which overrides the)J
307 259 :M
.234 .023(type of the bound-giving expression, if present\). This d-)J
307 269 :M
1.142 .114(pragma may also be used for pointers, to cater to the)J
307 279 :M
-.1(case where they are used as dynamic array names.)A
307 294 :M
.631 .063(The value of a constant index expression is checked to)J
307 304 :M
.626 .063(be positive and less than the bound \(except if indexing)J
307 314 :M
-.019(pointer\).)A
307 329 :M
22 :m
.084(Casts)A
307 344 :M
1.366 .137(To encourage programmers to choose the right types)J
307 354 :M
.051 .005(from the outset, and to enhance program portability with)J
307 364 :M
.508 .051(respect to, for example, alignment problems, the use of)J
307 374 :M
-.029(casts is severely monitored:)A
307 389 :M
(-)S
316 389 :M
1.853 .185(any arithmetic/enum/bool type can be cast to any)J
316 399 :M
2.149 .215(other arithmetic/enum/bool type, but an overflow)J
316 409 :M
-.038(check is performed on constant expressions,)A
307 424 :M
(-)S
316 424 :M
1.34 .134(pointers: they can only be cast to other pointers; a)J
316 434 :M
1.415 .142(non 'void )J
0 2 rm
.536(*)A
0 -2 rm
1.373 .137(' pointer cannot be cast to a pointer on)J
316 444 :M
1.367 .137(higher alignment-requiring type, or to a pointer on)J
316 454 :M
(type whose internal layout is machine dependent; only)S
316 464 :M
.973 .097(the constant 0 may be cast to a pointer. Conversion)J
316 474 :M
.861 .086(from a 'void )J
0 2 rm
.363(*)A
0 -2 rm
1.126 .113(' pointer \(except NULL\) to any other)J
316 484 :M
.946 .095(pointer has to be documented either by a cast or by)J
316 494 :M
2.134 .213(using the /)J
0 2 rm
.794(*)A
0 -2 rm
0 -2 rm
.859(~)A
0 2 rm
.778(VoidToOther)A
0 2 rm
.794(*)A
0 -2 rm
.441(/)A
0 2 rm
.361 .036( )J
0 -2 rm
3.086 .309(d-pragma, this for)J
316 504 :M
.037 .004(example to prevent the following construct:)J
316 519 :M
f7_9 sf
-.399(void )A
0 1 rm
-.399(*)A
0 -1 rm
-.399(pv; struct{...} )A
0 1 rm
-.399(*)A
0 -1 rm
-.399(pst; float )A
0 1 rm
-.399(*)A
0 -1 rm
-.532(pfl;)A
316 529 :M
-.415( ... ; pst= pv = pfl; ...)A
316 544 :M
f1_10 sf
.304 .03(from going unnoticed. A d-pragma, /)J
0 2 rm
.088(*)A
0 -2 rm
0 -2 rm
.095(~)A
0 2 rm
.081(ResultType)A
0 2 rm
.088(*)A
0 -2 rm
.093(/,)A
316 554 :M
1.06 .106(eases the situation for generic "modifier" functions,)J
316 564 :M
.971 .097(such as 'memcpy' or 'realloc', by specifying that the)J
316 574 :M
1.167 .117(result type of a given call to such a function is the)J
316 584 :M
.46 .046(type of the current actual parameter corresponding to)J
316 594 :M
-.027(the /)A
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
-.036(ResultType)A
0 2 rm
(*)S
0 -2 rm
-.031(/ qualified formal parameter, e.g.:)A
316 609 :M
f7_9 sf
-.399(void )A
0 1 rm
-.399(*)A
0 -1 rm
-.399(realloc\(void )A
0 1 rm
-.399(*)A
0 -1 rm
-.399(p /)A
0 1 rm
-.399(*)A
0 -1 rm
-.399(~ResultType)A
0 1 rm
-.399(*)A
0 -1 rm
-.797(/,)A
377 619 :M
-.399(  size_t n\);  /)A
0 1 rm
-.399(*)A
0 -1 rm
-.399( declaration )A
0 1 rm
-.399(*)A
0 -1 rm
(/)S
316 634 :M
-.399(realloc\(ptr, exp\)   /)A
0 1 rm
-.399(*)A
0 -1 rm
-.432( type of this)A
342 644 :M
-.399(    'realloc' call = type of 'ptr' )A
0 1 rm
-.399(*)A
0 -1 rm
-.797(/,)A
316 659 :M
f1_10 sf
.919 .092(The type of the /)J
0 2 rm
.396(*)A
0 -2 rm
0 -2 rm
.429(~)A
0 2 rm
.365(ResultType)A
0 2 rm
.396(*)A
0 -2 rm
1.594 .159(/ formal parameter)J
316 669 :M
.533 .053(must be the same that \(or a descendant of\) the return)J
316 679 :M
.183 .018(type of the function.)J
316 694 :M
.719 .072(For generic "creator" functions, such as 'malloc', see)J
316 704 :M
(below the /)S
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
(Generic)S
0 2 rm
(*)S
0 -2 rm
(/ d-pragma\312,)S
307 719 :M
(-)S
316 719 :M
.023 .002(arrays: they can't be cast to anything \(meaningless\),)J
307 734 :M
(-)S
316 734 :M
.312 .031(parallel types: they may be cast freely into each other)J
316 744 :M
.18 .018(\(but the /)J
0 2 rm
.075(*)A
0 -2 rm
0 -2 rm
.081(~)A
0 2 rm
.072(CastTo)A
0 2 rm
.075(*)A
0 -2 rm
.177 .018(/ d-pragma  is rather to be used in)J
316 754 :M
-.053(that case\).)A
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(YN; page: 4 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(4)S
60 79 :M
2.147 .215(Casts not conforming to these rules, or to a lower)J
60 89 :M
1.201 .12(qualified pointer type, elicit a warning, which can be)J
60 99 :M
5.113 .511(avoided by using the /)J
0 2 rm
1.795(*)A
0 -2 rm
0 -2 rm
1.941(~)A
0 2 rm
1.794(OddCast)A
0 2 rm
1.795(*)A
0 -2 rm
3.765 .377(/ or the)J
60 109 :M
(/)S
0 2 rm
-.075(*)A
0 -2 rm
0 -2 rm
-.081(~)A
0 2 rm
-.074(PortableQM)A
0 2 rm
-.075(*)A
0 -2 rm
-.069(/ d-pragma.)A
60 124 :M
1.044 .104(Since the number of casts in a program can be put to)J
60 134 :M
.293 .029(use in a qualimetry tool, the needless use of them \(or of)J
60 144 :M
.266(/)A
0 2 rm
.479(*)A
0 -2 rm
0 -2 rm
.518(~)A
0 2 rm
.479(OddCast)A
0 2 rm
.479(*)A
0 -2 rm
.722 .072(/, /)J
0 2 rm
.479(*)A
0 -2 rm
0 -2 rm
.518(~)A
0 2 rm
.474(PortableQM)A
0 2 rm
.479(*)A
0 -2 rm
1.536 .154(/ d-pragmas\) is also)J
60 154 :M
-.212(flagged.)A
60 169 :M
10 f5_1 :p
40 :m
.07(Functions)A
60 184 :M
.184 .018(Non-void functions should normally return named types)J
60 194 :M
-.007(\(problem-related names\), and so make use of the parallel)A
60 204 :M
3.809 .381(types facility. Yet some functions are 'utilities')J
60 214 :M
.641 .064(functions, that is there is no meaningful name for their)J
60 224 :M
.439 .044(returned type \(e.g. 'strcmp'\). The /)J
0 2 rm
.139(*)A
0 -2 rm
0 -2 rm
.15(~)A
0 2 rm
.104(Utility)A
0 2 rm
.139(*)A
0 -2 rm
.637 .064(/ d-pragma)J
60 234 :M
.809 .081(signals this.)J
60 249 :M
.37 .037(Also, the parallel type mechanism uses inheritance, and)J
60 259 :M
.446 .045(sometimes subtyping is needed. So the /)J
0 2 rm
.138(*)A
0 -2 rm
0 -2 rm
.149(~)A
0 2 rm
.125(Generic)A
0 2 rm
.138(*)A
0 -2 rm
.289 .029(/ d-)J
60 269 :M
.58 .058(pragma tells that the result of a such qualified function)J
60 279 :M
1.923 .192(is compatible with any visible \(cf /)J
0 2 rm
.665(*)A
0 -2 rm
0 -2 rm
.719(~)A
0 2 rm
.665(RootType)A
0 2 rm
.665(*)A
0 -2 rm
.812(/\))A
60 289 :M
1.102 .11(descendant of its return type. For a 'void )J
0 2 rm
.414(*)A
0 -2 rm
1.696 .17(' returning)J
60 299 :M
.29 .029(function, this d-pragma tells that its result is compatible)J
60 309 :M
.267 .027(with any pointer.)J
60 324 :M
2.507 .251(Functions formal pointer parameters that could be)J
60 334 :M
6.495 .65(qualified 'const' are signaled. Besides, the)J
60 344 :M
.396(/)A
0 2 rm
.712(*)A
0 -2 rm
0 -2 rm
.77(~)A
0 2 rm
2.811 .281(MayModify*/ d-pragma tells that, although its)J
60 354 :M
1.531 .153(formal parameters are marked const, a function may)J
60 364 :M
.574 .057(modify its environment through them, either via casted)J
60 374 :M
-.051(parameter or through pointer embedded in struct/unions.)A
60 389 :M
(The /)S
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
-.005(ResultPtr*/ d-pragma tells that a returned pointer)A
60 399 :M
.222 .022(is the same as the so-qualified parameter, this to be able)J
60 409 :M
.127 .013(to propagate the 'const' checking \(e.g. in 'strchr'\).)J
60 424 :M
1.021 .102(The /)J
0 2 rm
.368(*)A
0 -2 rm
0 -2 rm
.398(~)A
0 2 rm
1.472 .147(SizeOfMemBlk*/ d-pragma is intended to be)J
60 434 :M
3.503 .35(used with memory allocating functions, such as)J
60 444 :M
.896 .09('malloc', to allow verification that the argument of the)J
60 454 :M
.276 .028(possible sizeof used is of the same type as the receiving)J
60 464 :M
(pointer pointed type.)S
60 479 :M
6.806 .681(Others d-pragmas related to functions are)J
60 489 :M
.32(/)A
0 2 rm
.576(*)A
0 -2 rm
0 -2 rm
.623(~)A
0 2 rm
.531(ResultType)A
0 2 rm
.576(*)A
0 -2 rm
1.355 .135(/ \(cf 'Casts'\), /)J
0 2 rm
.576(*)A
0 -2 rm
0 -2 rm
.623(~)A
0 2 rm
.564(PseudoVoid)A
0 2 rm
.576(*)A
0 -2 rm
1.624 .162(/ and)J
60 499 :M
(/)S
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
.018(NeverReturns)A
0 2 rm
(*)S
0 -2 rm
.065 .007(/  \(see later, 'Miscelleanous'\); function)J
60 509 :M
-.046(parameters may also be marked /)A
0 2 rm
-.054(*)A
0 -2 rm
0 -2 rm
-.058(~)A
0 2 rm
-.055(NotUsed)A
0 2 rm
-.054(*)A
0 -2 rm
-.042(/  as well as)A
60 519 :M
.155(/)A
0 2 rm
.278(*)A
0 -2 rm
0 -2 rm
.301(~)A
0 2 rm
.208(Utility)A
0 2 rm
.278(*)A
0 -2 rm
.452 .045(/ \(do )J
13.489 :m
.237(not)A
.928 .093( accept an actual parameter whose)J
60 529 :M
.102 .01(type is a parallel type\).)J
60 544 :M
2.203 .22(As an extension, several formal parameters can be)J
60 554 :M
1.021 .102(qualified by /)J
0 2 rm
.325(*)A
0 -2 rm
0 -2 rm
.352(~)A
0 2 rm
.3(ResultType)A
0 2 rm
.325(*)A
0 -2 rm
.753 .075(/; then the type of one of)J
60 564 :M
.057 .006(the corresponding actual parameters must be higher than)J
60 574 :M
1.403 .14(all other corresponding actual parameters' types; that)J
60 584 :M
.215 .022(type is the result type of the function call.)J
60 599 :M
74 :m
.79 .079(Compilation units)J
60 614 :M
1.242 .124(One of the plagues of C is the lack of type-checking)J
60 624 :M
2.409 .241(between formal and actual parameters for external)J
60 634 :M
1.539 .154(functions, or more generally, between definition and)J
60 644 :M
2.275 .228(uses of external objets \(we will, for the following)J
60 654 :M
.422 .042(discussion, call "global" a block-level-0 object/function)J
60 664 :M
.767 .077(visible in only one compilation unit, and "external" an)J
60 674 :M
.145 .014(object/function visible from several compilation units\).)J
60 689 :M
.238 .024(Another problem is that the encapsulation of C modules)J
60 699 :M
2.606 .261(is usually very bad, because one of the tenets of)J
60 709 :M
1.724 .172(encapsulation is not respected: "anything that is not)J
60 719 :M
.727 .073(explicitly made visible must be hidden". In C, the rule)J
60 729 :M
.755 .076(is: "anything \(at block level 0\) not explicitly hidden is)J
60 739 :M
1.088 .109(visible"; this is because the 'static' keyword has to be)J
60 749 :M
.519 .052(explicitly used, instead of being the default option, and)J
60 759 :M
-.002(so is "often" \(the word is weak\) forgotten.)A
307 79 :M
.704 .07(Something also confusing to many programmers is the)J
307 89 :M
.304 .03(difference between declarations and definitions, and the)J
307 99 :M
.631 .063(uniqueness of definitions. This is because, for C, some)J
307 109 :M
.03 .003(declarations are also definitions \("tentative definitions"\);)J
307 119 :M
2.791 .279(also, a number of compilers/linkers allow several)J
307 129 :M
-.02(definitions for the same external object.)A
307 144 :M
1.248 .125(Disciplined C solves these problems in the following)J
307 154 :M
2.789 .279(way: any object/function/type identifier has to be)J
307 164 :M
1.941 .194(declared \(just once\) before use; any object/function)J
307 174 :M
.324 .032(defined at block level 0 as not 'static' has to be declared)J
307 184 :M
.188 .019(in a header file; there must be one "header" file for each)J
307 194 :M
-.039("body" file defining external objects/functions.)A
307 209 :M
-.007(A header file is constrained to contain only \(besides type)A
307 219 :M
-.007(and macro definitions\) external declarations, which must)A
307 229 :M
.318 .032(make use of the 'extern' keyword. A definition must not)J
307 239 :M
-.01(make use of this keyword.)A
307 254 :M
.035 .003(This provides the following benefits:)J
307 269 :M
(-)S
316 269 :M
1.229 .123(programmers are warned if they have forgotten the)J
316 279 :M
-.043('static' keyword,)A
307 294 :M
(-)S
316 294 :M
.74 .074(for really external objects/functions, since they must)J
316 304 :M
.119 .012(be declared in \(common\) header file\(s\), type checking)J
316 314 :M
-.006(between compilation units is secured,)A
307 329 :M
(-)S
316 329 :M
5.436 .544(an external object definition \(and possible)J
316 339 :M
1.022 .102(initialization\) is easier to find: it can only be in the)J
316 349 :M
-.097(corresponding "body" file\),)A
307 364 :M
(-)S
316 364 :M
1.131 .113(the difference between declaration and definition is)J
316 374 :M
-.237(made clearer.)A
307 389 :M
1.445 .145(To cater for module composition, the restriction that)J
307 399 :M
4.399 .44(there be only one declaration for an external)J
307 409 :M
1.142 .114(object/function is relaxed; but, in a given header file,)J
307 419 :M
1.897 .19(only one declaration for a given object/ function is)J
307 429 :M
.827 .083(allowed; the possible constraints \(qualifiers, array size)J
307 439 :M
1.705 .171(etc\) have to keep constant or increasing in order of)J
307 449 :M
-.034(inclusion of header files.)A
307 464 :M
.797 .08(Finally, the scope of any global object/type/tag can be)J
307 474 :M
.163 .016(terminated before the end of the compilation unit by use)J
307 484 :M
-.053(of the /)A
0 2 rm
-.075(*)A
0 -2 rm
0 -2 rm
-.081(~)A
0 2 rm
-.065(Undef\(Tag\) <identList> )A
0 2 rm
-.075(*)A
0 -2 rm
-.069(/ d-pragma.)A
307 499 :M
95.001 :m
-.079(Inclusion of header files)A
307 514 :M
.088 .009(Header files are often included at the wrong level. They,)J
307 524 :M
.224 .022(most of the time, should be included at least at the body)J
307 534 :M
1.062 .106(file level \(and at the beginning of it\), so that all used)J
307 544 :M
.291 .029(services are easy to spot. If they are not included at that)J
307 554 :M
1.027 .103(level \(and one of the functions/objects they declare is)J
307 564 :M
-.02(used\), a warning is issued.)A
307 579 :M
-.057(To cater to "composed" header files \(header files offering)A
307 589 :M
2.779 .278(services including other service\(s\)\), the /)J
0 2 rm
.794(*)A
0 -2 rm
0 -2 rm
.859(~)A
0 2 rm
1.206(Com-)A
307 599 :M
.157(posingHdr)A
0 2 rm
.167(*)A
0 -2 rm
.514 .051(/ d-pragma is supplied. For example, if one)J
307 609 :M
1.282 .128(wants to provide a <superMath.h> service, giving all)J
307 619 :M
.972 .097(services of <math.h> plus some others such as Bessel)J
307 629 :M
2.367 .237(and Jacobi functions, one will write the following)J
307 639 :M
.264 .026(<superMath.h> header file\312:)J
307 654 :M
f7_9 sf
-.41(#include <math.h> /*~ComposingHdr*/)A
307 669 :M
-.413(extern double bessel\( ... \);)A
307 679 :M
-.413(extern double jacobi\( ... \);)A
307 694 :M
f1_10 sf
1.582 .158(and then no warning will be incurred in a body file)J
307 704 :M
1.202 .12(including only <superMath.h>, and yet using 'sin' \(or)J
307 714 :M
.212 .021(any other <math.h> function/object\).)J
307 729 :M
56 :m
-.054(Encapsulation)A
307 744 :M
.307 .031(To still improve encapsulation, structures/unions/enums)J
307 754 :M
2.921 .292(declared in header files may be qualified by the)J
307 764 :M
.25(/)A
0 2 rm
.45(*)A
0 -2 rm
0 -2 rm
.486(~)A
0 2 rm
1.823 .182(PrivateTo <files list>)J
0 2 rm
.45(*)A
0 -2 rm
1.747 .175(/ d-pragma, which renders)J
307 774 :M
1.415 .141(their member's names invisible, except from macros/)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(YN; page: 5 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(5)S
60 74 :M
-.007(functions defined in the indicated files. So a type may be)A
60 84 :M
-.016(exported without its components being disclosed.)A
307 74 :M
f0_10 sf
.586(D-Pragmas)A
307 89 :M
f1_10 sf
.217 .022(As seen previously, Disciplined C often needs advice or)J
307 99 :M
.661 .066(information, to be conveyed by pragmas. But it cannot)J
307 109 :M
.099 .01(use the pragma facility of C, for two reasons:)J
307 124 :M
(-)S
316 124 :M
.531 .053(there might be an ambiguity with an already existing)J
316 134 :M
1.81 .181(local pragma, or a compiler might warn about an)J
316 144 :M
-.014(unknown pragma,)A
307 159 :M
(-)S
316 159 :M
1.882 .188(more significantly, C pragmas can only be at the)J
316 169 :M
.127 .013(beginning of a \(logical\) line.)J
307 184 :M
.126 .013(For those reasons, it was decided to define "d-pragmas",)J
307 194 :M
1.146 .115(and to make them look as comments, hoping that the)J
307 204 :M
.398('/)A
0 2 rm
.869(*)A
0 -2 rm
0 -2 rm
.939(~)A
0 2 rm
2.479 .248(' prefix does not happen too often in existing)J
307 214 :M
-.033(programs.)A
307 239 :M
f0_10 sf
.835(Miscelleanous)A
307 254 :M
f1_10 sf
.428 .043(Many other improvements of C have been incorporated)J
307 264 :M
2.507 .251(in Disciplined C \(and are verified by the checker)J
307 274 :M
-.122(program\):)A
307 289 :M
(-)S
316 289 :M
1.919 .192('if', 'else', loop operators: if they are followed by)J
316 299 :M
1.138 .114(several statements on the same \(physical\) line, it is)J
316 309 :M
1.705 .17(asked whether all these statements are part of the)J
316 319 :M
.25 .025('if'/'else' arm, or loop body,)J
307 334 :M
(-)S
316 334 :M
2.284 .228(as an option, line indentation is checked against)J
316 344 :M
1.158 .116(current block level; this makes it possible to detect)J
316 354 :M
.06 .006(early missing left/right braces, or bad 'if'/loop bodies,)J
307 369 :M
(-)S
316 369 :M
.555 .055(declarations have to be separated from statements by)J
316 379 :M
1.307 .131(white line\(s\), except if the first statement is empty)J
316 389 :M
.021(\(";;"\),)A
307 404 :M
(-)S
316 404 :M
.211 .021(only 'void' type expressions can be used as statements)J
316 414 :M
.805 .081(\(or as first argument of the comma operator, or first)J
316 424 :M
1.381 .138(and third arguments of the 'for' operator\), the only)J
316 434 :M
.108 .011(exceptions being the following:)J
319 449 :M
<A5>S
328 449 :M
.396 .04(expression whose top operator is an assignment or)J
328 459 :M
-.072(increment operator,)A
319 474 :M
<A5>S
328 474 :M
2.814 .281(functions marked as /)J
0 2 rm
.836(*)A
0 -2 rm
0 -2 rm
.905(~)A
0 2 rm
.818(PseudoVoid)A
0 2 rm
.836(*)A
0 -2 rm
2.759 .276(/ \(only)J
328 484 :M
-.022(functions whose main effect is a side effect, such as)A
328 494 :M
.051 .005('printf' or 'strcpy', should be so marked\).)J
316 509 :M
.448 .045(This way, probable errors such as ")J
f7_9 sf
.163(fct;)A
f1_10 sf
.463 .046(" \(instead of)J
316 519 :M
.121(")A
f7_9 sf
.16(fct\(\);)A
f1_10 sf
.289 .029("\), or ")J
f7_9 sf
.16(a[i,j])A
f1_10 sf
.367 .037(" \(instead of ")J
f7_9 sf
.16(a[i][j])A
f1_10 sf
.437 .044("\) are)J
316 529 :M
.829 .083(located. Also, it encourages programmers to test the)J
316 539 :M
.828 .083(value returned by I/O functions \('scanf', 'fputc', etc\),)J
316 549 :M
-.019(so as to detect I/O errors,)A
307 564 :M
(-)S
316 564 :M
.399 .04(a non-void function must terminate in all cases either)J
316 574 :M
.418 .042(via a 'return exp', whose type is \(a descendant of\) the)J
316 584 :M
.12 .012(type of the function, or via a call to a function marked)J
316 594 :M
.147 .015(as /)J
0 2 rm
.076(*)A
0 -2 rm
0 -2 rm
.082(~)A
0 2 rm
.07(NeverReturns)A
0 2 rm
.076(*)A
0 -2 rm
.184 .018(/ \(such as 'exit' or 'abort'\); to that)J
316 604 :M
1.932 .193(end, a simple control flow analysis is performed,)J
316 614 :M
-.056(which also detects unreachable statements,)A
307 629 :M
(-)S
316 629 :M
1.337 .134(since Disciplined C is only aimed at ANSI C with)J
316 639 :M
.978 .098("new-style" functions, a function with no parameter)J
316 649 :M
-.093(can be declared/defined as f\( \)  \(no 'void' keyword\), and)A
316 659 :M
-.03(still be considered only as a parameterless function,)A
307 674 :M
(-)S
316 674 :M
.569 .057(if a parameter name is given in a function prototype,)J
316 684 :M
1.205 .12(the same name must be used for the corresponding)J
316 694 :M
1.448 .145(parameter in the function definition, this to ensure)J
316 704 :M
.312 .031(that the meaning of the prototype is/stays the same as)J
316 714 :M
.364 .036(the implementation,)J
307 729 :M
(-)S
316 729 :M
.4 .04(a function name is not a pointer on that function, and)J
316 739 :M
-.024(pointers on functions are to be dereferenced before use)A
316 749 :M
-.035(\(for the sake of regularity\),)A
307 764 :M
(-)S
316 764 :M
.476 .048(switches: the 'switch' statement must control a block;)J
316 774 :M
.402 .04(a missing break is flagged, unless a /)J
0 2 rm
.148(*)A
0 -2 rm
0 -2 rm
.16(~)A
0 2 rm
.153(NoBreak)A
0 2 rm
.148(*)A
0 -2 rm
.31 .031(/ d-)J
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(YN; page: 6 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(6)S
69 74 :M
1.124 .112(pragma has been used; a 'default' case \(which must)J
69 84 :M
.885 .089(come at the end of the switch\) is expected, unless a)J
69 94 :M
.271(/)A
0 2 rm
.487(*)A
0 -2 rm
0 -2 rm
.527(~)A
0 2 rm
.457(NoDefault)A
0 2 rm
.487(*)A
0 -2 rm
1.294 .129(/ d-pragma has been used or, if the)J
69 104 :M
.211 .021(switch expression is of enum type, all enum constants)J
69 114 :M
2.412 .241(of that type have been used as case values; the)J
69 124 :M
(/)S
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
(FullEnum)S
0 2 rm
(*)S
0 -2 rm
-.002(/ d-pragma can be used to get a warning)A
69 134 :M
.649 .065(if not all \(distinct-valued\) constants of a given enum)J
69 144 :M
.419 .042(are used as cases values, and a default case \(to catch,)J
69 154 :M
-.019(for example, spurious values\) has been used,)A
60 169 :M
(-)S
69 169 :M
1.508 .151(in an effort to clarify the distinction between type)J
69 179 :M
2.975 .298(attribute \('extern'... 'register'\) and type qualifier)J
69 189 :M
.995 .099(\('const', 'volatile'\), the qualifier must lexically come)J
69 199 :M
-.018(after the attribute,)A
60 214 :M
(-)S
69 214 :M
1.947 .195('const'/'volatile' qualifiers are strictly obeyed \(and)J
69 224 :M
-.026(literal strings considered as  )A
10 f5_1 :p
20.959 :m
-.029(const)A
-.025( char [ ] !\),)A
60 239 :M
(-)S
69 239 :M
.118 .012(there is a warning if objects modified within the reach)J
69 249 :M
2.591 .259(of a setjmp\(\312\)/ longjmp\(\312\) pair are not qualified)J
69 259 :M
.091('volatile',)A
60 274 :M
(-)S
69 274 :M
2.828 .283(pointers on local objects cannot be returned or)J
69 284 :M
2.807 .281(assigned to global/external variables, unless the)J
69 294 :M
.241(/)A
0 2 rm
.433(*)A
0 -2 rm
0 -2 rm
.469(~)A
0 2 rm
.415(LocalAdr)A
0 2 rm
.433(*)A
0 -2 rm
1.178 .118(/ d-pragma is used \(this check is not)J
69 304 :M
4.366 .437(perfectly foolproof, however, because of the)J
69 314 :M
.362 .036(possibility of pointers on pointers\),)J
60 329 :M
(-)S
69 329 :M
.904 .09(except inside array and enum initialization, numeric)J
69 339 :M
-.029(constants \(barring -1, 0, 1\) must be named \('#define'd\);)A
69 349 :M
4.155 .415(this forces much semantic to flow from the)J
69 359 :M
2.695 .27(programmer's mind to the program\312! There is a)J
69 369 :M
2.573 .257(special case for array bound expressions, where)J
69 379 :M
5.998 .6(unnamed constants cause warning only if)J
69 389 :M
1.111 .111(\(subsequently\) a non constant expression is used to)J
69 399 :M
-.098(index the array.)A
69 414 :M
1.274 .127(Since this constraint sometimes proves clumsy, the)J
69 424 :M
.239 .024(following alleviates it:)J
72 439 :M
<A5>S
81 439 :M
-.069(parenthesized unnamed constants can be used inside)A
81 449 :M
-.062(macros,)A
72 464 :M
<A5>S
81 464 :M
1.923 .192(if a \(numeric\) parallel type is qualified by the)J
81 474 :M
.587(/)A
0 2 rm
1.056(*)A
0 -2 rm
0 -2 rm
1.142(~)A
0 2 rm
.845(LiteralCst)A
0 2 rm
1.056(*)A
0 -2 rm
3.637 .364(/ d-pragma, use of unnamed)J
81 484 :M
.811 .081(constants inside expressions of this type does not)J
81 494 :M
.143 .014(elicit warnings,)J
60 509 :M
(-)S
69 509 :M
2.334 .233(underflows/overflows in constant expressions are)J
69 519 :M
-.351(detected,)A
60 534 :M
(-)S
69 534 :M
2.757 .276(in the 'scanf'/'printf' family, argument types are)J
69 544 :M
-.045(checked against \(constant\) format string specifications,)A
60 559 :M
(-)S
69 559 :M
-.035(unclosed comments are flagged \(detection of '/)A
0 2 rm
(*)S
0 -2 rm
-.035(' inside)A
69 569 :M
(a comment\),)S
60 584 :M
(-)S
69 584 :M
.212 .021(labels and tags must obey the rule of other identifiers,)J
69 594 :M
3.065 .307(that is disappear outside the defining block or)J
69 604 :M
1.193 .119(structure/union; but, to stay compatible with C, the)J
69 614 :M
.042 .004(same label cannot be defined in different blocks of the)J
69 624 :M
-.02(same function body,)A
60 639 :M
(-)S
69 639 :M
1.539 .154(backward branches, which may cause unstructured)J
69 649 :M
.448 .045(loops, must be documented via the /)J
0 2 rm
.148(*)A
0 -2 rm
0 -2 rm
.16(~)A
0 2 rm
.146(BackBranch)A
0 2 rm
.148(*)A
0 -2 rm
(/)S
69 659 :M
-.226(d-pragma,)A
60 674 :M
(-)S
69 674 :M
.569 .057(unless the /)J
0 2 rm
.202(*)A
0 -2 rm
0 -2 rm
.219(~)A
0 2 rm
.18(DynInit)A
0 2 rm
.202(*)A
0 -2 rm
.693 .069(/ d-pragma is used, non-static)J
69 684 :M
-.028(structure/array initializations are flagged \(because they)A
69 694 :M
-.032(slow down function entry and waste memory\),)A
60 709 :M
(-)S
69 709 :M
.321 .032(external identifiers are checked for non ambiguity for)J
69 719 :M
.146 .015(the local linker,)J
60 734 :M
(-)S
69 734 :M
2.106 .211(tests for an unsigned quantity to be negative are)J
69 744 :M
-.212(flagged,)A
307 79 :M
(-)S
316 79 :M
.428 .043(constant boolean expressions \(used elsewhere than in)J
316 89 :M
2.44 .244(an assignment, and outside macros\) are flagged,)J
316 99 :M
-.043(because they probably signal a coding error,)A
307 114 :M
(-)S
316 114 :M
2.26 .226(parenthesization problems with macro bodies are)J
316 124 :M
3.34 .334(detected \(for example )J
f7_9 sf
1.046(Diff\(a,b+c\))A
0 1 rm
1.046(*)A
0 -1 rm
1.046(d)A
f1_10 sf
2.941 .294(, with)J
316 134 :M
f7_9 sf
-.221(Diff\(x,y\))A
f1_10 sf
-.153(  defined as ")A
f7_9 sf
-.221(x-y)A
f1_10 sf
-.16(" and not ")A
f7_9 sf
-.221(\(\(x\)-\(y\)\))A
f1_10 sf
-.169(" \),)A
307 149 :M
(-)S
316 149 :M
-.015(side effects via macro parameters used more than once)A
316 159 :M
-.199(are flagged,)A
307 174 :M
(-)S
316 174 :M
1.941 .194(unless qualified by the /)J
0 2 rm
.66(*)A
0 -2 rm
0 -2 rm
.714(~)A
0 2 rm
.671(NotUsed)A
0 2 rm
.66(*)A
0 -2 rm
3.043 .304(/ d-pragma,)J
316 184 :M
-.089(unused identifiers/objects are signaled,)A
307 199 :M
(-)S
316 199 :M
-.062(uninitialized local objects are flagged,)A
307 214 :M
(-)S
316 214 :M
-.056(unused variable values are signalled \(an only  modified)A
316 224 :M
-.015(object, e.g.  )A
f7_9 sf
-.023(i++)A
f7_10 sf
-.026( ,)A
f1_10 sf
-.017( is not considered as used\),)A
307 239 :M
(-)S
316 239 :M
.227 .023(an attempt to detect potentially dangerous side effects)J
316 249 :M
1.966 .197(has been unsuccessful; for, if it is easy to detect)J
316 259 :M
.451(")A
f7_9 sf
1.987 .199(a[i++] = i)J
f1_10 sf
1.207 .121(", it is harder to detect ")J
f7_9 sf
2.805 .281(a[i++] =)J
316 270 :M
-.127(*)A
0 -1 rm
-.127(\(&i\))A
0 1 rm
f1_10 sf
0 -1 rm
-.094(", and much harder to detect ")A
0 1 rm
f7_9 sf
0 -1 rm
-.127(a = f\(\) + g\(\))A
0 1 rm
f1_10 sf
0 -1 rm
-.155(",)A
0 1 rm
316 279 :M
-.02(where each \(external\) function f and g depends on side)A
316 289 :M
-.019(effects of the other function.)A
307 314 :M
f0_10 sf
4.849 .485(Compile-time checking tool)J
307 329 :M
f1_10 sf
1.868 .187(A d-pragma, /)J
0 2 rm
.552(*)A
0 -2 rm
0 -2 rm
.597(~)A
0 2 rm
.388(zif)A
0 -3 rm
.251 .025( )J
0 3 rm
3.622 .362(<boolExp> "<msgString>")J
0 2 rm
.552(*)A
0 -2 rm
.307(/)A
0 2 rm
.251 .025( )J
0 -2 rm
.736(is)A
307 339 :M
2.85 .285(provided, that causes emission of <msgString> if)J
307 349 :M
3.478 .348(<boolExp> is true. It is the main tool \(besides)J
307 359 :M
.921 .092("information" types and the fact that integer constants)J
307 369 :M
-.008(must be named\) that allows a programmer to indicate his)A
307 379 :M
1.915 .192(constraints \(for example, that a quantity should not)J
307 389 :M
-.022(exceed a certain value, or that a structure member should)A
307 399 :M
1.615 .161(be placed at such a position\). <boolExp> must be a)J
307 409 :M
.883 .088(constant expression, but can contain 'sizeof' operators,)J
307 419 :M
.16 .016(enum constants, casts, and also the following functions:)J
307 434 :M
(-)S
316 434 :M
2.273 .227(_ )J
-100 -100 :M
2.5 .25( )J
325 434 :M
1.057 .106(_member\(<membName>\): only to be used during)J
316 444 :M
.161 .016(structure/union initialization; answers true if currently)J
316 454 :M
2.608 .261(initializing the member whose name is <memb-)J
316 464 :M
2.53 .253(Name>, or at end of the structure/union \(empty)J
316 474 :M
(<membName>\),)S
307 489 :M
(-)S
316 489 :M
1.364 .136(_ )J
-100 -100 :M
1.5 .15( )J
324 489 :M
.725 .072(_extent\(<enumType>\): answers the "extent" of the)J
316 499 :M
.162 .016(enumType, i.e. the distance between its greatest enum)J
316 509 :M
.221 .022(constant and its smallest one \(type: 'int'\),)J
307 524 :M
(-)S
316 524 :M
.454 .045(_ )J
-100 -100 :M
.5 .05( )J
323 524 :M
.245 .025(_index\( \): only to be used inside array initialization;)J
316 534 :M
.662 .066(answers the index value of the current array element)J
316 544 :M
-.011(being initialized \(type = type of the bound\),)A
307 559 :M
(-)S
316 559 :M
.454 .045(_ )J
-100 -100 :M
.5 .05( )J
323 559 :M
.271 .027(_sametype\(x, y\): 'x'/'y' may be types or expressions;)J
316 569 :M
.635 .063(answers true if both \(expression\) types are the same.)J
316 579 :M
-.051(The type equivalence used is the same as for parameter)A
316 589 :M
1.394 .139(passing \(x: formal parameter, y: actual parameter\).)J
316 599 :M
.518 .052(This function can for example be used to type macro)J
316 609 :M
-.136(parameters.)A
307 624 :M
2.305 .231(The 'defined' function is also accepted. Of course,)J
307 634 :M
-.088(undefined identifiers are flagged \(not replaced by 0L\312!\).)A
307 649 :M
2.237 .224(This d-pragma permits a program to be much less)J
307 659 :M
.682 .068(fragile, by allowing one to build into it mechanisms to)J
307 669 :M
-.069(check at compile-time that related data structures are kept)A
307 679 :M
.66 .066(coherent through modifications; for example, it is easy)J
307 689 :M
.545 .055(to check that the length of parallel arrays are the same,)J
307 699 :M
.786 .079(or that the length of an array is the same as the extent)J
307 709 :M
1.193 .119(\(+1\) of an enum used to name its elements, or that a)J
307 719 :M
1.12 .112(structure member/array element is initialized with the)J
307 729 :M
.219 .022(right value.)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(YN; page: 7 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(7)S
60 74 :M
f0_10 sf
3.019 .302(Some words about the Disciplined C checker)J
60 89 :M
f1_10 sf
.659 .066("dcc", the C-checker, performs full syntactic and some)J
60 99 :M
4.46 .446(static semantic analysis of a C program, one)J
60 109 :M
2.885 .288(compilation unit at a time. It is itself written in)J
60 119 :M
.685 .069(Disciplined C, is approximately 15000 lines long, uses)J
60 129 :M
.106 .011(a recursive descent method, and is about ten times faster)J
60 139 :M
2.831 .283(that the 'gcc' C compiler \(on a DECstation 5000)J
60 149 :M
.342 .034(running ULTRIX\); so error detection is quite swift, and)J
60 159 :M
.239 .024(only a small time cost is added to regular compilation if)J
60 169 :M
-.023(the program is correct.)A
60 184 :M
2.616 .262(Unless the '-zcc' option has been used, control is)J
60 194 :M
.154 .015(automatically transfered to the local compiler if no error)J
60 204 :M
.098 .01(is detected \(the philosophy of dcc, as of any C compiler,)J
60 214 :M
-.009(is to issue errors only when the standard is violated\).)A
60 229 :M
1.383 .138(The '+zsy' option permits one to have, at each block)J
60 239 :M
.178 .018(exit, the content of the symbol table for those identifiers)J
60 249 :M
.756 .076(local to the block; their kind, type \(fully decoded\) and)J
60 259 :M
.404 .04(size \(for objects\) are given, this last information so that)J
60 269 :M
1.302 .13(programmers have an idea of the amount of memory)J
60 279 :M
.023 .002(their program uses.)J
60 294 :M
1.137 .114(Numerous other options are available, for example to)J
60 304 :M
.208 .021(limit dcc's scrutiny.)J
60 319 :M
-.007(All error/warning messages can be adapted at will, being)A
60 329 :M
2.038 .204(gathered in one single source file. In addition to a)J
60 339 :M
1.25 .125(message, one is given: the number of the source line)J
60 349 :M
.39 .039(where the error/warning has been detected, the name of)J
60 359 :M
.302 .03(the corresponding file, the preceding and current source)J
60 369 :M
.257 .026(line text, and a caret showing the precise position of the)J
60 379 :M
.93 .093(error/warning in the source line. An option causes the)J
60 389 :M
.153 .015(printing in clear of the last processed tokens \(sometimes)J
60 399 :M
-.105(very handy !\).)A
60 414 :M
2.379 .238(Three levels of warnings, corresponding to benign)J
60 424 :M
1.966 .197(\(mostly readibility\), serious, quasi-certain error, are)J
60 434 :M
.848 .085(implemented; a screening mechanism \(desactivated by)J
60 444 :M
2.347 .235(some options, e.g. '-zcc'\) prevents a warning from)J
60 454 :M
1.224 .122(showing up if its level is lower that the last message)J
60 464 :M
1.48 .148(level. In the same vein, unless option '+zae' is used,)J
60 474 :M
1.146 .115(messages are not repeated if they pertain to the same)J
60 484 :M
-.141(cause.)A
60 499 :M
2.209 .221(There is a way to adjust local system header files)J
60 509 :M
1.283 .128(\(without modifying them\), mainly in order to change)J
60 519 :M
1.39 .139(some library functions return types \(such as 'getc' or)J
60 529 :M
.952 .095('isalpha'\), to define NULL as )J
f7_9 sf
1.307 .131(\(void )J
0 1 rm
.349(*)A
0 -1 rm
.349(\)0)A
f1_10 sf
.735 .073(, or to mark)J
60 539 :M
-.031(functions as /)A
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
-.039(PseudoVoid)A
0 2 rm
(*)S
0 -2 rm
-.025(/ or /)A
0 2 rm
(*)S
0 -2 rm
0 -2 rm
(~)S
0 2 rm
-.037(NeverReturns)A
0 2 rm
(*)S
0 -2 rm
(/.)S
60 554 :M
1.08 .108(A symbol, '_ )J
-100 -100 :M
1.5 .15( )J
117 554 :M
.428 .043(_dcc', is defined by the checker; it can be)J
60 564 :M
.74 .074(used to turn off its scrutiny in selected areas of source)J
60 574 :M
2.027 .203(code \(besides the /)J
0 2 rm
.67(*)A
0 -2 rm
0 -2 rm
.725(~)A
0 2 rm
.769(NoWarn)A
0 2 rm
.67(*)A
0 -2 rm
1.24 .124(/ and /)J
0 2 rm
.67(*)A
0 -2 rm
0 -2 rm
.725(~)A
0 2 rm
.744(Warn)A
0 2 rm
.67(*)A
0 -2 rm
1.402 .14(/ d-)J
60 584 :M
-.087(pragmas\).)A
60 599 :M
.34 .034(This program, developed on a VAX/VMS machine, has)J
60 609 :M
1.472 .147(been ported in less than a day on a HP715/UNIX, a)J
60 619 :M
.168 .017(DECstation 5000/ULTRIX and an ALPHA 3000/OSF1.)J
60 634 :M
1.093 .109(It is available via anonymous ftp at 'ftp.supelec.fr', in)J
60 644 :M
-.071(the sub-directory 'pub/lang/dcc'.)A
60 669 :M
f0_10 sf
.913(Conclusion)A
60 684 :M
f1_10 sf
1.159 .116(The ambition of Disciplined C is to be a really high-)J
60 694 :M
-.023(level programming language, with all the confidence and)A
60 704 :M
-.014(ease of use the term "high-level" should convey.)A
60 719 :M
.384 .038(The first idea behind it is that programmers ought to be)J
60 729 :M
1.826 .183(given a tool permitting to render the semantics and)J
60 739 :M
.757 .076(constraints of their programs more apparent, while not)J
60 749 :M
.987 .099(hampering or restraining their creativity, nor inducing)J
60 759 :M
-.007(any run-time loss of efficiency.)A
307 79 :M
.397 .04(Another idea is that a tool should serve its user, instead)J
307 89 :M
3.487 .349(of randomly disseminating traps in his way; so)J
307 99 :M
.146 .015(everything that seems "strange" is flagged. But there are)J
307 109 :M
.655 .065(ways \(via d-pragmas\) to tell that a generally erroneous)J
307 119 :M
.071 .007(situation is perfectly valid in this specific case.)J
307 134 :M
.397 .04(A third idea is that a tool should exhibit clear concepts,)J
307 144 :M
.427 .043(so that the user can easily master it; the last idea is that)J
307 154 :M
2.27 .227(error messages should be indicative enough to put)J
307 164 :M
2.311 .231(programmers back on the right track, and the less)J
307 174 :M
.022 .002(numerous possible \(don't detect twice the same error; try)J
307 184 :M
-.066(to avoid induced errors...\).)A
307 199 :M
.866 .087(Those ideas have been in the mind of the author for a)J
307 209 :M
.504 .05(long time )J
f2_10 sf
.124([)A
f1_10 sf
.796 .08(NOY 88)J
f2_10 sf
.124(])A
f1_10 sf
.446 .045(, but it took him about ten years to)J
307 219 :M
1.118 .112(realize that, instead of regularly complaining about C)J
307 229 :M
-.017(weaknesses and pitfalls, it would be better \(and possible\))A
307 239 :M
1.085 .109(to write a program that reports most of the problems,)J
307 249 :M
1.281 .128(and so, last but not least, facilitate the teaching of C)J
307 259 :M
1.659 .166(with due regard to good programming practices and)J
307 269 :M
-.011(conceptual purity.)A
307 284 :M
1.627 .163(The C standard library is another place where some)J
307 294 :M
.304 .03(improvements could be brought: for example, the string)J
307 304 :M
.71 .071(handling function 'strcpy' could return a pointer on the)J
307 314 :M
.305 .031(ending NUL character, and give an easy way to prevent)J
307 324 :M
.813 .081(buffer overflow; or there could exist a function telling)J
307 334 :M
.488 .049(whether a pointer points on a 'free'able area. But this is)J
307 344 :M
.006 .001(unfortunately out of the reach of Disciplined C.)J
307 359 :M
.724 .072(I am much indebted to my colleagues of our computer)J
307 369 :M
.613 .061(science department, with whom discussions were often)J
307 379 :M
2.046 .205(illuminating \(and animated !\). Special thanks to C.)J
307 389 :M
1.078 .108(Bocage, F. Boulanger, D. Marcadet and F. Mullet for)J
307 399 :M
.054 .005(their advice and patience. Also to W. Briscoe \(freelance,)J
307 409 :M
-.036(UK\), for numerous comments/advices.)A
307 449 :M
f0_10 sf
.597(References)A
307 469 :M
f1_10 sf
.104 .01([K&R 88])J
357 469 :M
.037 .004(B.W. Kernighan and D.M. Ritchie)J
357 479 :M
f3_10 sf
-.051(The C Programming Language)A
357 489 :M
f1_10 sf
.273 .027(Prentice Hall, Englewood Cliffs, N.J.,)J
357 499 :M
(1988)S
307 519 :M
-.069([MOD 91])A
357 519 :M
.768 .077(R.P. Mody)J
357 529 :M
f3_10 sf
-.094(C In Education and Software Engineering)A
357 539 :M
f1_10 sf
.364 .036(SIGCSE Bulletin, Vol 23 n)J
cF
f2_10 sf
.036<B0>A
sf
.364 .036( 3,)J
357 549 :M
.172 .017(September 1991, pp 45-56)J
307 569 :M
-.116([NOY 88])A
357 569 :M
.247 .025(Y.L. Noyelle)J
357 579 :M
f3_10 sf
.173 .017(La Saga du LSE \(et de ses cousins LSD/)J
357 589 :M
.428(LSG/LST\))A
357 599 :M
f1_10 sf
-.037(Colloque sur l'histoire de l'Informatique en)A
357 609 :M
.281 .028(France, Vol 2, May 1988, pp 301-310)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(YN; page: 8 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(8)S
268 75 :M
-.017(APPENDIX A)A
232 97 :M
-.03(Disciplined C grammar  \(LL\(2\) \))A
60 121 :M
(prog ::=)S
130 121 :M
-.242(decl)A
0 -3 rm
(+)S
0 3 rm
60 133 :M
-.193(decl ::=)A
130 133 :M
-.141(attrib? decl1)A
60 145 :M
.107 .011(attrib ::=)J
130 145 :M
10 f5_1 :p
24.983 :m
(extern)S
( )S
2 :m
(|)S
( )S
21.101 :m
(static)S
( )S
2 :m
(|)S
( )S
17.217 :m
(auto)S
( )S
2 :m
(|)S
( )S
29.926 :m
-.006(register)A
( )S
2 :m
(|)S
( )S
29.931 :m
-.009(typedef)A
290 145 :M
-.028(-- auto/register allowed only inside function.)A
60 157 :M
-.169(decl1 ::=)A
130 157 :M
-.281(decl2 decl3)A
180 157 :M
-.063(-- 'modifier' \(called by 'decl2'\) must declare an identifier; exceptions: 'attrib' )A
cF
f2_10 sf
-.063<B9>A
sf
-.063( typedef,)A
190 169 :M
-.017(and bit-field \(if no identifier => padding\), or 'strun'/'enum' with both 'tag' and)A
190 181 :M
.16 .016('member's/'enumElt's \(in such a case, 'modifier' must be empty\).)J
60 193 :M
-.169(decl2 ::=)A
130 193 :M
-.149(qualif? baseType qualif? modifier)A
280 193 :M
-.011(-- only one qualif.)A
60 205 :M
-.113(qualif ::=)A
130 205 :M
3.38 :m
.052([)A
( )S
21.437 :m
.066(const)A
( )S
2 :m
(|)S
( )S
30.461 :m
.059(volatile)A
( )S
3.38 :m
.052(])A
f1_9 sf
0 -3 rm
(+)S
0 3 rm
220 205 :M
f1_10 sf
.125 .013(-- one of each at most; volatile incompatible with register.)J
60 217 :M
-.092(baseType ::=)A
130 217 :M
-.074(nativeType? )A
2 :m
(|)S
220 217 :M
-.044(-- may only be omitted in case of \(field\) padding.)A
130 229 :M
19 :m
-.249(ident)A
220 229 :M
-.059(-- "type" identifier.)A
60 241 :M
-.052(nativeType ::=)A
130 241 :M
17.557 :m
-.055(void)A
( )S
2 :m
(|)S
180 241 :M
.07 .007(-- only if function or pointer declaration; then 'qualif' must be empty.)J
130 253 :M
18.438 :m
.023(float)A
( )S
2 :m
(|)S
( )S
3.328 :m
([)S
( )S
17.89 :m
.028(long)A
( )S
3.328 :m
(])S
(? )S
27.388 :m
.029(double)A
( )S
2 :m
(|)S
130 265 :M
3.384 :m
.056([)A
( )S
36.716 :m
.076(unsigned)A
( )S
2 :m
(|)S
( )S
26.547 :m
.074(signed)A
( )S
3.384 :m
.056(])A
.098 .01(? )J
3.384 :m
.056([)A
( )S
17.495 :m
.073(char)A
( )S
2 :m
(|)S
( )S
20.333 :m
.068(short)A
( )S
3.384 :m
.056([)A
( )S
10.735 :m
.059(int)A
( )S
3.384 :m
.056(])A
.098 .01(? )J
2 :m
(|)S
( )S
10.735 :m
.059(int)A
( )S
2 :m
(|)S
( )S
18.079 :m
.075(long)A
( )S
3.384 :m
.056([)A
( )S
10.735 :m
.059(int)A
( )S
3.384 :m
.056(])A
.098 .01(? )J
3.384 :m
.056(])A
( )S
2 :m
(|)S
130 277 :M
.29 .029(strun )J
2 :m
(|)S
130 289 :M
-.072(enum)A
60 301 :M
.171 .017(strun ::=)J
130 301 :M
3.328 :m
([)S
( )S
22.212 :m
(struct)S
( )S
2 :m
(|)S
( )S
22.778 :m
(union)S
( )S
3.328 :m
(])S
( tag? )S
3.328 :m
([)S
( { member)S
f1_9 sf
0 -3 rm
(+)S
0 3 rm
f1_10 sf
( } )S
3.328 :m
(])S
(?)S
310 301 :M
.137 .014(-- error if no 'tag' nor 'member's, or if one of them)J
240 313 :M
-.016(exist, but the following 'modifier'\(s\) do not each one define an identifier; )A
240 325 :M
.057 .006(if no identifier definition, error if 'attrib' or 'qualif' non empty. Exception:)J
240 337 :M
.352 .035(a 'strun' with a tag only is legal.)J
60 349 :M
-.051(member ::=)A
130 349 :M
-.414(decl1)A
180 349 :M
.219 .022(-- 'member' must not be a function.)J
60 361 :M
.051 .005(enum ::=)J
130 361 :M
22.419 :m
.051(enum)A
.076 .008( tag? )J
3.328 :m
([)S
.103 .01( { enumElt )J
3.328 :m
([)S
.097 .01( , enumElt )J
3.328 :m
(])S
.056 .006(* } )J
3.328 :m
(])S
(?)S
310 361 :M
.214 .021(-- error if no 'tag' nor 'enumElt's; see also 'strun'.)J
60 373 :M
.054 .005(tag ::=)J
130 373 :M
19 :m
-.249(ident)A
60 385 :M
.211 .021(enumElt ::=)J
130 385 :M
19.74 :m
-.051(ident)A
( )S
3.328 :m
([)S
-.051( = cstExp )A
3.328 :m
(])S
(?)S
60 397 :M
-.102(modifier ::=)A
130 397 :M
-.063(pointer* modif1 arrayFct*)A
60 409 :M
(pointer ::=)S
130 411 :M
-.179(*)A
0 -2 rm
-.155( qualif?)A
0 2 rm
200 409 :M
-.086(-- pointer declaration.)A
60 421 :M
-.065(modif1 ::=)A
130 421 :M
-.043(\( modifier \) )A
2 :m
(|)S
130 433 :M
18.822 :m
-.235(ident)A
(?)S
200 433 :M
-.028(-- error if 'ident' omitted and {'attrib' = typedef or 'baseType' )A
cF
f2_10 sf
-.028<B9>A
sf
-.028( 'enum', 'strun'}.)A
60 445 :M
-.091(arrayFct ::=)A
130 445 :M
.044 .004([ cstExp? ] )J
2 :m
(|)S
200 445 :M
-.155(-- array declaration.)A
130 457 :M
-.038(\( parList? \))A
200 457 :M
-.014(-- function declaration; 'attrib' )A
cF
f2_10 sf
-.014<B9>A
sf
-.014( auto/register; return type not array nor function.)A
60 469 :M
(parList ::=)S
130 469 :M
.07 .007(attrib? declPar )J
3.328 :m
([)S
.048 .005( , attrib? declPar )J
3.328 :m
(])S
(* )S
3.328 :m
([)S
.02 .002( , ... )J
3.328 :m
(])S
(?)S
310 469 :M
-.012(-- only legal 'attrib' = register. If parameter type =)A
220 481 :M
-.006(void, parameter must not be named, nor 'attrib'uted, and must be alone; other-)A
220 493 :M
-.026(wise, parameter names must all be different. If 'parList' called by a 'modifier')A
220 505 :M
-.05(followed by 'block', then each 'declPar' must declare an identifier.)A
60 517 :M
-.168(declPar ::=)A
130 517 :M
-.414(decl2)A
180 517 :M
-.004(-- function type not allowed.)A
60 529 :M
-.169(decl3 ::=)A
130 529 :M
.168 .017(initOrSizFld? )J
3.328 :m
([)S
.108 .011( , modifier initOrSizFld? )J
3.328 :m
(])S
.038 .004(* ; )J
2 :m
(|)S
320 529 :M
.157 .016(-- no 'initOrSizFld' if 'attrib' = typedef , or if no)J
250 541 :M
-.092(identifier declared, or if function declared, or if called via 'member'.)A
130 553 :M
-.054(block)A
180 553 :M
-.065(-- 'modifier' \(called by the 'decl1' that called this 'decl3'\) must have declared a function;)A
410 565 :M
.179 .018('attrib' = extern or static only.)J
60 577 :M
.124 .012(initOrSizFld ::=)J
130 577 :M
.351 .035(= init )J
2 :m
(|)S
130 589 :M
.298 .03(: cstExp)J
180 589 :M
-.03(-- allowed only if called via 'member'.)A
60 601 :M
.57 .057(init ::=)J
130 601 :M
-.124(condExp )A
2 :m
(|)S
180 601 :M
-.004(-- 'condExp' allowed only if 'qualif' = auto/register, and 'init' not called by itself.)A
130 613 :M
.158 .016(cstExp )J
2 :m
(|)S
130 625 :M
.345 .034({ init )J
3.462 :m
.134([)A
.247 .025( , init )J
3.462 :m
.134(])A
.251 .025(* )J
3.462 :m
.134([)A
.131 .013( , )J
3.462 :m
.134(])A
.394 .039(? })J
60 637 :M
.048 .005(block ::=)J
130 637 :M
-.07({ decl* stmt* })A
210 637 :M
-.029(-- no function definition allowed among 'decl's.)A
60 649 :M
.635 .063(stmt ::=)J
130 649 :M
.461 .046(label : stmt )J
2 :m
(|)S
130 661 :M
.34 .034(block )J
2 :m
(|)S
.235 .024( ifStmt )J
2 :m
(|)S
.343 .034( switchStmt )J
2 :m
(|)S
.328 .033( returnStmt )J
2 :m
(|)S
.343 .034( whileLoop )J
2 :m
(|)S
.284 .028( doLoop )J
2 :m
(|)S
.286 .029( forLoop )J
2 :m
(|)S
.05 .005( )J
22.693 :m
.098(break)A
.074 .007( ; )J
2 :m
(|)S
.05 .005( )J
35.191 :m
.095(continue)A
.074 .007( ; )J
2 :m
(|)S
130 673 :M
18.04 :m
.065(goto)A
.112 .011( label ; )J
2 :m
(|)S
.179 .018( sideEffects ; )J
2 :m
(|)S
( )S
25.363 :m
.074(empty)A
.07 .007( ;)J
60 685 :M
-.016(label ::=)A
130 685 :M
19 :m
-.249(ident)A
60 697 :M
.686 .069(ifStmt ::=)J
130 697 :M
6.262 :m
.078(if)A
.264 .026( \( boolExp \) stmt )J
3.413 :m
.085([)A
.058 .006( )J
15.942 :m
.099(else)A
.218 .022( stmt )J
3.413 :m
.085(])A
(?)S
60 709 :M
.568 .057(switchStmt ::=)J
130 709 :M
26.21 :m
.018(switch)A
.033 .003( \( exp \) { decl* )J
3.328 :m
([)S
( )S
3.328 :m
([)S
( )S
17.275 :m
.018(case)A
.038 .004( cstExp : )J
3.328 :m
(])S
f1_9 sf
0 -3 rm
(+)S
0 3 rm
f1_10 sf
.054 .005( stmt)J
f1_9 sf
0 -3 rm
(+)S
0 3 rm
f1_10 sf
( )S
3.328 :m
(])S
f1_9 sf
0 -3 rm
(+)S
0 3 rm
f1_10 sf
( )S
3.328 :m
([)S
( )S
27.875 :m
.016(default)A
.038 .004( : stmt)J
f1_9 sf
0 -3 rm
(+)S
0 3 rm
f1_10 sf
( )S
3.328 :m
(])S
(? })S
60 721 :M
.234 .023(returnStmt ::=)J
130 721 :M
23.802 :m
-.012(return)A
( )S
3.328 :m
([)S
-.011( exp )A
3.328 :m
(])S
(? ;)S
60 733 :M
(whileLoop ::=)S
130 733 :M
22.713 :m
.1(while)A
.272 .027( \( boolExp \) stmt)J
60 745 :M
-.089(doLoop ::=)A
130 745 :M
10.208 :m
.104(do)A
.178 .018( stmt )J
22.676 :m
.092(while)A
.209 .021( \( boolExp \) ;)J
60 757 :M
-.046(forLoop ::=)A
130 757 :M
11.53 :m
-.042(for)A
-.042( \( sideEffects? ; boolExp? ; sideEffects? \) stmt)A
60 769 :M
-.151(sideEffects ::=)A
130 769 :M
3.226 :m
-.101([)A
-.11( sideEffect , )A
3.226 :m
-.101(])A
-.133(* sideEffect)A
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(YN; page: 9 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
294 804 :M
f1_10 sf
(9)S
60 76 :M
-.171(sideEffect ::=)A
130 76 :M
-.073(asgnExp)A
190 76 :M
.155 .016(-- warning if top operator of 'asgnExp' is not one of 'incDec', 'asgnOp', call to a)J
375 88 :M
.082 .008(function returning void, or cast to void.)J
60 100 :M
.208 .021(boolExp ::=)J
130 100 :M
-.219(exp)A
190 100 :M
.03 .003(-- of boolean type.)J
60 112 :M
.047 .005(cstExp ::=)J
130 112 :M
-.258(condExp)A
190 112 :M
.197 .02(-- computable at compilation time.)J
60 124 :M
-.022(exp ::=)A
130 124 :M
10 f5_1 :p
3.328 :m
([)S
-.041( sideEffect , )A
3.328 :m
(])S
-.059(* asgnExp)A
60 136 :M
-.013(asgnExp ::=)A
130 136 :M
-.124(condExp )A
2 :m
(|)S
130 148 :M
-.073(condExp asgnOp asgnExp)A
60 160 :M
-.027(asgnOp ::=)A
130 160 :M
.1 .01(= )J
2 :m
(|)S
.078 .008( |= )J
2 :m
(|)S
.094 .009( ^= )J
2 :m
(|)S
.113 .011( &= )J
2 :m
(|)S
.13 .013( <<= )J
2 :m
(|)S
.13 .013( >>= )J
2 :m
(|)S
.1 .01( += )J
2 :m
(|)S
.086 .009( -= )J
2 :m
(|)S
( )S
0 2 rm
.074(*)A
0 -2 rm
.1 .01(= )J
2 :m
(|)S
.083 .008( /= )J
2 :m
(|)S
.203 .02( %=)J
60 172 :M
-.124(condExp ::=)A
130 172 :M
-.025(term0 )A
3.328 :m
([)S
-.024( ? exp : condExp )A
3.328 :m
(])S
(?)S
60 184 :M
(term0 ::=)S
130 184 :M
.156 .016(term1 )J
3.328 :m
([)S
.084 .008( || term1 )J
3.328 :m
(])S
(*)S
60 196 :M
(term1 ::=)S
130 196 :M
.22 .022(term2 )J
3.328 :m
([)S
.158 .016( && term2 )J
3.328 :m
(])S
(*)S
60 208 :M
(term2 ::=)S
130 208 :M
.161 .016(term3 )J
3.328 :m
([)S
.084 .008( | term3 )J
3.328 :m
(])S
(*)S
60 220 :M
(term3 ::=)S
130 220 :M
-.058(term4 )A
3.328 :m
([)S
-.054( ^ term4 )A
3.328 :m
(])S
(*)S
60 232 :M
(term4 ::=)S
130 232 :M
.195 .02(term5 )J
3.328 :m
([)S
.12 .012( & term5 )J
3.328 :m
(])S
(*)S
60 244 :M
(term5 ::=)S
130 244 :M
-.05(term6 )A
3.328 :m
([)S
-.05( equalOp term6 )A
3.328 :m
(])S
(*)S
60 256 :M
-.157(equalOp ::=)A
130 256 :M
-.21(== )A
1.908 :m
-.091(|)A
-.262( !=)A
60 268 :M
(term6 ::=)S
130 268 :M
-.068(term7 )A
3.275 :m
-.053([)A
-.068( orderOp term7 )A
3.275 :m
-.053(])A
(*)S
60 280 :M
-.201(orderOp ::=)A
130 280 :M
.391 .039(> )J
2.115 :m
.115(|)A
.391 .039( >= )J
2.115 :m
.115(|)A
.391 .039( <= )J
2.115 :m
.115(|)A
.427 .043( <)J
60 292 :M
(term7 ::=)S
130 292 :M
.116 .012(term8 )J
3.328 :m
([)S
.097 .01( shiftOp term8 )J
3.328 :m
(])S
(*)S
60 304 :M
.156 .016(shiftOp ::=)J
130 304 :M
.876 .088(>> )J
2.165 :m
.165(|)A
.948 .095( <<)J
60 316 :M
(term8 ::=)S
130 316 :M
-.089(term9 )A
3.259 :m
-.069([)A
-.091( addOp term9 )A
3.259 :m
-.069(])A
(*)S
60 328 :M
-.206(addOp  ::=)A
130 328 :M
.439 .044(+ )J
2.129 :m
.129(|)A
.343 .034( -)J
60 340 :M
(term9 ::=)S
130 340 :M
.158 .016(term10 )J
3.328 :m
([)S
.126 .013( mulOp term10 )J
3.328 :m
(])S
(*)S
60 352 :M
.293 .029(mulOp ::=)J
130 354 :M
.315(*)A
0 -2 rm
.143 .014( )J
0 2 rm
0 -2 rm
2.125 :m
.126(|)A
0 2 rm
0 -2 rm
.213 .021( / )J
0 2 rm
0 -2 rm
2.125 :m
.126(|)A
0 2 rm
0 -2 rm
.62 .062( %)J
0 2 rm
60 364 :M
(term10 ::=)S
130 364 :M
-.02(unaryOp term10 )A
2 :m
(|)S
130 376 :M
-.015(prim incDec* )A
2 :m
(|)S
130 388 :M
23.167 :m
-.117(sizeof)A
-.118( \( declPar \))A
220 388 :M
-.066(-- 'declPar' must not declare any identifier.)A
60 400 :M
-.068(unaryOp ::=)A
130 400 :M
.044 .004(~ )J
2 :m
(|)S
.024 .002( ! )J
2 :m
(|)S
( )S
0 2 rm
(*)S
0 -2 rm
( )S
2 :m
(|)S
.037 .004( & )J
2 :m
(|)S
.078 .008( addOp )J
2 :m
(|)S
( )S
24.032 :m
.027(sizeof)A
( )S
2 :m
(|)S
.053 .005( cast )J
2 :m
(|)S
.129 .013( incDec)J
60 412 :M
-.034(cast ::=)A
130 412 :M
-.164(\( declPar \))A
220 412 :M
-.026(-- 'declPar' must not declare any identifier, and the result type may not be)A
445 424 :M
.03(struct/union/function.)A
60 436 :M
-.112(incDec ::=)A
130 436 :M
.453 .045(++ )J
2.085 :m
.085(|)A
.326 .033( --)J
60 448 :M
.247 .025(prim ::=)J
130 448 :M
.073 .007(prim1 primQualif*)J
60 460 :M
.233 .023(prim1 ::=)J
130 460 :M
.085 .009(\( exp \) )J
2 :m
(|)S
.073 .007( cst )J
2 :m
(|)S
( )S
20.221 :m
.057(ident)A
60 472 :M
-.009(primQualif ::=)A
130 472 :M
.174 .017(\( argList \) )J
2 :m
(|)S
.109 .011( [ exp ] )J
2 :m
(|)S
.056 .006( . )J
20.34 :m
.069(ident)A
( )S
2 :m
(|)S
.1 .01( -> )J
20.34 :m
.086(ident)A
60 484 :M
(argList ::=)S
130 484 :M
3.328 :m
([)S
.11 .011( asgnExp )J
3.328 :m
([)S
.087 .009( , asgnExp )J
3.328 :m
(])S
.05 .005(* )J
3.328 :m
(])S
(?)S
60 496 :M
.124 .012(cst ::=)J
130 496 :M
-.031(' )A
36.093 :m
-.059(character)A
-.033( ' )A
2 :m
(|)S
130 508 :M
.2 .02(" )J
23.603 :m
.138(string)A
.144 .014( " )J
3.449 :m
.121([)A
.144 .014( " )J
23.603 :m
.138(string)A
.144 .014( " )J
3.449 :m
.121(])A
.228 .023(* )J
2 :m
(|)S
130 520 :M
-.082(sgndNb )A
2 :m
(|)S
130 532 :M
10 :m
(nb)S
60 544 :M
-.089(sgndNb ::=)A
130 544 :M
3.483 :m
.156([)A
.216 .022( + )J
2.093 :m
.094(|)A
.169 .017( - )J
3.483 :m
.156(])A
.106 .011( )J
10.468 :m
.468(nb)A
60 580 :M
.246 .025(Restrictions with respect to ANSI C:)J
70 604 :M
(-)S
78 604 :M
-.006(no old-style function definition,)A
70 616 :M
(-)S
78 616 :M
-.069(imposed order for 'attrib' and 'qualif',)A
70 628 :M
(-)S
78 628 :M
-.009(no default 'int' baseType,)A
70 640 :M
(-)S
78 640 :M
.117 .012(a switch must control a block; 'default' must come as last case; 'case', 'default' not labels,)J
70 652 :M
(-)S
78 652 :M
-.012(no unparenthesized assignment in initializer,)A
70 664 :M
(-)S
78 664 :M
-.001(braces in initializer only to indicate initialization of a compound object \(array/struct/union\); if so, mandatory,)A
70 676 :M
(-)S
78 676 :M
.157 .016(enum, char\312: types by themselves \(not considered as int\),)J
70 688 :M
(-)S
78 688 :M
-.02(automatic arithmetic conversions only from narrower to wider type,)A
70 700 :M
(-)S
78 700 :M
-.072(identifiers may never be declared more than once in the same scope \(except in header files\),)A
70 712 :M
(-)S
78 712 :M
-.129(macros \(#define\) cannot be declared more than once \(if not '#undef'ed beforehand\),)A
70 724 :M
(-)S
78 724 :M
.024 .002(labels local to blocks \(but cannot be duplicated in a given function\),)J
70 736 :M
(-)S
78 736 :M
-.024(a function or array is different from a pointer on the same function/array,)A
70 748 :M
(-)S
78 748 :M
-.043(left operand of indexation must be array/pointer,)A
70 760 :M
(-)S
78 760 :M
-.064(void )A
0 2 rm
-.079(*)A
0 -2 rm
-.065(  only universal receiver for pointers \(cast or d-pragma needed the other way around, except for NULL\).)A
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(YN; page: 10 of 10)setjob
%%EndPageSetup
-29 -30 :T
gS 29 30 538 781 rC
292 804 :M
f1_10 sf
(10)S
227 74 :M
f1_9 sf
-.305(APPENDIX B)A
60 94 :M
f7_9 sf
-.404(/**************************************************************************/)A
60 104 :M
-.404(/*      Sum of two matrix of arbitrary size \(without use of pointer\)      */)A
60 114 :M
-.404(/**************************************************************************/)A
60 124 :M
-.422(#include <stdio.h>)A
60 134 :M
-.419(#include "dynarray.h")A
60 154 :M
-.413(/* 'bool' type definition */)A
60 164 :M
-.415(typedef unsigned int bool;)A
60 174 :M
-.418(#define FALSE \(0 != 0\))A
60 184 :M
-.418(#define TRUE  \(0 == 0\))A
60 204 :M
-.409(/* type definition for matrix elements */)A
60 214 :M
-.422(typedef float Num;)A
60 224 :M
-.408(/* type definition for variable-size matrix */)A
60 234 :M
-.412(typedef DynArray2\(Num\) DynArr;)A
60 244 :M
-.41(typedef DynArray2\(const Num\) CDynArr;)A
60 264 :M
-.412(/* Models \(function profiles\) */)A
60 274 :M
-.409(static void print\(CDynArr\), read\(DynArr\);)A
60 284 :M
-.41(static DynArr add\(CDynArr, CDynArr\);)A
60 304 :M
-.443(int main\(\))A
60 314 :M
-.412({ bool ok;  unsigned int i, j;)A
60 324 :M
-.404(  DynArr mat1 = NULL, mat2 = NULL, resMat;  /* matrix declarations \(resMat)A
340 334 :M
-.412(allocated by 'add' function\). */)A
60 344 :M
-.478(  do {)A
60 354 :M
-.429(    for \(;;\) {)A
60 364 :M
-.408(      printf\("\\nEnter matrix dimensions: "\);)A
60 374 :M
-.403(      if \(scanf\("%u%u",&i,&j\) == 2\) break;  /* exit loop if numbers read are correct */)A
60 384 :M
-.405(      while \(getchar\(\) != '\\n'\) {}}  /* flush input buffer */)A
60 394 :M
-.404(    AllocDynArray2\(mat1, i, j, &ok\);  /* allocate space for matrix 'mat1', freeing)A
410 404 :M
-.415(possible previous one. */)A
60 414 :M
-.406(    if \(! ok\) printf\("\\n memory overflow for 1st matrix"\);)A
60 424 :M
-.443(    else {)A
60 434 :M
-.409(      printf\("\\nmat1=\\n"\); read\(mat1\);)A
60 444 :M
-.409(      AllocDynArray2\(mat2, i, j, &ok\);)A
60 454 :M
-.405(      if \(! ok\) printf\("\\n memory overflow for 2nd matrix"\);)A
60 464 :M
-.435(      else {)A
60 474 :M
-.409(        printf\("\\nmat2=\\n"\); read\(mat2\);)A
60 484 :M
-.407(        resMat = add\(mat1, mat2\); print\(resMat\);)A
60 494 :M
-.405(        FreeDynArray2\(resMat\);}}  /* free result matrix space */)A
60 504 :M
-.421(  } while \(i != 0\);)A
60 514 :M
-.439(  return 0;)A
60 524 :M
(})S
60 544 :M
-.415(static void read\(DynArr x\))A
60 554 :M
-.413({ unsigned int i, j, l1, l2;)A
60 574 :M
-.405(  LimDynArray2\(x, &l1, &l2\); /* get dimensions of matrix 'x' */)A
60 584 :M
-.403(  for \(i = 0; i < l1; i++\)  {for \(j = 0; j < l2; j++\) {\(void\)scanf\("%g", &x[i][j]\);}})A
60 594 :M
(})S
60 614 :M
-.413(static void print\(CDynArr x\))A
60 624 :M
-.413({ unsigned int i, j, l1, l2;)A
60 644 :M
-.427(  printf\("\\n"\);)A
60 654 :M
-.413(  LimDynArray2\(x, &l1, &l2\);)A
60 664 :M
-.403(  for \(i = 0; i < l1; i++\)  {for \(j = 0; j < l2; j++\) {printf\("%g ", x[i][j]\);} printf\("\\n"\);})A
60 674 :M
(})S
60 694 :M
-.409(static DynArr add\(CDynArr x, CDynArr y\))A
60 704 :M
-.406({ unsigned int i, j, l1, l2;  bool ok;  DynArr z = NULL;)A
60 724 :M
-.413(  LimDynArray2\(x, &l1, &l2\);)A
60 734 :M
-.404(  AllocDynArray2\(z, l1, l2, &ok\);  /* allocate space for result matrix */)A
60 744 :M
-.406(  if \(! ok\) printf\("\\n memory overflow for result matrix"\);)A
60 754 :M
-.403(  else for \(i = 0; i < l1; i++\)  {for \(j = 0; j < l2; j++\) {z[i][j] = x[i][j] + y[i][j];}})A
60 764 :M
-.439(  return z;)A
60 774 :M
(})S
endp
%%Trailer
end
%%EOF
