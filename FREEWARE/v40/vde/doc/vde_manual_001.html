<!-- VDE_MANUAL_001.HTML continuation of VDED$:[VDE.VDEDOC.DOC]VDE_MANUAL.HTML -->
<html>
<head>
<title>VDE</title>
</head>
<body bgcolor=white>
<font color=maroon>
<h1 align="center">VDE<br>VDE<br> Reference Manual</h1>
</font>

<hr>
<table border=2>
  <tr>
    <td bgcolor=lightgoldenrodyellow width=150 align=center><a href="vde_manual.html#bottom_main">Previous</a>
    <td bgcolor=cyan width=150 align=center><a href="vde_manual_contents.html">Contents</a>
    <td bgcolor=lightskyblue width=150 align=center><a href="vde_manual_index.html">Index</a>
</table>

<hr>

<p>
<hr size=5>
<font color=maroon>
<a name="vde_dcl_cmd_ref"><h1>Chapter 2<br>VDE Commands Invoked from DCL</h1></a>
</font>
<p>

<hr>
<a name="dcl_vde_command"><h1><font color=maroon>VDE</font></h1></a>
<a name="index_x_15"></a>

<p>
<blockquote>
The OpenVMS Development Environment (VDE) Utility is a tool 
that software developers can use to manage software development. 
VDE uses a relational database to store development 
information about your software system and to manage multiple instances 
of that system. VDE also manages the disk directories, CMS 
libraries, and files that comprise your software system. In managing a 
software system, VDE can perform the following functions:

<ul>
  <li>Store and retrieve information about the modules, facilities 
  (groups of modules), module generations, development streams, and other 
  entities that make up your software system.
  <li>Reserve source modules from the VDE library and replace 
  them after they have been modified. Modules can be reserved from and 
  replaced into multiple development streams and changes can be 
  automatically propagated between streams.
  <li>Build the software system. VDE can perform both full and 
  minimal system builds. In a full build, all modules in the software 
  system are compiled, linked, or otherwise processed. In a minimal 
  system build, only those modules that have been changed since the last 
  system build are compiled, linked, or processed.
  <li>Collect and report software development statistics.
</ul>

<p>
VDE includes extensive built-in HELP. At the VDE„, 
type &quot;HELP&quot;. An extensive documentation set, in Bookreader 
and Postscript formats, is also available.
</blockquote>

<hr>
<h2>Format</h2>
<blockquote>
<h3>VDE [vde-command [; vde-command...]] </h3>
</blockquote>

<hr>
<h2>Parameter</h2>
<blockquote>
<h3>vde-command</h3>
A VDE command to be performed. The available VDE 
commands are described in <a href="vde_manual_002.html#vde_cmd_ref">Chapter 3</a>. You can specify multiple 
VDE commands if you separate them by semicolons (;).

<p>
This parameter is optional; it you omit it, VDE prompts you 
for commands.
</blockquote>

<hr>
<h2>Description</h2>
<blockquote>
The VDE command invokes the VDE utility and allows 
you to enter VDE subcommands. Specifying the VDE 
command with specific qualifiers enables you to modify the 
VDE environment or invoke separate programs that are part of 
the VDE system.

<p>
To invoke the VDE utility, enter the VDE command at 
the DCL prompt ($). The system responds with the prompt for the 
VDE utility (VDE„). For example:

<p>
<table border=0>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue><pre>
$ VDE
VDE„
</pre>
</font>
</table>

<p>
At the VDE„ prompt, you can enter VDE subcommands to 
perform VDE functions. For simplicity, these subcommands are 
referred to as &quot;VDE commands&quot; in the rest of this 
description.
<a name="index_x_16"></a>
To exit from VDE, enter the EXIT command or press CTRL/Z.

<p>
The following example shows how to enter VDE commands from 
within the utility:
<a name="index_x_17"></a>

<p>
<table border=0>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue><pre>
$ VDE
VDE„ SHOW LIBRARY
Main library LIBNAME in root directory DEV$:[PROJDIR]
VDE„ EXIT
$
</pre>
</font>
</table>

<p>
You can also enter VDE commands directly on the VDE 
command line. In this case, VDE does not prompt you for 
commands. The following example shows how to enter a VDE 
command from the DCL command line:
<a name="index_x_18"></a>

<p>
<table border=0>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue><pre>
$ VDE SHOW LIBRARY
Main library LIBNAME in root directory DEV$:[PROJDIR]
$
</pre>
</font>
</table>

<p>
You can also enter the following commands from the DCL command line 
(either interactively or from within a coded file called a 
&quot;VDE script&quot;) to invoke separate programs that are 
part of the VDE system:

<ul>
  <li>VDE/DEPEND
  <li>VDE/READ_UAF
  <li>VDE/WHEREIS
</ul>

<p>
These commands are described separately in this chapter.

<p>
To use VDE, you must specify the VDE library that 
you want to use. The VDE library for a software system 
consists of a root directory, a VDE database residing in that 
root directory, and a directory tree that contains all CMS libraries, 
source files, and other files that make up your software system. You 
specify the VDE library you want to use by giving the 
directory specification for the library root directory. The root 
directory contains the database and the database contains pointers to 
all other directories that make up the library.

<p>
Unless you are creating a new VDE library, you can specify 
the library using any of three methods. First, you can define a logical 
name VDE$LIBRARY to give the library's root directory.
<a name="index_x_19"></a>
<a name="index_x_20"></a>
If you use the same VDE library most of the time, you should 
define VDE$LIBRARY in your login file. Second, you can use the /LIBRARY 
qualifier to the VDE command to specify the library mnemonic 
or root directory. And third, you can use the VDE SET LIBRARY 
command to specify the mnemonic or root directory. You must use one of 
these three methods to specify the VDE library.
</blockquote>

<hr>
<h2>Qualifiers</h2>
<blockquote>
<h3>/INTERFACE=keyword</h3>
The /INTERFACE qualifier allows the user to select a keyword 
representing the prefered user interface presented by VDE. 
With the VDE/INTERFACE=DECWINDOWS keyword, the Motif
<a name="index_x_21"></a>
 graphical user interface is used. With the 
 VDE/INTERFACE=CHARACTER_CELL keyword, the traditional command 
 interface is used.
<h3>/KEPT_PROCESS</h3>
<h3>/NOKEPT_PROCESS (default)</h3>
Specifies whether VDE runs with or without creating a kept 
process. /KEPT_PROCESS specifies that the VDE utility should 
run in a kept subprocess that is retained from one invocation of the 
VDE command to the next. Use of a kept subprocess allows 
VDE to connect to the VDE database once for many 
invocations of VDE, thus speeding up subsequent accesses to 
the database. It also allows VDE to retain state information, 
such as the default stream and facility, between invocations. 
/NOKEPT_PROCESS specifies that VDE not run in a kept 
subprocess.

<p>
Do <em>not</em> attempt to use the DCL ATTACH command to attach to a 
VDE or VSC kept process.
<h3>/LIBRARY=directory-spec</h3>
Specifies the mnemonic name or root directory of the VDE 
library with which you want to work. Subsequent VDE 
operations will access the database associated with that library.
<h3>/DEPEND lang ana-file [in-out-file [,in-out-file...]]</h3>
The /DEPEND qualifier causes VDE to invoke a separate program 
that automatically collects build dependency information. The 
VDE/DEPEND combination is described as a separate command 
later in this chapter.
<h3>/READ_UAF</h3>
The /READ_UAF qualifier causes VDE to invoke a separate 
program used to update the User Table in a VDE database from 
information in the system user authorization file (UAF). The 
VDE/READ_UAF combination is described as a separate command 
later in this chapter.
</blockquote>

<hr>
<h2>Examples</h2>
<blockquote>
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen><strong>#1</strong></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ DEFINE VDE$LIBRARY DEV$:[PROJDIR]
$ VDE
VDE„ SHOW LIBRARY
Main library LIBNAME in root directory DEV$:[PROJDIR]
VDE„ SHOW STREAM V2.1-1
Stream V2.1-1          "First update to version 2.1"
VDE„ HELP
...help text displayed...
VDE„ EXIT
$
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
This example defines logical name VDE$LIBRARY to specify the root
<a name="index_x_22"></a>
<a name="index_x_23"></a>
directory of the VDE library you want to work with. This 
directory contains the VDE database for the library. The 
VDE command entered from DCL then gives the VDE„ 
prompt. You can now enter VDE commands, in this case the SHOW 
LIBRARY and SHOW STREAM commands. The EXIT command ends the 
VDE session and returns you to the DCL prompt ($).
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen><strong>#2</strong></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ VDE SHOW LIBRARY; SHOW STREAM V2.1-1
Main library LIBNAME in root directory DEV$:[PROJDIR]
Stream V2.1-1          "First update to version 2.1"
$
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
This example shows two VDE commands entered directly on the 
DCL-level VDE command line. Both commands are executed, after 
which VDE exits and returns you to the DCL prompt ($). In 
this case, VDE does not prompt for commands. The example 
assumes that logical name VDE$LIBRARY has already been defined, perhaps 
in the user's login file.
<a name="index_x_24"></a>
<a name="index_x_25"></a>
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen><strong>#3</strong></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ VDE/LIBRARY=DEV$:[ROOTDIR]
VDE„ SHOW LIBRARY
Library LIBNAME in root directory DEV$:[ROOTDIR]
VDE„ EXIT
$
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
In this example, the /LIBRARY qualifier specifies that the root 
directory for the VDE library is DEV$:[ROOTDIR]. Entering the 
SHOW LIBRARY command at the VDE prompt confirms that this 
library has been set.
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen><strong>#4</strong></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ VDE
VDE„ SET LIBRARY DEV$:[ROOTDIR]
VDE„ SHOW LIBRARY
Library LIBNAME in root directory DEV$:[ROOTDIR]
VDE„ EXIT
$
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
This example uses the SET LIBRARY command to specify the root directory 
of the VDE library to use. The SHOW LIBRARY command confirms 
that this library has been set.
</blockquote>

<hr>
<a name="dcl_vde_depend"><h1><font color=maroon>VDE/DEPEND</font></h1></a>
<a name="index_x_26"></a>

<p>
<blockquote>
Invokes a program that automatically collects build dependency 
information from a compiler-generated analysis file to determine the 
inputs and outputs of a build step.

<p>
<strong>This command should only be invoked in DCL command procedures 
created from VDE scripts to perform build steps. Do not 
attempt to run this program interactively.</strong>
</blockquote>

<hr>
<h2>Format</h2>
<blockquote>
<h3>VDE/DEPEND lang ana-file [in-out-file [,in-out-file...]] 
</h3>
</blockquote>

<hr>
<h2>Parameters</h2>
<blockquote>
<h3>lang</h3>
The name of the language processor that generated the Source Code 
Analyzer analysis file. This is a required parameter. Keywords for the 
supported language processors are as follows:

<table border=3>
  <tr bgcolor=lightseagreen>
    <th align=center>Keyword </th>
    <th align=center>Language Processor </th>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      ADA
    </td>
    <td>
      Ada compiler
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      B32
    </td>
    <td>
      Bliss compiler
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      C
    </td>
    <td>
      C compiler
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      DML
    </td>
    <td>
      DBMS preprocessors for compilers
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      FOR
    </td>
    <td>
      Fortran compiler
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      MAR
    </td>
    <td>
      Macro assembler
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      NOANA
    </td>
    <td>
      No analysis file given (only the
      <strong>in-out-file</strong> parameters are used)
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      PLI
    </td>
    <td>
      PLI compiler
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      PAS
    </td>
    <td>
      Pascal compiler
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      RBA
    </td>
    <td>
      RDML preprocessor for BASIC
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      RBL
    </td>
    <td>
      RDML preprocessor for Bliss
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      RC
    </td>
    <td>
      RDML preprocessor for C
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      RCO
    </td>
    <td>
      RDML preprocessor for COBOL
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      RFO
    </td>
    <td>
      RDML preprocessor for FORTRAN
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      RPA
    </td>
    <td>
      RDML preprocessor for Pascal
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      REQ
    </td>
    <td>
      Bliss library compilation
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      SC
    </td>
    <td>
      SQL preprocessor for C
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      SCO
    </td>
    <td>
      SQL preprocessor for COBOL
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      SFO
    </td>
    <td>
      SQL preprocessor for FORTRAN
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      SPA
    </td>
    <td>
      SQL preprocessor for Pascal
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      SPL
    </td>
    <td>
      SQL preprocessor for PL/I
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      SQLADA
    </td>
    <td>
      SQL preprocessor for Ada
    </td>
  </tr>
  <tr bgcolor=blanchedalmond>
    <td>
      SQLMOD
    </td>
    <td>
      SQL module language
    </td>
  </tr>
</table>
<h3>ana-file</h3>
The file specification for the analysis file containing the dependency 
information. This is a required parameter. If the <strong>lang</strong> 
parameter is NOANA, specify two double quotes ("") to indicate that the 
<strong>ana-file</strong> parameter is null.
<h3>in-out-file</h3>
A file specification that specifies an input file or output file for 
the build step. The file specification can be followed by the /INPUT 
qualifier to indicate that the file is an input to the step or by the 
/OUTPUT qualifier to indicate that the file is an output of the step. 
If neither qualifier is specified, the file is assumed to be an input 
file. This parameter is used to record input and output files that are 
not specified in the analysis file or that are not correctly classified 
as inputs or outputs from the information in the analysis file.
</blockquote>

<hr>
<h2>Description</h2>
<blockquote>
The VDE/DEPEND command invokes a separate program that 
automatically collects build dependency information from a 
compiler-generated Source Code Analyzer (SCA) analysis file. The 
VDE/DEPEND command is used in command procedures generated 
from VDE scripts to compile source modules. The program reads 
the analysis (.ANA) file along with information specified on the 
command line to determine all input and output modules for the current 
build step. This information is written to the VDE database 
if the build step completes successfully.

<p>
The analysis file specifies all input and output files of the 
compilation but does not indicate which files are inputs and which 
files are outputs. VDE/DEPEND therefore requires that you 
specify the language that was compiled so that the program can guess 
which files are inputs and which are outputs based on file types. As a 
result, it is important that you use the standard file types for all of 
your compilations.

<p>
Because the analysis file and command line supply VDE/DEPEND 
with a list of file names, VDE must translate those file 
names into VDE module names before it can record build 
dependencies in its database. To do so, VDE uses the 
following rules:

<ul>
  <li>VDE assumes that the VDE module name and type 
  are the same as the file name and type from the analysis file or 
  command line.
  <li>VDE looks up the full directory specification of the file 
  in the VDE database. If that directory is a subdirectory in 
  the VDE directory tree for the stream being built, then 
  VDE can determine the facility of the module. The facility is 
  determined from the part of the directory tree in which the file is 
  found.
  <li>Once the facility, module name, and module type are determined, the 
  module can be looked up in the VDE database. If the module is 
  an output module for the build step and the module is not found in the 
  database, VDE adds it to the database as a new derived module.
  <li>If the full directory specification cannot be found in the 
  VDE database, the module is assumed to be outside of your 
  VDE library and is ignored. As a result, input modules from 
  system libraries, for example, are omitted from VDE's 
  dependency graph.
</ul>

<p>
As a result of these rules, it is important that each source module or 
derived module be stored somewhere in the directory tree for the stream 
you are building and, within that stream, for the facility to which the 
module belongs. This is a constraint that your scripts must obey; 
within that constraint, scripts are free to place files anywhere you 
want.
</blockquote>

<hr>
<h2>Examples</h2>
<blockquote>
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen><strong>#1</strong></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ DEFINE SRC$ DEV$:[ROOTLIB.MAIN.FAC.SRC]
$ DEFINE OBJ$ DEV$:[ROOTLIB.MAIN.FAC.OBJ]
$ VDE FETCH [FAC]FOO.C/OUTPUT=SRC$:
$ CC/ANA=OBJ$:/OBJ=OBJ$:  SRC$:FOO.C
$ VDE/DEPEND C OBJ$:FOO.ANA 
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
This example shows the lines generated from a VDE script to 
compile module FOO.C. The first two lines define logical names SRC$ and 
OBJ$ to point to the source and object directories for stream MAIN and 
facility FAC within the VDE library. The third line fetches 
source module FOO.C from the VDE library into the source 
directory. The next line runs the C compiler, compiling module FOO.C to 
produce an object file FOO.OBJ and an SCA analysis file FOO.ANA. The 
last line runs VDE/DEPEND to read that analysis file. From 
information in the analysis file, VDE/DEPEND determines what 
input files were used and what output files were produced by the 
compilation. This information will be passed to VDE for 
inclusion in the VDE database.
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen><strong>#2</strong></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ VDE/DEPEND REQ OBJDIR:LIBDEF.ANA OBJDIR:LIBDEF.L32/OUTPUT 
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
When the command procedure containing this line executes, 
VDE/DEPEND will read the analysis file OBJDIR:LIBDEF.ANA to 
determine the input and output modules of a Bliss library compilation. 
Because a Bliss library compilation produces one .L32 module as an 
output and may use many .L32 modules as inputs, the 
VDE/DEPEND command line must specify which .L32 module is the 
one output. This is done by specifying OBJDIR:LIBDEF.L32 with the 
/OUTPUT qualifier at the end of the command. This is an example of 
using an <strong>in-out-file</strong> parameter to override the default 
assumption that a module of that type is an input to the compilation.
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen><strong>#3</strong></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ VDE/DEPEND NOANA "" SRCDIR:FOO.MSG/INPUT,OBJDIR:FOO.EXE/OUTPUT 
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
This example shows how VDE/DEPEND can be used to specify 
input and output modules when no analysis file is available. The 
message compiler does not produce an analysis file. For this reason, 
the command uses the NOANA keyword and specifies the null string as the 
analysis file parameter. The actual input and output files are 
specified by a list of <strong>in-out-file</strong> parameters at the 
end of the command.
</blockquote>

<hr>
<a name="vde_read_uaf"><h1><font color=maroon>VDE/READ_UAF</font></h1></a>
<a name="index_x_27"></a>

<p>
<blockquote>
Updates the User Table in a VDE database from information in 
the system user authorization file (SYSUAF).
</blockquote>

<hr>
<h2>Format</h2>
<blockquote>
<h3>VDE/READ_UAF[/WRITE_UAF] </h3>
</blockquote>

<hr>
<h2>Description</h2>
<blockquote>
The VDE/READ_UAF command invokes a separate program that 
updates the User Table in a VDE database from information in 
the system user authorization file (SYSUAF).
<a name="index_x_28"></a>
<a name="index_x_29"></a>
For each user recorded in the VDE database, the program looks 
up that user in the UAF to determine the user's full name from the UAF 
owner field. That name is then stored in the VDE database if 
not already there. The program also determines whether the user's 
account is still valid. If not, the user is marked as deleted in the 
VDE database so that the database is no longer accessible to 
that user.

<p>
The VDE/READ_UAF command also supports a /WRITE_UAF 
qualifier. Specification of VDE/READ_UAF/WRITE_UAF causes 
VDE to update the process quota values of all VDE 
users in the System Authorization Database (SYSUAF).
<a name="index_x_30"></a>
<a name="index_x_31"></a>
Any process quotas below the minimum VDE requirements are 
increased, but quotas above the minimum are not altered. The /WRITE_UAF 
qualifier is valid only when specified with /READ_UAF, and it requires 
read and write access to the SYSUAF database.

<p>
VDE/READ_UAF can be run at regular intervals to maintain the 
VDE database so it stays synchronized with the system 
authorization database. This way, you do not have to manually maintain 
the VDE User Table with the CREATE USER, MODIFY USER, and 
DELETE USER commands. Specification of the the target VDE 
library is required via the /LIBRARY qualifier on the command, or via 
the logical name VDE$LIBRARY.
<a name="index_x_32"></a>
<a name="index_x_33"></a>

<p>
To use this command, you must have read access to the
<a name="index_x_34"></a>
 SYSUAF system authorization file. Access to the system authorization 
 file can be granted via OpenVMS an privilege such as
<a name="index_x_35"></a>
 READALL or BYPASS, via an ACL on the SYSUAF file, or via various other 
 means. Contact your system manager for assistance.
<a name="index_x_36"></a>
<a name="index_x_37"></a>
</blockquote>

:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,==
<hr>
<h2>Qualifiers</h2>
<blockquote>
<h3>/DELETE</h3>
The /DELETE qualifier causes VDE to delete any VDE 
usernames that are not also found in SYSUAF. This is not generally 
desirable, and can potentially lead to problems should SYSUAF be 
misdirected.
<h3>/WRITE_UAF</h3>
The /WRITE_UAF qualifier causes VDE to update any process 
quotas stored in the SYSUAF file that are below the required minimum 
settings to the minumum settings. Quota values above the minimum 
settings are not altered.
</blockquote>

:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,=:=,==
<hr>
<h2>Example</h2>
<blockquote>
</blockquote>

<table border=0>
  <tr>
    <th bgcolor=lightseagreen></th>
  <tr>
    <td bgcolor=blanchedalmond>
      <br>
      <font color=mediumblue>
<pre>
$ SET PROCESS/PRIVILEGE=BYPASS
$ VDE/READ_UAF/WRITE_UAF/LIBRARY=DEV$:[VDELIBDIR]
$ SET PROCESS/PRIVILEGE=NOBYPASS
      </pre>
      </font>
    </td>
  </tr>
</table>

<blockquote>
<p>
The first command sets the OpenVMS privilege BYPASS, which overrides 
all protections on the system authorization database. The second 
command runs VDE/READ_UAF to update the VDE 
database from the user authorization file, and the system authorization 
database process quotas from the list of users in the VDE 
database. The final line removes the BYPASS privilege to clean up.
<a name="index_x_38"></a>
</blockquote>

<a name="bottom_001"></a>
<p>
<hr>
<table border=2>
  <tr>
    <td bgcolor=lightgoldenrodyellow width=150 align=center><a href="vde_manual.html#bottom_main">Previous</a>
    <td bgcolor=aquamarine width=150 align=center><a href="vde_manual_002.html">Next</a>
    <td bgcolor=cyan width=150 align=center><a href="vde_manual_contents.html">Contents</a>
    <td bgcolor=lightskyblue width=150 align=center><a href="vde_manual_index.html">Index</a>
</table>
</body>
</html>
