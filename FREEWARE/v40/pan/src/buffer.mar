


;Member           Access              Mail Address                   Privileges
;GREG             HSSWS1::GREG        HSSWS1::GREG                   [M]


	.title	PAN

		.ident	/V1.0-2/
version:	.ascid	/V1.0-2/





	.psect	page,page




conf_moderator = 54

type_author = 198
type_date   = 204
type_title  = 215
type_per    = 211
type_li     = 209
type_un1    = 223
type_rep    = 210



tmp_fab:	$fab	fac=<get,put,upd,del>, fop=dlt,shr=<put,get,del,upd>
			

XXAB:   $XABPRO PRO=<REWD,REWD,REWD,REWD>


tmp_rab:	$rab	usz=10000,rsz=10000,ubf=buffer,rbf=buffer,rac=key,-
		ksz=4,kbf=uid,fab=tmp_fab
                             



fab:	$fab	fac=<get,put,upd,del>,shr=<put,get,del,upd>
rab:	$rab	usz=10000,rsz=10000,ubf=buffer,rbf=buffer,rac=key,-
		ksz=4,kbf=uid,fab=fab


Dfab:	$fab	fac=<Put>, Rat=<Cr>, nam=nam,fop=nam
Drab:	$rab	fab=Dfab,usz=500,rsz=500,ubf=buffer,rbf=buffer


nam:    $nam    rsa=result,-
                rss=200,-
                esa=exp,-
                ess=200



Tfab:	$fab	fac=<get>
Trab:	$rab	usz=1000,rsz=1000,ubf=Tbuffer,rbf=Tbuffer,fab=Tfab



Tbuffer:	.Blkb	1000


buffer:	.blkb	10000
save_1:	.blkb	10000
save_2:	.blkb	10000


result:	.blkb	200
exp:	.blkb	200


	.macro	check_fail	?L3,?L4
	blbc	r0,L3
	brw	L4
L3:	nop

	MOVL    R0,VEC+4

	pushaq	rev_on
	calls	#1,g^lib$put_output


        $PUTMSG_S       MSGVEC=VEC
	pushaq	fail_over
	calls	#1,g^lib$put_output

	pushaq	rev_off
	calls	#1,g^lib$put_output


	brw	166$
L4:	nop
	.endm	check_fail



	.macro	check_eof, ?L5, ?L6
	blbs	r0, L5
	cmpl	r0, #rms$_eof
	bneq	L6
	movl	#1, R0
	ret
L6:	nop
L5:	nop
	.endm	check_eof


	.macro	pad_star , list, ?L3
	pushr	#^m<R5>


	pushaq	noautowildcard
	calls	#1,g^cli$present
	blbs	r0,L3
	



	movzwl	list, R5
	addl2	List+4, R5

	decl	R5
	cmpb	#^a/*/, (R5)
	beql	L3

	incl	R5
	incw	list

	movb	#^a/*/, (R5)

L3:	popr	#^m<R5>

	.endm	pad_star




	.MACRO	put_de	, mmm
	movw	mmm, Drab+rab$w_rsz
	movw	mmm, Drab+rab$w_usz
	movl	mmm+4, Drab+rab$l_Rbf
	movl	mmm+4, Drab+rab$l_Ubf
	$Put	Rab=Drab
	check	r0,error
	.endm	put_de


	.MACRO	tst_priv	AERROR,?L3
	bbs	#Aerror, priv, L3
	pushaq	priv_e
	calls	#1,g^lib$put_output
	movl	#SS$_nopriv,R0
	ret
L3:	NOP
	.endm	tst_priv



	.MACRO	CHECK	AR0,AERROR,?L3

	BLBS	AR0,L3
	ret
L3:	NOP

	.ENDM	CHECK




	.MACRO	tst	AR0,AERROR,?L3

	beql	L3

	pushaq	out
	calls	#1,g^lib$put_output

	pushaq	san_fail
	calls	#1,g^lib$put_output
	movl	#SS$_REJECT,R0
	ret
L3:	NOP

	.ENDM	tst


san_fail:	.ascid	/>>> failed to understand the file structure <<</
bad_type:	.ascid	/>>> Bad type code found <<</



	.MACRO	sts	AR0,AERROR,?L3,?L4

	Tstl	Status
	Beql	L4
	movl	Status,R0
	Ret
L4:	nop

	.ENDM	Sts




	.library	/sys$login:peb/
	.library	/sys$library:lib/
	$prvdef
	$Maildef
	$hlpdef
        $notesdef
	$NOTESMSGDEF
	NOTEITEMS
	$ttdef
 	$tt2def
	$brkdef
	$Fscndef

fpmt:	
.ascid	/PAN Command (Help) > /


cpmt:	.ascid	/Cli     Pmt > /




; ---------------------------------------------------------------
	.entry	start,0



;	movab	Hand,(Fp)


; get the command line  (prompt if none)

	movl	#1000,command_line
	pushaw	command_line
	pushaq	Fpmt
	pushaq	command_line
	calls	#3,g^lib$get_Foreign
	check_eof


star:	nop


;extract
;answer
;reply
;write

; was that an ENOTES command ?

	cmpw	#^a/DI/,@command_line+4
	beql	500$
	cmpw	#^a/EX/,@command_line+4
	beql	500$
	cmpw	#^a/AN/,@command_line+4
	beql	500$
	cmpw	#^a/RE/,@command_line+4
	beql	500$
	cmpw	#^a/WR/,@command_line+4
	beql	500$
	brw	600$


500$:	nop

;	pushaq	enote_com
;	calls	#1,g^lib$put_output

	calls	#0,a_enotes_command
	ret
600$:	nop

	clrl	help_flag

; parse the command line

	pushaq	CPmt
	pushal	g^Lib$get_input
	pushal	g^Lib$get_input
	pushal	Table
	pushaq	command_line
	calls	#5,g^cli$dcl_parse
	check	r0,error



; --------------------------------------------------



	$getsyi_s	itmlst=syi_item
	check	r0,error

	$getjpiw_s	itmlst=jpi_item
	check	r0,error


	movl	#100,stamp
	$fao_s	ctrstr=ctr_stamp,outbuf=stamp,outlen=stamp,-
		p1=#Nodename,-
		p2=#15,-
		p3=#Username
;	pushaq	stamp
;	calls	#1,g^lib$put_output


	movw	stamp, stamp_l


; dispatch to the required routine

	calls	#0,g^cli$dispatch
	check	r0,error




; if that was help.. return to prompt

	tstl	help_flag
	beql	error

	movl	#1000,command_line
	pushaw	command_line
	pushaq	Fpmt
	pushaq	command_line
	calls	#3,g^lib$get_input
	check_eof

	brw	star

error:	ret


help_flag::	.blkl	1



; condition hand for the Mail routines (since they all signal, sigh)
; return error condition in Status & continue


	.entry  hand,^m<r2,r3,r4,r5,r6,r7,r8,r9> 
	nop
	nop

	pushaq	entry_hand
	calls	#1,g^lib$put_output

	nop

; get pointer to signal array           
                                        
        movl    chf$l_sigarglst(ap),r5  
        nop                             

	movl	chf$l_sig_name(r5),R5


	movl	R5,Status


	ret
; ---------------------------------------------------------------


	.entry	Notes_Notes,0

; get the command line

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Rest_of_line
	calls   #3,g^cli$get_value 
	check	r0,error


	pushaq	input
	calls	#1,g^lib$put_output

	pushaq	input
	calls	#1,g^notes$notes
	check	r0,error


	pushaq	thank
	calls	#1,g^lib$put_output

	ret


; move mail from selected folder to a notes conf

	.entry	add,0

	pushaq	single
	calls	#1,g^cli$present
	blbc	r0,6110$
	incl	single_flag
6110$:	nop



; newfolder???



	pushaq	newfolder
	calls	#1,g^cli$present
        blbc    r0,1678$

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  newfolder
	calls   #3,g^cli$get_value 
	check	r0,error	

	movw	input, Nfl
	movc3	input, @input+4, newfolder_name

1678$:	nop



; by user ?????

	pushaq	by_user
	calls	#1,g^cli$present
	blbc	r0,678$

	incl	by_user_flag

678$:	nop





; debug file

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  debug
	calls   #3,g^cli$get_value 
	check	r0,error	

	movl	#100,out
	$fao_s	ctrstr=ctr_debug,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

	movb	input,Dfab+fab$b_fns
	movl	input+4,Dfab+fab$l_fna

	$create	fab=Dfab
	check	r0,error

	$connect	rab=Drab
	check	r0,error




	pushaq	op_msg
	calls	#1,g^lib$put_output




; get the conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  conf
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i


; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	300$
301$:	nop

	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in
	

	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4


	incl	fred

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

300$:	nop
; create a new conf ??

	pushaq	create
	calls	#1,g^cli$Present
	blbc	r0,8$

	incl	create_flag

	movw	input,notes_open_i_create

	pushaq	op_msg_cre
	calls	#1,g^lib$put_output



        pushaw  notes_open_o
        pushaw  notes_open_i_create
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


	brw	1123$

8$:	nop



	movw	seen_map_len, se_mp

        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

1123$:	nop



; if we neither of MOD priv OR RMS access then fail over

	pushaq	hack
	calls	#1,g^cli$present
	blbs	r0,167$
	brw	166$
167$:	nop


; enable mod priv !!

	pushaq	get_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify
	check_fail





        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output







;	pushaq	imp_msg
;	calls	#1,g^lib$put_output


;	tst_priv	PRV$V_CMKRNL
;	tst_priv	PRV$V_BYPASS
;	tst_priv	PRV$V_SECURITY








	movb	descr,fab+fab$b_fns
	movl	descr+4,fab+fab$l_fna


	pushaq	o_msg
	calls	#1,g^lib$put_output

	$open	fab=fab
	check_fail


	$connect	rab=rab
	check_fail


 	incl	hack_flag

166$:	nop


	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       

	tstl	by_user_flag
	beql	8877$

        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  other_note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       

8877$:	nop


	pushaq	Dlm
	calls	#1,g^lib$put_output

; begin

	movab	Hand,(Fp)

	pushaw	begin_out
	pushaw	Null
	pushal	mail_cont
	calls	#3,g^mail$mailfile_begin
	Sts	r0,error


; tack on MAIL.MAI


	movab	DEFmail_dir, R6
	addl2	DEFmail_dir_len, R6
	incl	R6
	movc3	#a2, a1, (R6)
	addl2	#a2, DEFmail_dir_len
	incl	DEFmail_dir_len


	movl	DEFmail_dir_len, descr
	movab	DEFmail_dir, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output






	movl	#100,out
	$fao_s	ctrstr=ctr_d,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


	movw	DEFmail_dir_len, def_it

; open the mail file


	pushaq	dir
	calls	#1,g^cli$present
	blbc	r0,55$


	movl    #100,Out
	Pushaw  Out
	pushaq  Out
	pushaq  Dir
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	Out, open_in
	movab	out+8,open_in+4

55$:	nop


	pushaw	open_out
	pushaw	open_in
	pushal	mail_cont
	calls	#3,g^mail$mailfile_open
	Sts	r0,error




; tell us the mail file name & how many deleted bytes

	movl	#100,out
	$fao_s	ctrstr=ctr1,outbuf=out,outlen=out,-
		p1=mail_dir_len,-
		p2=#mail_dir,-
		p3=deleted_bytes 
	pushaq	out
	calls	#1,g^lib$put_output


	movw	mail_dir_len, defl






; message begin

	clrl	message_cont
	clrl	status


	pushaw	message_out
	pushaw	message_in
	pushal	message_cont
	calls	#3,g^mail$message_begin
	Sts	r0,error



; get the folder name

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  folder
	calls   #3,g^cli$get_value 
	check	r0,error



	movw	input,add_add_i
	movab	input+8,add_add_i+4





	movw	input,Self_In

	pushaw	self_out
	pushaw	self_in
	pushal	message_cont
	calls	#3,g^mail$message_select
	Sts	r0,error




; tell us how many messages in folder

	movl	#100,out
	$fao_s	ctrstr=ctr2,outbuf=out,outlen=out,-
		p1=message_selected
	pushaq	out
	calls	#1,g^lib$put_output

	pushaq	Dlm
	calls	#1,g^lib$put_output



        movab   rec,add_txt_st
	movw	#notes$k_continue,add_txt_i+2



; /REPLY = nnnnn ???????


	pushaq	master_topic
	calls	#1,g^cli$present
	blbs	r0,124$
	brw	123$
124$:	nop

	movl    #100,Out
	Pushaw  Out
	pushaq  Out
	pushaq  master_topic
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	out,get_i

        pushaw  add_add_o
        pushaw  get_i
        pushal  note_cont
        calls   #3,g^notes$note_get
        check   r0,error

	pushaq	rep_msg
	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_p1,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
	pushaq	out
	calls	#1,g^lib$put_output





	movl	uid,base_uid

	brw	loop

123$:	nop

; /title ???

	pushaq	atitle
	calls	#1,g^cli$present
	blbc	r0,66$


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  atitle
	calls   #3,g^cli$get_value 
	check	r0,error



	movw	input,add_add_i
	movab	input+8,add_add_i+4




66$:	nop

	tstl	by_user_flag
	beql	5319$
	brw	loop
5319$:	nop


; create an empty base note

        pushaw  add_add_o
        pushaw  add_add_i
        pushal  note_cont
        calls   #3,g^notes$note_add
        check   r0,error





	movl	uid,base_uid




	movw	#0, add_txt_len

        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


       movw    #notes$k_text_end,add_txt_i+2


        cvtbw   null,add_txt_len
        movab   null+8,add_txt_st

        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error





loop:	nop

;	pushaq	dlm
;	calls	#1,g^lib$put_output
	put_de	dlm


        movab   rec,add_txt_st
	movw	#notes$k_continue,add_txt_i+2



	pushaw	search_out
	pushaw	search_in
	pushal	message_cont
	calls	#3,g^mail$message_Info
	blbs	r0,755$
	cmpl	R0, #^x007E8052		; no more messages
	bneq	756$
	brw	add_end
756$:	nop
	ret
755$:	nop



; if doing /by_user then  find the right note to reply to


	tstl	by_user_flag
	bneq	5511$
	brw	145$
5511$:	nop

; generate the required title


	locc	#^a/ /,author_len,author
	movl	R0,R6

	subl3	R6, author_len, R6

	movl	#100,out
	$fao_s	ctrstr=ctr_by,outbuf=out,outlen=out,-
		p1=R6,-
		p2=#Author
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out


; now search for a topic with that title

	movw	out, find_top_i

        pushaw  find_top_o
        pushaw  find_top_i
        pushal  other_note_cont
        calls   #3,G^Notes$note_get
	blbc	r0,6000$
	brw	6010$
6000$:	nop

	cmpl	r0,#NOTES$_NO_SUCH_NOTE
	beql	6001$
	ret
6001$:	nop




	put_de	cre_empty


; create an empty base note

	movw	#peb_name_len, add_add_i+12
	movab	peb_name, add_add_i+16

	movw	out, add_add_i
	movab	out+8, add_add_i+4

	put_de	out

	movw	#notes$k_note_mark_seen, zzz

        pushaw  add_add_o
        pushaw  add_add_i
        pushal  other_note_cont
        calls   #3,g^notes$note_add
        check   r0,error

	movw	#notes$k_noop, zzz



	movl	uid,find_top_uid




	movw	#0, add_txt_len

        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  other_note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


       movw    #notes$k_text_end,add_txt_i+2


        cvtbw   null,add_txt_len
        movab   null+8,add_txt_st

        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  other_note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


        movab   rec,add_txt_st
	movw	#notes$k_continue,add_txt_i+2

6010$:	nop

	movl	find_top_uid, base_uid



145$:	nop

	movl	#79,out
	$fao_s	ctrstr=ctrx22,outbuf=out,outlen=out,-
		p1=author_len,-
		p2=#author
	pushaq	out
	calls	#1,g^lib$put_output
	put_de	out

; check... and if the author line looks like
; Andy u?u Leslie VMS/CSSE Newbury  12-Oct-1989 1335"
;
; then drop the date / time bit




	movab	author, R6
	addl2	Author_len , R6

	subl2	#5, R6

	movl	#4, Descr
	movl	R6, Descr+4

;	pushaq	descr
;	calls	#1,g^lib$put_output

; is this a number ???

	
        pushal  Tmp
        pushaq  Descr
        calls   #2,g^OTS$CVT_TI_L
	blbc	r0,150$
	
; is the rest a date ???

	subl2	#12, R6

	movl	#11, Descr
	movl	R6, Descr+4

;	pushaq	descr
;	calls	#1,g^lib$put_output


	pushaq	descr
	pushaq	descr
        calls   #2,g^str$upcase


	$bintim_s	timbuf=descr,-
			timadr=quad
	blbc	r0,150$

	
	movab	Author, R3
	subl3	R3, Descr+4, Author_len

	brw	145$



150$:	nop

	movl	#79,out
	$fao_s	ctrstr=ctry22,outbuf=out,outlen=out,-
		p1=Subject_len,-
		p2=#subject
		
	pushaq	out
	calls	#1,g^lib$put_output
	put_de	out


; start the add process

        cvtlw   Subject_len,add_add_i
        cvtlw   Subject_len,add_add_iC


        cvtlw   author_len,Add_Add_I+12
        cvtlw   author_len,Add_Add_IC+12

	movw	#0,Add_Add_I+12
	movw	#0,Add_Add_IC+12




	locc	#^a/"/,author_len,author
	beql	49$

	decl	r0
	incl	r1


	movl	R1,R6
	movl	r0,R7

	brw	48$


44$:	nop



	tstl	R7
	beql	49$

	cmpb	#^a/ /,(R6)
	bneq	48$

	incl	R6
	decl	R7

	tstl	R7
	beql	49$

	brw	44$

48$:	nop


	movc3	R7,(R6),Pen_Name
        movw	R7,Add_Add_I+12
	movw	R7,Add_Add_IC+12


49$:	nop

	tstl	hack_flag
	bneq	123$
	clrw	Add_Add_I+12
	clrw	Add_Add_IC+12
123$:	nop                   	


	tstl	single_flag
	beql	4990$
	movw	#notes$k_noop, s_s
4990$:	nop


        pushaw  add_add_o
        pushaw  add_add_IC
        pushal  note_cont
        calls   #3,g^notes$note_add
        check   r0,error


; stamp it
	movl	Uid, uid_to_stamp



; tell us

	movl	#100,out
	$fao_s	ctrstr=ctr19,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id
	pushaq	out
	calls	#1,g^lib$put_output
	put_de	out





; get the text for this message

        pushaw  txt_out
        pushaw  txt_in
        pushal  message_cont
        calls   #3,g^mail$message_get
	blbs	r0,55$
	cmpl	R0, #^x007E8052		; no more messages
	bneq	56$
	brw	add_end
56$:	nop
	ret
55$:	nop




txt_loop:	nop


        pushaw  txt1_out
        pushaw  txt1_in
        pushal  message_cont
        calls   #3,g^mail$message_get
	blbs	r0,10$
        cmpl    r0,#^x007EDFA8 ; no more rec
	bneq	20$
	brw	end_add
20$:	ret
10$:	nop


; if this this the From: line we need to add ; MAIL$_MESSAGE_DATE
; (ie the FIRST line!)


	tstl	MESSAGE_DATE_len
	beql	1000$

	movl	#500, out
	$fao_s	ctrstr=ctr_apd,outbuf=out,outlen=out,-
		p1=rec_len,-
		p2=#rec,-
		p3=MESSAGE_DATE_len,-
		p4=#MESSAGE_DATE

	clrl	MESSAGE_DATE_len

	movl	out, rec_len
	movc3	out, out+8, rec

1000$:	nop
		


	movl	rec_len, Descr
	movab	Rec,     Descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output


	movw	rec_len, add_txt_len

        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error




	brw	txt_loop



end_add:	nop




       movw    #notes$k_text_end,add_txt_i+2


;'''''''''''''''''''''''''''''''''''''''''''''''''''
; a blank line
        cvtbw   null,add_txt_len
        movab   null+8,add_txt_st

        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


	pushaw	null
	pushaw	stamp_in
	pushal	note_cont
	calls	#3,g^notes$note_modify
	check	r0,error


; move that message???

	tstw	nfl
	beql	515$

	pushaw	copy_out
	pushaw	copy_in
	pushal	message_cont
	calls	#3,g^mail$message_Copy
	Sts	r0,error

515$:	nop



	tstl	hack_flag
	bneq	500$
	brw	loop
500$:	nop

	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz

	movc5	#0,(sp),#0,#10000,buffer
	movc5	#0,(sp),#0,#10000,save_1
	movc5	#0,(sp),#0,#10000,save_2

	$get	rab=rab
	check	r0,error
	

; sanity check....


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Author


; ret_note_author
; ret_note_author_len


	movzbl	buffer+77,descr
	movab	buffer+78,descr+4

	movl	#100,out
	$fao_s	ctrstr=xctr2,outbuf=out,outlen=out,-
		p1=#Descr
;	pushaq	out
;	calls	#1,g^lib$put_output

	cmpl	descr, ret_note_author_len
	tst

	cmpc3	descr,ret_note_author,@Descr+4
	tst

; blank fill the author field

	movab	author,R6
	addl2	author_len,R6

	movc5	#0,(sp),#^a/ /,#10,(R6)


; hack the author field....

	movzbl	buffer+77,descr
	movab	buffer+78,descr+4


; save...

	addl3	descr,descr+4,R6
	movc3	#3000,(R6), Save_1	


	movab	buffer+78, R6


	movc3	author_len,author, (R6)	
	decl	r6
	movb	author_len,(R6)

; restore

	addl3	author_len ,descr+4,R6
	movc3	#3000,Save_1, (R6)



	movzwl	rab+rab$w_rsz,R6
	subl2	descr,R6
	addl2	author_len,R6



	movl	author_len, descr


;	movzwl	rab+rab$w_rsz,R6
;	addl2	#40,R6

	movw	R6, rab+rab$w_rsz
	movw	R6, rab+rab$w_usz





; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; date
; ret_note_time

	addl3	descr,descr+4,R6

	addl2	#2,R6


	movq	(R6),Quad
	
	movq	binary_date, (R6)

	movl	#100,out
	$fao_s	ctrstr=xctr1,outbuf=out,outlen=out,-
		p1=#Quad
;	pushaq	out
;	calls	#1,g^lib$put_output

	cmpl	quad, ret_note_time
	tst

	cmpl	quad+4, ret_note_time+4
	tst


	brw	skip
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Title


; ret_note_title
; ret_note_title_len

	addl3	descr,descr+4,R6

	addl2	#12,R6


	movzwl	(R6),Descr
	movl	R6,Descr+4


	movl	#100,out
	$fao_s	ctrstr=xctr3,outbuf=out,outlen=out,-
		p1=#Descr
;	pushaq	out
;	calls	#1,g^lib$put_output



;	cmpl	descr, ret_note_title_len
;	tst

	cmpc3	ret_note_title_len, ret_note_title, @descr+4
	tst


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; personal name

; ret_per_name
; ret_per_name_len




	addl3	descr,descr+4,R6




	addl2	#1,R6


	movzbl	(R6),Descr
	movl	R6,Descr+4
	incl	Descr+4



	movl	#100,out
	$fao_s	ctrstr=xctr4,outbuf=out,outlen=out,-
		p1=#Descr
;	pushaq	out
;	calls	#1,g^lib$put_output



;	cmpl	ret_per_name_len, descr
;	tst

	cmpc3	ret_per_name_len, ret_per_name, @descr+4
	tst
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


skip:	nop

	$update	rab=rab
	check	r0,error



	brw	loop



add_end:	nop

	pushaq	end_of_add
	calls	#1,g^lib$put_output

; is there a notebook ?

	tstl	notebook_file_cont
	bneq	10$
	ret
10$:	nop

; are we doing by_user

	tstl	by_user_flag
	bneq	20$
	ret
20$:	nop



	pushaw	end_o
	pushaw	null
        pushal  file_cont
	calls	#3,g^notes$notefile_end
	check	r0,error




	pushaq	entry_mod
	calls	#1,g^lib$put_output
; update the entry

	movw	seen_map_len, se_mp1
	movw	entry_name_len, mod_ent_i



	pushaw	null
	pushaw	mod_ent_i
	pushal	notebook_cont
	calls	#3,g^notes$entry_modify
	check	r0,error	



	ret
entry_mod:	.ascid	/%PAN-I-SETEM, Setting empty base notes to SEEN status/

mod_ent_i:	.word	0
		.word	notes$k_entry_name
		.long	entry_name
		.long	0
;
se_mp1:		.word	0
		.word	notes$k_seen_map
		.long	seen_map
		.long	0
;
		.long	0








end_o:		.word	3000
		.word	notes$k_seen_map
		.long	seen_map
		.long	seen_map_len
;
		.long	0


end_of_add:	.ascid	/                    >>>>>>>>> End of add <<<<<<<<< /

; return number of deleted bytes in mail file
; & its full file spec (we need this later)

open_out:	.word	4
		.word	mail$_mailfile_deleted_bytes
		.long	deleted_bytes 
		.long	0
;
		.word	250
		.word	mail$_mailfile_resultspec
		.long	Mail_dir
		.long	Mail_dir_len
;
		.long	0

deleted_bytes:	.blkl	1






open_in:	.word	0
		.word	mail$_mailfile_name
		.long	0
		.long	0
;
def_it:		.word	0
		.word	MAIL$_MAILFILE_DEFAULT_NAME
		.long	DEFmail_dir
		.long	0
;
		.long	0



; a blank item list

Null:		.word	0
		.word	0
		.long	0
		.long	0
;
		.long	0



; tell us the mail spec for the mail file

begin_out:	.word	150
		.word	mail$_mailfile_mail_directory
		.long	DEFmail_dir
		.long	DEFmail_dir_len
;
		.long	0


DEFmail_dir:		.blkb	200
DEFmail_dir_len:	.blkl	1


Mail_Dir_Len:	.blkl	1
Mail_Dir:	.blkb	255





; search input item list, get the next mesage

search_in:	.word	4
		.word	mail$_message_next
		.long	0
		.long	0
;
		.long	0


; search output item list, tell us 

; the subject line
; who sent it to us
; the message Id

search_out:	.word	255
		.word	mail$_message_subject
		.long	subject
		.long	subject_len
;
		.word	8
		.word	mail$_message_binary_date
		.long	binary_date
		.long	0
;
		.word	255
		.word	mail$_message_From
		.long	Author
		.long	Author_Len
;
		.word	4
		.word	mail$_message_current_id
		.long	Id
		.long	0
;		
		.word	255
		.word	mail$_message_extid
		.long	Extid
		.long	Extid_len
;
		.word	255
		.word	MAIL$_MESSAGE_DATE
		.long	MESSAGE_DATE
		.long	MESSAGE_DATE_len
;
		.long	0

MESSAGE_DATE:		.blkb	255
MESSAGE_DATE_len:	.blkl	1


binary_date:	.blkl	2

Extid:		.blkb	255
Extid_Len:	.blkl	1




Author:		.blkb	255
Author_Len:	.Blkl	1

id:		.blkl	1


subject:	.blkb	255
subject_len:	.long	1




Status:	.blkl	1


; selection item list, select the right (input) folder 

self_in:	.word	0
		.word	mail$_message_folder
		.long	Input+8
		.long	0
;
		.long	0

; selection output list, tell us the number of messages
; in this folder

self_out:	.word	4
		.word	mail$_message_selected
		.long	message_selected
		.long	0
;
		.long	0




; pass context to message_begin 

message_in:	.word	4
		.word	mail$_message_file_ctx
		.long	mail_cont
		.long	0
;
		.long	0



; 

message_out:	.word	4
		.word	mail$_message_selected
		.long	message_selected
		.long	0
;
		.long	0

message_selected:	.blkl	1


message_cont:	.blkl	1

mail_cont:	.blkl	1

input:	.long	300
	.long	input+8
	.blkb	300

descr:		.blkl	2
ctr1:	.ascid	/%PAN-I-MAILF, Mail file is   !AD    (!UL Deleted Bytes)/
ctr2:	.ascid	/     !4UL  messages in folder  /




folder:	.ascid	/FOLDER/


OUT:	.long	500
	.long	out+8
	.blkb	500


ctr22:	.ascid	/|!25AD|!40AD|/



notes_open_i:   .word   0
                .word   notes$k_notefile_file_name
                .long   input+8
                .long   0
;
def_l:          .word   default_name_len
                .word   notes$k_notefile_default_name
def_n:          .long   default_name
                .long   default_name_len
;
se_mp:		.word	0
		.word	notes$k_seen_map
		.long	seen_map
		.long	0
;
                .long   0



notes_open_o:   .word   100
                .word   notes$k_notefile_title
                .long   title
                .long   title_len
;
                .word   150
                .word   notes$k_notefile_result_spec
                .long   result_spec
                .long   result_spec_len
;
                .word   100
                .word   notes$k_notefile_notice
                .long   notice
                .long   notice_len
;
		.word	4
		.word	notes$k_notefile_restricted
		.long	is_restricted
		.long	0
;
		.word	300
		.word	notes$k_notefile_moderator
		.long	moderator_st
		.long	moderator_st_len
;
		.word	4
		.word	notes$k_notefile_high_uid
		.long	max_uid_in_high_uid
		.long	0
;
                .long   0
                                                                               

max_uid_in_high_uid:	.blkl	1

is_restricted:	.blkl	1

notice:         .blkb   100
notice_len:     .blkl   1

title:          .blkb   100
title_len:      .blkl   1


result_spec:            .blkb   150
result_spec_len:        .blkl   1


l_default_name:   .ascii  /.Note/
l_default_name_len =. - l_default_name
                                                                  

default_name:   .ascii  /Notes$library:.Note/
default_name_len =. - default_name


full_default_name:   .ascii  /Notes$Library:.Note/
full_default_name_len =. - full_default_name







notes_beg_i:    .word   4
                .word   notes$k_notefile_context
                .long   file_cont
                .long   0
;
                .word   4
                .word   notes$k_nosignal
                .long   no_sig
                .long   0

;
                .long   0


notes_beg_o:    .word   4
                .word   notes$k_notefile_numnotes
                .long   number_of_notes
                .long   0
;
                .long   0
                                                                                

NUMBER_OF_NOTES:	.blkl	1
no_sig:		.long	1
NOTE_CONT:		.blkl	1
file_cont:	.blkl	1



conf:	.ascid	/CONF/



entry_hand:	
.ascid	/ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc/

dlm:	
.ascid	/-------------------------------------------------------------------------------/


dlm_et:	
.ascid	/+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++/

txt_in:         .word   4
                .word   mail$_message_id
                .long   Id
                .long   0
;
                .long   0

txt_out:        .word   255
                .word   mail$_message_extid
                .long   Extid
                .long   Extid_len
;
                .long   0
                                                 


txt1_in:        .word   4
                .word   mail$_message_continue
                .long   txt_continue
                .long   0
;
                .long   0




txt1_out:       .word   255
                .word   mail$_message_record
                .long   rec
                .long   rec_len
;
                .word   255
                .word   mail$_message_subject
                .long   subject
                .long   subject_len
;
                .word   255
                .word   mail$_message_Sender
                .long   Author
                .long   Author_Len
;
                .long   0
                                                    

rec:            .blkb   1000

rec_len:        .blkl   1


txt_continue:   .blkl   1



add_add_IC:	.word   0
                .word   notes$k_note_title
                .long   subject
                .long   0
;
                .word   0
                .word   Notes$K_Note_pen_Name
                .long   pen_name
                .long   0
;
		.word	4
s_s:		.word	notes$k_note_blink_uid
		.long	base_uid
		.long	0
;
                .long   0




pen_name_len:	.blkl	1
pen_name:	.blkb	100


add_add_i:      .word   0
                .word   notes$k_note_title
                .long   subject
                .long   0
;
                .word   peb_name_len
                .word   Notes$K_Note_pen_Name
                .long   peb_name
                .long   0
;
		.word	4
zzz:		.word	notes$k_noop
		.long	no_sig
		.long	0
;
                .long   0


peb_name:	.ascii	/Mail-To-Notes  (Peb software inc)/
peb_name_len = . - peb_name















add_txt_i:      .word   4
                .word   notes$k_continue
                .long   continue
                .long   0
;
add_txt_len:    .word   4
                .word   notes$k_text_string
add_txt_st:     .long   rec
                .long   0
;
                .long   0

add_txt_o:      .word   4
                .word   notes$k_text_type
                .long   text_type
                .long   0
;
                .long   0

text_type:      .blkl   1
continue:       .long   1


ctr19:	.ascid	/%PAN-I-ADDED,            Added as Note !AD /

fred:	.blkl	1

atitle:	.ascid	/TITLE/

hack:	.ascid	/IMPERSONATE/
hack_flag:	.blkl	1






add_add_o:      .word   20
                .word   notes$k_note_id
                .long   note_id
                .long   note_id_len
;
		.word	4
		.word	notes$k_note_uid
		.long	uid
		.long	0
;
                .word   100
                .word   Notes$K_Note_pen_Name
                .long   ret_per_name
                .long   ret_per_name_len
;

		.word	100
		.word	notes$k_note_author
		.long	ret_note_author
		.long	ret_note_author_len
;
		.word	100
		.word	notes$k_note_title
		.long	ret_note_title
		.long	ret_note_title_len
;
		.word	4
		.word	notes$k_note_numrecords
		.long	number_of_lines
		.long	0
;
		.word	8
		.word	notes$k_note_create_time
		.long	ret_note_time
		.long	0
;
		.word	4
		.word	notes$k_note_hidden
		.long	note_hidden
		.long	0
;
		.word	100
		.word	notes$k_notefile_file_name
		.long	Notefile_file_name
		.long	Notefile_file_name_len
;
		.word	100
		.word	notes$k_note_user_area
		.long	note_user_area
		.long	note_user_area_len
;
		.long	0


file_name:		.blkl	2

; ********** start of note detail data area **************
detail_area:	

uid:			.blkl	1

note_id:        	.blkb   50
note_id_len:    	.blkl   1

note_user_area_len:	.blkl	1
note_user_area:		.blkb	100

Notefile_file_name:	.blkb	100
Notefile_file_name_len:	.blkl	1

note_hidden:		.blkl	1

number_of_lines:	.blkl	1

ret_per_name:		.blkb	100
ret_per_name_len:	.blkl	1

ret_note_author:	.blkb	100
ret_note_author_len:	.blkl	1

ret_note_title:		.blkb	100
ret_note_title_len:	.blkl	1

ret_note_time:		.blkl	2

; **********   end of note detail data area **************
detail_size = . - detail_area

save_detail:	.blkb	detail_size




a1:	.ascii	/MAIL.MAI/
a2 = . - a1

dir:	.ascid	/DIR/


ctr_d:	.ascid	/%PAN-I-DEFMAIL, Default mail file is !AS/


op_msg:	.ascid	/%PAN-I-OPEN_C, Opening the notes conference/
o_msg:	.ascid	/%PAN-I-OPEN_R, Opening file for RMS access/




xctr1:   .ascid  /Date added = "!%D"/
xctr2:   .ascid  /    Author = "!AS"/
xctr4:   .ascid  /  Personal = "!AS"/
xctr3:   .ascid  /     Title = "!AS"/
ctr_xt:	 .ascid	 +     Lines =  !UL / !UL+

quad:	.blkl	2

hat:	.ascid	/ ------------------ WHAT ?----------------------/


tmp:	.blkl	2



ctrx22:	.ascid	/From:    !AD/
ctry22:	.ascid	/Subject: !AD/


get_I:	.word	0
	.word	notes$k_note_id
	.long	out+8
	.long	0
;
        .word   4
        .word   notes$k_nosignal
        .long   no_sig
        .long   0
;
	.word	8
g_bt:	.word	notes$k_noop
	.long	b_quad
	.long	0
;
	.word	8
g_st:	.word	notes$k_noop
	.long	s_quad
	.long	0
;
	.long	0

reply:	.ascid	/REPLY/

rep_msg:	.ascid	/      Adding replies to base note ............../
ctr_p1:		.ascid	/Note !AD   !AD  !AD  !UL lines/






priv:	.blkl	2



priv_e:	.ascid	+/IMPERSONATE  requires CMKRNL, BYPASS and SECURITY +






	.entry	Replace,0

; get the text file 

	pushaq	o_t_f
	calls	#1,g^lib$put_output

	movl    #100,Out
	Pushaw  Out
	pushaq  Out
	pushaq  in_file
	calls   #3,g^cli$get_value 
	check	r0,error

	movb	Out,Tfab+fab$b_fns
	movl	Out+4,Tfab+fab$l_fna


	$Open	fab=Tfab
	check	r0,error

	$connect	rab=Trab
	check	r0,error





;	pushaq	imp_msg
;	calls	#1,g^lib$put_output


;	tst_priv	PRV$V_CMKRNL
;	tst_priv	PRV$V_BYPASS
;	tst_priv	PRV$V_SECURITY






	pushaq	op_msg
	calls	#1,g^lib$put_output




; get the conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  conf
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i


; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	300$
301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in



	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

300$:	nop



        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


	pushaq	get_mod
	calls	#1,g^lib$put_output




        pushaw  open_o
        pushaw  open_m
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error



        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




	movb	descr,fab+fab$b_fns
	movl	descr+4,fab+fab$l_fna


	pushaq	o_msg
	calls	#1,g^lib$put_output

	$open	fab=fab
	check	r0,error

	$connect	rab=rab
	check	r0,error


	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; 
; create a dummy conf

	pushaq	op_msg
	calls	#1,g^lib$put_output

        pushaw  notes_open_o
        pushaw  notes_open_create
        pushal  tmp_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



; and open that...

	pushaq	o_msg
	calls	#1,g^lib$put_output

	movb	descr,tmp_fab+fab$b_fns
	movl	descr+4,tmp_fab+fab$l_fna



	$open	fab=tmp_fab
	check	r0,error

	$connect	rab=tmp_rab
	check	r0,error






        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       






; begin on tmp 

	MOVAB	TMP_FILE_CONT, notes_beg_i+4


        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  tmp_note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       





	pushaq	Dlm
	calls	#1,g^lib$put_output






        movab   rec,add_txt_st
	movw	#notes$k_continue,add_txt_i+2



; get the reply number..



	movl    #100,Out
	Pushaw  Out
	pushaq  Out
	pushaq  notes
	calls   #3,g^cli$get_value 
	check	r0,error

	movl	out,r_note_len
	movc3	out,@out+4,r_note_id



; and access that note

	movw	out,get_i
	movw	out,get_i_seen


	movc3	out, @out+4, note_s


        pushaw  add_add_o
        pushaw  get_i
        pushal  note_cont
        calls   #3,g^notes$note_get
        check   r0,error



; stamp it
	movl	Uid, uid_to_stamp

	pushaq	seen
	calls	#1,g^cli$present
	blbc	r0,18$
	movl	#0, seen_status
	incl	seen_flag
18$:	nop



	pushaq	UNseen
	calls	#1,g^cli$present
	blbc	r0,19$
	movl	#1, seen_status
	incl	seen_flag
19$:	nop



; tell us about it


	movl	#100,out
	$fao_s	ctrstr=ctr_p1,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
	pushaq	out
	calls	#1,g^lib$put_output

; modify seen / unseen ?

	tstl	seen_flag
	bneq	499$
	brw	500$
499$:	nop

	pushaq	se_msg
	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_se,outbuf=out,outlen=out,-
		p1=seen_status
	pushaq	out
	calls	#1,g^lib$put_output




        pushaw  add_add_o
        pushaw  get_i_seen
        pushal  note_cont
        calls   #3,g^notes$note_modify
        check   r0,error

	movl	#100,out
	$fao_s	ctrstr=ctr_p1,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
	pushaq	out
	calls	#1,g^lib$put_output

500$:	nop


; check that this is the note we wanted

	cmpc3	r_note_len, note_id, r_note_id
	beql	448$
	pushaq	no_ask
	calls	#1,g^lib$put_output
	ret
448$:	nop





; enter the text as a new note

	movw	ret_note_title_len, ti_len
	movw	ret_per_name_len, add_tmp_i

        pushaw  add_tmp_o
        pushaw  add_tmp_i
        pushal  tmp_note_cont
        calls   #3,g^notes$note_add
        check   r0,error






	movl	#100,out
	$fao_s	ctrstr=ctr_p2,outbuf=out,outlen=out,-
		p1=tmp_note_id_len,-
		p2=#tmp_note_id
	pushaq	out
	calls	#1,g^lib$put_output

; now enter the text....


r_loop:	nop


	movw	#10000,Trab+rab$w_rsz
	movw	#10000,Trab+rab$w_usz

	$get	rab=Trab
	blbs	r0,10$
	cmpl	r0,#rms$_eof
	beql	r_loop_end
	ret
10$:	nop

	incl	text_lines


	movab	Tbuffer, add_txt_st
	movw	Trab+rab$w_rsz, add_txt_len


	pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  tmp_note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


	movw	#notes$k_continue,add_txt_i+2


	brw	r_loop


r_loop_end:	nop









	pushaq	dlm
	calls	#1,g^lib$put_output




	movw	#0, add_txt_len
	movw	#notes$k_text_end,add_txt_i+2


	pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  tmp_note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


	$close	fab=Tfab
	check	r0,error


; --------------------------------------------------------------




; get the note_id field for the original note


	movab	uid, rab+rab$l_kbf

	$rab_store	rab=rab, Rac=Key


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz

	$get	rab=rab
	check	r0,error

	movl	buffer+72, orig_noteid

; and for the tmp file



	movab	tmp_uid, tmp_rab+rab$l_kbf

	$rab_store	rab=tmp_rab, Rac=Key


	movw	#10000,tmp_rab+rab$w_rsz
	movw	#10000,tmp_rab+rab$w_usz

	$get	rab=tmp_rab
	check	r0,error

	movl	buffer+72, tmp_noteid




; --------------------------------------------------

; now delete all text records from the original note



	movab	orig_noteid, rab+rab$l_kbf
	movb	#1,rab+rab$b_krf

	$rab_store	rab=rab,rac=Key


	pushaq	del_t_orig
	calls	#1,g^lib$put_output





del_t:	nop

;	pushaq	ab_r1
;	calls	#1,g^lib$put_output

	$get	rab=rab
	blbs	r0,10$
	brw	del_t_end
10$:	nop


	$rab_store	rab=rab,rac=seq



	cmpl	buffer+72, orig_noteid
;	bneq	del_t_end
	beql	20$
	brw	del_t_end
20$:	nop


	movl	#100,out
	$fao_s	ctrstr=ctr_dr,outbuf=out,outlen=out,-
		p1=buffer,-
		p2=buffer+72
;	pushaq	out
;	calls	#1,g^lib$put_output



; if this is a text record then save the header

	cmpb	#^x80,Buffer+3
	bneq	139$
	tstl	head
	bneq	139$

	movl	buffer, head

139$:	nop



; delete record (if text)

	cmpb	#^x80,Buffer+3
	bneq	39$

;	pushaq	ab_r2
;	calls	#1,g^lib$put_output

	$delete	rab=rab
	check	r0,error


39$:	nop

	brw	del_t


del_t_end:	nop


	tstl	head
	bneq	41$
	pushaq	emp
	calls	#1,g^lib$put_output
	ret
41$:	nop


	pushaq	Dlm
	calls	#1,g^lib$put_output




; --------------------------------------------------------------

; paste text records from tmp file into the real file


	pushaq	paste
	calls	#1,g^lib$put_output




	movab	tmp_noteid, tmp_rab+rab$l_kbf
	movb	#1,tmp_rab+rab$b_krf

	$rab_store	rab=tmp_rab,rac=Key
	$rab_store	rab=rab,rac=Key


	movw	#10000,tmp_rab+rab$w_rsz
	movw	#10000,tmp_rab+rab$w_usz


pas_t:	nop

;	pushaq	ab_r1
;	calls	#1,g^lib$put_output

	$get	rab=tmp_rab
	blbs	r0,10$
	brw	pas_t_end
10$:	nop


	$rab_store	rab=tmp_rab,rac=seq



	cmpl	buffer+72, tmp_noteid
	beql	20$
	brw	pas_t_end
20$:	nop


	movl	#100,out
	$fao_s	ctrstr=ctr_dr,outbuf=out,outlen=out,-
		p1=buffer,-
		p2=buffer+72
;	pushaq	out
;	calls	#1,g^lib$put_output






; if this is a text record paste it into the real file

	cmpb	#^x80,Buffer+3
;	bneq	39$
	beql	38$
	brw	39$
38$:	nop

	movl	head, buffer
	incb	head

	movw	tmp_rab+rab$w_rsz, Rab+rab$w_rsz
	movw	tmp_rab+rab$w_rsz, Rab+rab$w_usz


	movl	orig_noteid, buffer+72

;	pushaq	ab_r3
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_dr,outbuf=out,outlen=out,-
		p1=buffer,-
		p2=buffer+72
;	pushaq	out
;	calls	#1,g^lib$put_output



	$put	rab=rab
	check	r0,error


39$:	nop

	brw	pas_t


pas_t_end:	nop


; modify the lines count field




	pushaq	mod_lin
	calls	#1,g^lib$put_output



	movab	orig_noteid, rab+rab$l_kbf
	movb	#1,rab+rab$b_krf

	$rab_store	rab=rab,rac=Key


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	$get	rab=rab
	check	r0,error

	$rab_store	rab=rab,rac=Seq

	movw	rab+rab$w_rsz, Descr

; make sure its a header record


	cmpb	#^x40,Buffer+3
	beql	10$
	pushaq	not_head
	calls	#1,g^lib$put_output
	ret
10$:	nop


; locate the line count field




	movab	buffer, R6
	addl	#76, R6


200$:	nop

	movb	(R6), type
	incl	r6
	movzbl	(R6), type_len


	cmpb	type,  #type_un1    
	bneq	888$
	movl	#1, Type_Len	
888$:	nop


;	movl	#100,out
;	$fao_s	ctrstr=ctr_hhhhh,outbuf=out,outlen=out,-
;		p1=type,-
;		p2=type_len
;	pushaq	out
;	calls	#1,g^lib$put_output


	tstb	type
	bneq	44$
	pushaq	bad_type
	calls	#1,g^lib$put_output
	ret
44$:	nop


	cmpb	type, #type_li
	beql	250$

	


	addl2	type_len, r6

	incl	R6


	brw	200$

250$:	nop

	incl	R6



; check it !!!




	movl	#100,out
	$fao_s	ctrstr=ctr_ot1,outbuf=out,outlen=out,-
		p1=(R6),-
		p2=number_of_lines
	pushaq	out
	calls	#1,g^lib$put_output



	cmpl	(R6), Number_Of_Lines
	tst




	movw	Descr, rab+rab$w_usz
	movw	Descr, rab+rab$w_rsz

	movl	text_lines, (R6)

	$update	rab=rab
	check	r0,error


	$close	Fab=Fab
	check	r0,error


        pushaw  null
        pushaw  null
        pushal  tmp_note_cont
        calls   #3,G^Notes$note_end
        check   r0,error                                                                       
	

        pushaw  null
        pushaw  null
        pushal  tmp_file_cont
        calls   #3,G^Notes$notefile_end
        check   r0,error


	$fab_store	fab=tmp_fab,xab=xxab
	$rab_store	rab=tmp_rab,rac=key,ksz=#4,kbf=uid
	clrl	uid

	$get	rab=tmp_rab
	check	r0,error

	$update	rab=tmp_rab
	check	r0,error

;	$close	Fab=tmp_Fab
;	check	r0,error


	pushaw	null
	pushaw	stamp_in
	pushal	note_cont
	calls	#3,g^notes$note_modify
	check	r0,error


	ret






ctr_ty:	.ascid	/(!5UL Bytes)    Buffer !XL        Buffer+72 !XL/

imp_msg:	.ascid	+NOTE: Copying usernames is unsupported..................+

ctr_ty1:	.ascid	/!AS/


ctr_ty4:	.ascid	/!5UB  !5UB  !5UB  !5UB /

save_head:	.blkb	500

head:	.blkl	1

TText:	.ascid	/TEXT/


o_t_f:	.ascid	/%PAN-I-OPENT, Opening the input Text file....................../

text_buffer:	.blkb	100 * 5000
text_count:	.blkl	1

tty:	.ascid	/... short record .... /

text_point:	.blkl	1

no_lin:	.ascid	/Unable to replace notes that have NO lines !!!!!!!!!!!!!!!!!/

ctr_dt:	.ascid	/Text_Count = !UL /

flag:	.blkl	1


text_read_lines:	.blkl	1
ctr_xt1:	.ascid	/!UL lines read............................/

notes:	.ascid	/NOTE/

in_file:	.ascid	/FILE/


r_note_len:	.blkl	1
r_note_id:	.blkb	100


no_ask:	.ascid	/You did'nt find the note you wanted !!!!!!!!!!!!!!!!!!!!!!!!!/




add_tmp_i:      .word   0
                .word   Notes$K_Note_pen_Name
                .long   ret_per_name
                .long   0
;
ti_len:		.word   0
                .word   notes$k_note_title
                .long   ret_note_title
                .long   0
;
		.word	4
		.word	notes$k_note_hidden
		.long	note_hidden
		.long	0
;
Nf_1:		.word	0
		.word	notes$k_notefile_file_name
		.long	Notefile_file_name
		.long	
;
		.word	4
bas_sten:	.word	notes$k_noop
		.long	no_sig
		.long	0
;
                .long   0


add_tmp_o:      .word   20
                .word   notes$k_note_id
                .long   tmp_note_id
                .long   tmp_note_id_len
;
		.word	4
		.word	notes$k_note_uid
		.long	tmp_uid
		.long	0
;
		.word	8
		.word	notes$k_note_create_time
		.long	tmp_note_time
		.long	0
;
		.word	100
		.word	notes$k_note_author
		.long	tmp_note_author
		.long	tmp_note_author_len
;
		.long	0



tmp_note_time:		.blkl	2
tmp_note_id:		.blkb	50
tmp_note_id_len:	.blkl	1
tmp_uid:		.blkl	1

ctr_p2:	.ascid	/Enter as note !AD/
ab_d:	.ascid	/Delete original note/
ab_h:	.ascid	/Changing author and creation time......./

tmp_note_author:	.blkb	100
tmp_note_author_len:	.blkl	1


ctr_dr:	.ascid	/Buffer !XL    +72  !XL/


noteid:	.blkl	1








del_i:	.word	4
	.word	notes$k_note_Uid
	.long	uid
	.long	0
;
	.word	4
hss:	.word	notes$k_noop
	.long	note_hidden
	.long	0
;
	.long	0

ctr_peb:	.ascid	/UID = !XL      cont = !XL/
ab_r:	.ascid	/re-enter note with the correct ID/

tmp_noteid:	.blkl	1
orig_noteid:	.blkl	1

ab_r3:	.ascid	/$put/
ab_r1:	.ascid	/$get/
ab_r2:	.ascid	/$delete/
ab_r4:	.ascid	/$update/

o_msg_m:	.ascid	/%PAN-I-MODP, enable moderator priv/

open_o:         .word   8
                .word   notes$k_notefile_create_time
                .long   create_time
                .long   0
;
		.word	100
		.word	notes$k_notefile_user_area
		.long	notefile_user_area
		.long	notefile_user_area_len
;
                .long   0



open_m:         .word   4
                .word   notes$k_notefile_moderate
                .long   moderate
                .long   0
;
                .word   4
                .word   notes$k_nosignal
                .long   hint
                .long   0
;
                .long   0



notefile_user_area:	.blkb	100
notefile_user_area_len:	.blkl	1
                                                                       
create_time:	.blkl	2
hint:		.long	1

index:		.blkl	1

a_head:	.blkl	1

emp:	.ascid	/no text records found in original note /

ctr_x:	.ascid	/Head !XL       Text !XL/
ab_rp:	.ascid	/reset owner of original note (so we can delete it)/
ab_d1:	.ascid	/delete note (notes$note_delete)/
ab_d2:	.ascid	/delete note records/
ab_rp1:	.ascid	/get text record header/

ctr_s1:	.ascid	/temp header size !UL /
ctr_s2:	.ascid	/orig header size !UL /
ctr_s2t:	.ascid	/!5UL > number of lines ??  !UL/
count:	.blkl	1
ctr_6:	.ascid	/!XL/


tmp_file_cont:	.blkl	1


dummy_name:	.ascii	/sys$login:Dummy/
dummy_name_len = . - dummy_name

notes_open_create:
		.word   dummy_name_len
                .word   notes$k_notefile_file_name
                .long   dummy_name
                .long   0
;
                .word   default_name_len
                .word   notes$k_notefile_default_name
                .long   default_name
                .long   default_name_len
;
                .word   4
                .word   notes$k_notefile_create
                .long   no_sig
                .long   0

;
                .long   0

TMP_NOTE_CONT:	.blkl	1

ctr_x2:	.ascid	/orig_noteid  !XL   tmp_noteid !XL/

del_t_orig:	.ascid	/Delete text records from the target note /

paste:	.ascid	/paste text records from tmp file into the real file/

ctr111:	.ascid	/Head = !XL/

ctr_rc1:	.ascid	/You can only insert less than or equal to number of lines/
ctr_rc: 	.ascid	/!UL lines read from file.. !UL lines in note/

text_lines:	.blkl	1

mod_lin:	.ascid	/Modify line count ............./

not_head:	.ascid	/did not find header record ????????????????????/


Master:	.ascid	/MASTER/
op_msg_mast:	.ascid	/%PAN-I-OPEN_SC, Opening the Source conference/
op_msg_shad:	.ascid	/%PAN-I-OPEN_TC, Opening the Target conference/



	.entry	Shad,0





; null shad created symbol

	clrl	Out

        PUSHAL  DCLFLAG                
        PUSHAQ  Out		   ; value of symbol
        PUSHAQ  Shad_created  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    


	movw	#notes$k_note_hint_get_text,texthint
	movw	#notes$k_note_hint_get_text,texthint1


	pushaq	Forced_text
	calls   #1,g^cli$present
	blbc	r0,500$
	incl	Forced_text_flag
500$:	nop


	pushaq	create
	calls	#1,g^cli$present
	blbc	r0,1555$



	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  create
	calls   #3,g^cli$get_value 
	check	r0,error	

	cmpb	#^a/A/, @Input+4
	bneq	551$
	incl	create_flag
551$:	nop



	cmpb	#^a/N/, @Input+4
	bneq	552$
	incl	test_create_flag
552$:	nop

1555$:	nop

	pushaq	UNseen
	calls	#1,g^cli$present
	blbc	r0,19$
	incl	fast_wind
	movl	#1, doing_unseen
19$:	nop


; debug file

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  debug
	calls   #3,g^cli$get_value 
	check	r0,error	

	movl	#100,out
	$fao_s	ctrstr=ctr_debug,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

	movb	input,Dfab+fab$b_fns
	movl	input+4,Dfab+fab$l_fna

	$create	fab=Dfab
	check	r0,error

	$connect	rab=Drab
	check	r0,error


	calls	#0,g^lib$init_timer



	pushaq	uid_cld
	calls	#1,g^Cli$Present
	blbc	r0,4433$
	incl	uid_cld_flag
4433$:	nop



	pushaq	master_topic
	calls	#1,g^cli$present
	blbc	r0, 555$
	incl	master_topic_flag
555$:	nop









	pushaq	hack
	calls	#1,g^cli$present
	blbs	r0,167$
	brw	166$
167$:	nop


;	pushaq	imp_msg
;	calls	#1,g^lib$put_output

;	tst_priv	PRV$V_CMKRNL
;	tst_priv	PRV$V_BYPASS
;	tst_priv	PRV$V_SECURITY


	pushaq	dlm
	calls	#1,g^lib$put_output



	pushaq	dlm
	calls	#1,g^lib$put_output


 	incl	hack_flag


166$:	nop



; /range ???


	pushaq	range
	calls	#1,g^cli$Present
	blbc	r0,459$
	incl	range_flag
459$:	nop







	pushaq	op_msg_mast
	calls	#1,g^lib$put_output



; get start time

;	$Gettim_s	timadr=start_time
;	check	r0,error






; get the master conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Master
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i



; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	300$
301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	entry_name_len, master_entry_len
	movc3	entry_name_len, entry_name, master_entry


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

300$:	nop



	movw	#full_default_name_len, def_l
	movab	full_default_name, def_n


	tstl	doing_unseen
	beql	1221$
	movw	seen_map_len, se_mp
1221$:	nop



        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


	movl	max_uid_in_high_uid, max_uid

	movl	title_len, source_title_len
	movc3	source_title_len, title, source_title




        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; try for mod status

	pushaq	try_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_modify


	MOVL    R0,VEC+4
        $PUTMSG_S       MSGVEC=VEC






; get note context...

	movab	mast_file_cont, notes_beg_i+4



        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  mast_note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       

; --------------------------------------------------------------

	pushaq	dlm
	calls	#1,g^lib$put_output


	pushaq	op_msg_shad
	calls	#1,g^lib$put_output





; get the shadow conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Shadow
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	input,notes_open_i

; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,1301$			; skip if NOnotebook
	brw	1300$
1301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in



	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

	tstl	notebook_file_cont
	bneq	557799$

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

557799$:	nop

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error



	movl	entry_name_len, shad_entry_len
	movc3	entry_name_len, entry_name, shad_entry


; test fot create ??????

	tstl	test_create_flag
	bneq	14499$
	brw	4499$
14499$:	nop
	

	movw	shad_entry_len, mod_up_i
	movab	shad_entry, mod_up_i+4

	pushaw	mod_up_o
	pushaw	mod_up_i
	pushal	notebook_cont
	calls	#3,g^notes$entry_update



; tell us if bad update status

	movl	entry_last_status, R0
	blbs	r0,779$

	pushaq	due_to
	calls	#1,g^lib$put_output

	movl	entry_last_status, vec+4
        $PUTMSG_S       MSGVEC=VEC

	brw	4499$

779$:	nop


	movl	#100,out
	$fao_s	ctrstr=ctr_un_est,outbuf=out,outlen=out,-
		p1=found_unseen
	pushaq	out
	calls	#1,g^lib$put_output

	tstl	found_unseen
	bneq	4499$

777$:	nop
	incl	create_flag

4499$:	nop



	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

1300$:	nop





; create a new conf ??

	tstl	create_flag
	bneq	67$
	brw	68$
67$:	nop


	movab	notice,R6
	addl2	notice_len,R6

;	movc3	#shad_n_l, shad_n, (R6)
;	addl2	#shad_n_l, notice_len



	movl	source_title_len, title_len
	movc3	source_title_len, source_title, title


;	movl	title_len, Descr
;	movab	title, Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movab	title,R6
	addl2	title_len,R6

	movc3	#shad_n_l, shad_n, (R6)
	addl2	#shad_n_l, title_len



;	movl	title_len, Descr
;	movab	title, Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output


	movw	notice_len, c_n_l
	movw	title_len, c_t_l




	movw	input,notes_open_i_create2

	pushaq	op_msg_cre
	calls	#1,g^lib$put_output

	tstl	is_restricted
	beql	120$
	movl	#1,Xnotefile_restricted
120$:	nop


        pushaw  notes_open_o
        pushaw  notes_open_i_create2
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


        PUSHAL  DCLFLAG                
        PUSHAQ  True		   	; value of symbol
        PUSHAQ  Shad_created  		; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    



	pushaw	null
	pushaw	null
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_end
        check   r0,error


68$:	nop



	tstl	doing_unseen
	beql	3221$

	clrw	se_mp

	tstl	create_flag
	bneq	3221$

	movw	seen_map_len, se_mp
3221$:	nop


	movw	#default_name_len, def_l
	movab	default_name, def_n

        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


1123$:	nop



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




; enable mod priv !!


	tstl	hack_flag
	beql	4191$

	pushaq	mod_en
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

4191$:	nop


        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output





	tstl	hack_flag
	beql	1234$


	movb	descr,fab+fab$b_fns
	movl	descr+4,fab+fab$l_fna


	pushaq	o_msg
	calls	#1,g^lib$put_output

	$open	fab=fab
	check	r0,error

	$connect	rab=rab
	check	r0,error


1234$:	nop

; create dcl symbol


	locc	#^a/;/, descr, @descr+4
	
	subl2	R0, Descr

        PUSHAL  DCLFLAG                
        PUSHAQ  Descr   ; value of symbol
        PUSHAQ Shad_sym_name  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    




; get note context...

	movab	shad_file_cont, notes_beg_i+4



        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  shad_note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       



	movl	number_of_notes, max_note_number


; new notes id ?

	pushaq	new_topic
	calls	#1,g^cli$present
	blbc	r0, 55$

	incl	new_topic_flag

	movl	number_of_notes, new_topic_number
	incl	new_topic_number

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  new_topic
	calls   #3,g^cli$get_value 
	blbc	r0, 55$



        pushal  new_topic_number
        pushaq  Input
        calls   #2,g^OTS$CVT_TI_L
	check	r0,error


55$:	nop




	movl	#100,out
	$fao_s	ctrstr=ctr_sh,outbuf=out,outlen=out,-
		p1=max_note_number
	put_de	out






heap:	nop


	tstl	range_flag
	beql	341$
	brw	no_last
341$:	nop


	tstl	master_topic_flag
	beql    9341$
        brw     no_last
9341$:  nop



; are we doing /UNseen ???

	tstl	doing_unseen
	beql	1221$


	movw	#notes$k_noop, mm1
	movw	#notes$k_noop, mm2

	movw	#notes$k_noop, Nlt
	movw	#notes$k_note_mark_seen, nlt1
	movw	#notes$k_note_mark_seen, nlt2


	movw	#4, disp_i
	movw	#notes$k_note_next_unseen, disp_i+2
	movab	cont,  disp_i+4


	movw	#4, disp_iC
	movw	#notes$k_note_next_unseen, disp_iC+2
	movab	cont, disp_iC+4



	brw	no_last
1221$:	nop






	$Bintim_s	timbuf=time,-
			timadr=p_quad
	check	r0,error



; last update time ???

	cmpl	#8,notefile_user_area_len
	beql	8$



;	incl	only_doing_base_notes



	movl	#8,notefile_user_area_len
	movq	p_quad, notefile_user_area

8$:	nop


	movl	#100,out
	$fao_s	ctrstr=ctr_last1,outbuf=out,outlen=out,-
		p1=notefile_user_area_len
;	pushaq	out
;	calls	#1,g^lib$put_output




	movl	#100,out
	$fao_s	ctrstr=ctr_last2,outbuf=out,outlen=out,-
		p1=#notefile_user_area
	pushaq	out
	calls	#1,g^lib$put_output

; check its a valid time...

	movl	#100,out

	$Asctim_s	timbuf=Out,-
			timadr=notefile_user_area
	check	r0,error


; select on this time !!!!


;	movw	#8, disp_i
;	movw	#NOTES$K_NOTE_SINCE_TIME   , disp_i+2
;	movab	notefile_user_area, disp_i+4


;	movw	#8, disp_iC
;	movw	#NOTES$K_NOTE_SINCE_TIME   , disp_iC+2
;	movab	notefile_user_area, disp_iC+4


; build a seen/unseen map based on that date



;	$Bintim_s	timbuf=time,-
;			timadr=notefile_user_area
;	check	r0,error


	incl	fast_wind

	incl	se_fl

	pushaq	map_bl
	calls	#1,g^lib$put_output

        pushaw  se_o
        pushaw  se_i
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

	movw	#notes$k_noop, mm1
	movw	#notes$k_noop, mm2

	movw	#notes$k_noop, Nlt
	movw	#notes$k_note_mark_seen, nlt1
	movw	#notes$k_note_mark_seen, nlt2


	movw	#4, disp_i
	movw	#notes$k_note_next_unseen, disp_i+2
	movab	cont,  disp_i+4


	movw	#4, disp_iC
	movw	#notes$k_note_next_unseen, disp_iC+2
	movab	cont, disp_iC+4



no_last:	nop


; /SINCE ???


	pushaq	since
	calls	#1,g^cli$Present
	blbs	r0,66$
	brw	no_since
66$:	nop

	clrl	only_doing_base_notes

	movl    #100,out
	Pushaw  out
	pushaq  out
	pushaq  since
	calls   #3,g^cli$get_value 
	check	r0,error

; convert to binary


	$bintim_s	timbuf=Out,-
			timadr=notefile_user_area
	check	r0,error			


	movl	#100,out
	$fao_s	ctrstr=ctr_last2,outbuf=out,outlen=out,-
		p1=#notefile_user_area
	pushaq	out
	calls	#1,g^lib$put_output


	incl	fast_wind

	incl	se_fl

	pushaq	map_bl
	calls	#1,g^lib$put_output

        pushaw  se_o
        pushaw  se_i
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

	movw	#notes$k_noop, mm1
	movw	#notes$k_noop, mm2

	movw	#notes$k_noop, Nlt
	movw	#notes$k_note_mark_seen, nlt1
	movw	#notes$k_note_mark_seen, nlt2


	movw	#4, disp_i
	movw	#notes$k_note_next_unseen, disp_i+2
	movab	cont,  disp_i+4


	movw	#4, disp_iC
	movw	#notes$k_note_next_unseen, disp_iC+2
	movab	cont, disp_iC+4




no_since:	nop





	pushaq	dlm
	calls	#1,g^lib$put_output



; get a note from the master





	tstl	master_topic_flag
	beql	555$

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  master_topic
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	input, disp_i
	movl	input+4, disp_i+4

	clrl	uid_cld_flag

555$:	nop




mg_loop:	nop



	movl	#100,out
	$fao_s	ctrstr=ctr_larep,outbuf=out,outlen=out,-
		p1=reply_number
	put_de	out



;	pushaq	dlm
;	calls	#1,g^lib$put_output
	put_de	dlm

mg_loop_sk:	nop



	tstl	save_detail
	beql	10$

	put_de	dlm_et

	movw	#notes$k_noop, bas_sten

	movc3	#detail_size, save_detail,  detail_area
	clrl	save_detail
	brw	34$
10$:	nop


	clrl	topic_exists


	tstl	flag
	beql	331$
	brw	33$
331$:	nop

	tstl	range_flag
	beql	491$

	movl    #100,out
	Pushaw  out
	pushaq  out
	pushaq  range
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	#notes$k_noop, mm1

	movw	out, disp_i
	movl	out+4, disp_i+4

491$:	nop




        pushaw  add_add_o
        pushaw  disp_i
        pushal  mast_note_cont
        calls   #3,g^notes$note_get
	blbs	r0,101$
	cmpl	r0,#NOTES$_NO_SUCH_NOTE
	bneq	717$
	brw	shad_end
717$:	cmpl	r0,#NOTES$_NO_MORE_NOTES
	bneq	102$
	brw	shad_end
102$:	ret
101$:	nop


;	calls	#0,g^lib$show_timer


	incl	flag
	brw	34$
33$:	nop

        pushaw  add_add_o
        pushaw  disp_IC
        pushal  mast_note_cont
        calls   #3,g^notes$note_get
	blbs	r0,201$
	cmpl	r0,#NOTES$_NO_SUCH_NOTE
	bneq	7171$
	brw	shad_end
7171$:	cmpl	r0,#NOTES$_NO_MORE_NOTES
	bneq	202$
	brw	shad_end
202$:	ret
201$:	nop




34$:	nop


	movl	uid,original_note_uid
	movl	uid,next_uid


; DONT DO ANY_THING IF only_doing_base_notes is set !!!!

	tstl	only_doing_base_notes
	beql	747$
	locc	#^a/./, note_id_len, note_id


	decl	R0
	incl	R1

	movl	r0, Descr
	movl	R1, Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output


        pushal  Tmp1
        pushaq  Descr
        calls   #2,g^OTS$CVT_TI_L	
	check	r0,error

	tstl	tmp1
	beql	747$

;	pushaq	sk_th
;	calls	#1,g^lib$put_output

	put_de	sk_th


	brw	mg_loop_sk


747$:	nop



;	movw	#4, Disp_I
;	movw	#notes$k_continue, Disp_i+2
;	movab	cont, Disp_I+4	


	movl	#100,out
	$fao_s	ctrstr=ctr_p3,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out

	movq	ret_note_time, start_time

	movl	#100,out
	$fao_s	ctrstr=ctr_last2,outbuf=out,outlen=out,-
		p1=#start_time
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out


	movl	note_id_len, o_note_id_len
	movc3	note_id_len, note_id, o_note_id


; hidden ???

	tstl	note_hidden
	beql	49$
;	pushaq	note_hidden_t
;	calls	#1,g^lib$put_output
	put_de	note_hidden_t
49$:	nop


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output
	put_de	descr


	movw	Notefile_file_name_len, Nf_1
	movw	Notefile_file_name_len, Nf_2

; does this note exist in the shadow conf ?






; (if new topic number)


	tstl	new_topic_flag
	bneq	119$
	brw	120$
119$:	nop



	locc	#^a/./, note_id_len, note_id


	decl	R0
	incl	R1

	movl	r0, Descr
	movl	R1, Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output


        pushal  Tmp1
        pushaq  Descr
        calls   #2,g^OTS$CVT_TI_L	
	check	r0,error

	movl	#100,out
	$fao_s	ctrstr=ctr_nt,outbuf=out,outlen=out,-
		p1=new_topic_number,-
		p2=tmp1
;	pushaq	out
;	calls	#1,g^lib$put_output

	movl	out, note_id_len
	movc3	out, @out+4, note_id



120$:	nop


; if no notes in shad..  dont bother to get !!!


	movl	#100,out
	$fao_s	ctrstr=ctr_sh,outbuf=out,outlen=out,-
		p1=max_note_number
	put_de	out


	tstl	max_note_number
	bneq	734$
;	pushaq	skip_ch
;	calls	#1,g^lib$put_output
	put_de	skip_ch
	brw	100$
734$:	nop	

	movw	note_id_len, Get_I
	movab	note_id, Get_I+4


        pushaw  tst_o
        pushaw  get_I
        pushal  shad_note_cont
        calls   #3,g^notes$note_get

	blbs	r0,61$
        cmpl    r0, #NOTES$_NO_SUCH_NOTE
	bneq	62$
	brw	100$
62$:	ret
61$:	nop



	movl	r_note_len, descr
	movab	r_note_id, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output

	put_de	descr





	cmpl	r_note_len,  note_id_len
	bneq	100$

	cmpc3	r_note_len, r_note_id, note_id
	bneq	100$

;	pushaq	all_t
;	calls	#1,g^lib$put_output
	put_de	all_t

	incl	not_add


	brw     mg_loop

100$:	nop	;------------------------------------------





; dont tell us about forced base notes

	tstl	save_detail
	bneq	9910$

	tstl	force_base
	beql	7911$
	clrl	force_base
	brw	9910$
7911$:	nop

	movl	#100,out
	$fao_s	ctrstr=actr_p333,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=#ret_note_time,-
		p6=number_of_lines
	pushaq	out

	calls	#1,g^lib$put_output
9910$:	nop


	tstl	ret_note_author_len
	bneq	1234$
	put_de	nul_auth
	movzbl	nul_auth, ret_note_author_len
	movc3	ret_note_author_len, nul_auth+8, ret_note_author
1234$:	nop



	movl	#100,out
	$fao_s	ctrstr=ctr_123,outbuf=out,outlen=out,-
		p1=original_note_uid
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out



	tstl	mast_note_cont_tmp
	bneq	121$


	movab	mast_file_cont, notes_beg_i+4



        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  mast_note_cont_tmp
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       

121$:	nop





	movw	o_note_id_len ,disp_i_text
	movab	o_note_id, disp_i_text+4


; save note_id

	movl	note_id_len, save_len
	movc3	note_id_len, note_id, save_ch


;        pushaw  add_add_o
 ;       pushaw  disp_i_text
  ;      pushal  mast_note_cont_tmp
   ;     calls   #3,g^notes$note_get
    ;    check   r0,error




	movl	#100,out
	$fao_s	ctrstr=ctr_p3,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
;	pushaq	out
;	calls	#1,g^lib$put_output




; restore...

	movl	save_len, note_id_len
	movc3	note_id_len, save_ch, note_id




; is this a reply ??????

;	brw	776$


	locc	#^a/./, note_id_len, note_id


	decl	R0
	incl	R1

	movl	r0, Descr
	movl	R1, Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output


        pushal  Tmp1
        pushaq  Descr
        calls   #2,g^OTS$CVT_TI_L	
	check	r0,error





	locc	#^a/./, note_id_len, note_id

	subl3	R0, note_id_len, Descr
	movab	note_id, Descr+4

;	pushaq	Descr
;	calls	#1,g^lib$put_output


        pushal  Tmp2
        pushaq  Descr
        calls   #2,g^OTS$CVT_TI_L	
	check	r0,error

; reply ?

	movl	Tmp2, topic_number

; if no notes in shad..  dont bother to get !!!

	tstl	shadnumber_of_notes
	bneq	1734$
;	pushaq	skip_ch
;	calls	#1,g^lib$put_output
;?????	put_de	skip_ch
;?????	brw	776$
1734$:	nop	


	clrl	reply_number


	tstl	Tmp1
	bneq	774$
	brw	776$
774$:	nop

	clrl	topic_number
	movl	Tmp1, reply_number


; yes a reply!!!

	movl	#100,out
	$fao_s	ctrstr=ctr_45,outbuf=out,outlen=out,-
		p1=#Descr,-
		p2=Tmp1
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out

; get base note uid




	movw	Descr, bas_i
	movl	descr+4, bas_i+4

        pushaw  bas_o
        pushaw  bas_i
        pushal  shad_note_cont
        calls   #3,g^notes$note_get
;        check   r0,error


	movl	base_uid, base_note_uid




	movl	#100,out
	$fao_s	ctrstr=ctr_99,outbuf=out,outlen=out,-
		p1=bas_note_len,-
		p2=#bas_note
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out



	movl	#100,out
	$fao_s	ctrstr=ctr_459,outbuf=out,outlen=out,-
		p1=#Descr
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out



; is this the base note we wanted ???


	cmpl	out,bas_note_len
	beql	9911$
	brw	4000$
9911$:	nop

	cmpc3	out, bas_note, @out+4
	beql	9912$
	brw	4000$
9912$:	nop

	brw	4001$
4000$:	nop			; base note not found !!!!

;	pushaq	dlm_et
;	calls	#1,g^lib$put_output
	put_de	dlm_et

;	pushaw	no_bas_fnd
;	calls	#1,g^lib$put_output
	put_de	no_bas_fnd

	movc3	#detail_size, detail_area, save_detail



	pushaq	add_add_o
	pushaw	bas_i
	pushal	mast_note_cont_tmp
	calls	#3,g^notes$note_get
	check	r0,error


	movw	#notes$k_note_mark_seen, bas_sten


	incl	force_base

	brw	34$

	$exit_s

4001$:	nop






	movl	#100,out
	$fao_s	ctrstr=ctr_881,outbuf=out,outlen=out,-
		p1=base_uid
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out






; create note in shadow



	movw	ret_note_title_len, Xti_len
	movw	ret_per_name_len, add_tmp_i_r

; if we are not hacking then change the per name 

	tstl	hack_flag
;	bneq	4234$
	beql	14234$
	brw	4234$
14234$:	nop



	movl	#100,out
	$fao_s	ctrstr=ctr_p333,outbuf=out,outlen=out,-
		p1=o_note_id_len,-
		p2=#o_note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=#ret_note_time
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out

	movw	out, add_tmp_i_r
	movl	out+4, add_tmp_i_r+4


4234$:	nop

	calls	#0,select_uid

        pushaw  add_tmp_o
        pushaw  add_tmp_i_r
        pushal  shad_note_cont
        calls   #3,g^notes$note_add
        check   r0,error



	tstl	uid_cld_flag
	beql	999$
	cmpl	next_uid, tmp_uid
	beql	999$

	movl	#100,out
	$fao_s	ctrstr=ctr_uidd,outbuf=out,outlen=out,-
		p1=next_uid,-
		p2=tmp_uid
	pushaq	out
	calls	#1,g^lib$put_output
999$:	nop




; stamp it
	movl	tmp_uid, uid_to_stamp




	incl	shadnumber_of_notes


	movl	#100,out
	$fao_s	ctrstr=ctr_p2,outbuf=out,outlen=out,-
		p1=tmp_note_id_len,-
		p2=#tmp_note_id
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out

	incl	add_add


	brw	c_txt_ch

	ret


776$:	nop






;	incl	topic_exists

; create note in shadow

	movw	ret_note_title_len, ti_len
	movw	ret_per_name_len, add_tmp_i



	tstl	hack_flag
;	bneq	234$
	beql	9234$
	brw	234$
9234$:	nop

	movl	#100,out
	$fao_s	ctrstr=ctr_p333,outbuf=out,outlen=out,-
		p1=o_note_id_len,-
		p2=#o_note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=#ret_note_time
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out

	movw	out, add_tmp_i
	movl	out+4, add_tmp_i+4


234$:	nop

	calls	#0,select_uid

        pushaw  add_tmp_o
        pushaw  add_tmp_i
        pushal  shad_note_cont
        calls   #3,g^notes$note_add
        check   r0,error



	tstl	uid_cld_flag
	beql	1999$
	cmpl	next_uid, tmp_uid
	beql	1999$

	movl	#100,out
	$fao_s	ctrstr=ctr_uidd,outbuf=out,outlen=out,-
		p1=next_uid,-
		p2=tmp_uid
	pushaq	out
	calls	#1,g^lib$put_output
1999$:	nop




; stamp it
	movl	tmp_uid, uid_to_stamp



	incl	shadnumber_of_notes

	movl	#100,out
	$fao_s	ctrstr=ctr_p2,outbuf=out,outlen=out,-
		p1=tmp_note_id_len,-
		p2=#tmp_note_id
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out

	incl	add_add


c_txt_ch:	nop

	movl	#100,out
	$fao_s	ctrstr=ctr_123,outbuf=out,outlen=out,-
		p1=tmp_uid
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out


	tstl	uid_cld_flag
	beql	1588$

	cmpl	original_note_uid, tmp_uid
	beql	1588$

	put_de	uid_ne

	pushaq	uid_ne
	calls	#1,g^lib$put_output


1588$:	nop


; is this a new maximum uid ???




	cmpw	tmp_uid, max_uid
	bleq	588$

	movw	tmp_uid, max_uid


	movl	#100,out
	$fao_s	ctrstr=ctr_1235,outbuf=out,outlen=out,-
		p1=max_uid
;	pushaq	out
;	calls	#1,g^lib$put_output	
	put_de	out

588$:	nop



	tstl	hack_flag
	bneq	1234$
	brw	2234$
1234$:	nop



;	pushaq	sh_3
;	calls	#1,g^lib$put_output
	put_de	sh_3



; hack the author / date 




	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz

	movc5	#0,(sp),#0,#10000,buffer
	movc5	#0,(sp),#0,#10000,save_1
	movc5	#0,(sp),#0,#10000,save_2

	movw	Tmp2, Key_id+2
	movw	Tmp1, Key_id



	movab	tmp_uid, rab+rab$l_kbf
	movb	#0,rab+rab$b_krf


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	$rab_store	rab=rab,rac=Key

	$get	rab=rab
	check	r0,error



	movl	#100,out
	$fao_s	ctrstr=ctr_dr,outbuf=out,outlen=out,-
		p1=buffer,-
		p2=buffer+72
;	pushaq	out
;	calls	#1,g^lib$put_output



	

; sanity check....


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Author


; ret_note_author
; ret_note_author_len

	movl	tmp_note_author_len, descr
	movab	tmp_note_author, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output

	movzbl	buffer+77,descr
	movab	buffer+78,descr+4

	movl	#100,out
	$fao_s	ctrstr=xctr2,outbuf=out,outlen=out,-
		p1=#Descr
;	pushaq	out
;	calls	#1,g^lib$put_output

	cmpl	descr, tmp_note_author_len
	tst

	cmpc3	descr,tmp_note_author,@Descr+4
	tst

; blank fill the author field

	movab	ret_note_author,R6
	addl2	ret_note_author_len,R6

	movc5	#0,(sp),#^a/ /,#10,(R6)


; hack the author field....

	movzbl	buffer+77,descr
	movab	buffer+78,descr+4


; save...

	addl3	descr,descr+4,R6
	movc3	#3000,(R6), Save_1	


	movab	buffer+78, R6


	movc3	ret_note_author_len,ret_note_author, (R6)	
	decl	r6
	movb	ret_note_author_len,(R6)

; restore

	addl3	ret_note_author_len ,descr+4,R6
	movc3	#3000,Save_1, (R6)



	movzwl	rab+rab$w_rsz,R6
	subl2	descr,R6
	addl2	ret_note_author_len,R6



	movl	ret_note_author_len, descr


;	movzwl	rab+rab$w_rsz,R6
;	addl2	#40,R6

	movw	R6, rab+rab$w_rsz
	movw	R6, rab+rab$w_usz





; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; date
; ret_note_time

	addl3	descr,descr+4,R6

	addl2	#2,R6


	movq	(R6),Quad
	
	movq	ret_note_time, (R6)

	movl	#100,out
	$fao_s	ctrstr=xctr1,outbuf=out,outlen=out,-
		p1=#Quad
;	pushaq	out
;	calls	#1,g^lib$put_output

	cmpl	quad, tmp_note_time
	tst

	cmpl	quad+4, tmp_note_time+4
	tst




	$update	rab=rab
	check	r0,error





2234$:	nop


; now enter the text....

	calls	#0,re_set_max



	tstl	Forced_text_flag
	bneq	c_txt

; dont get the text for a 'forced' base note

	tstl	save_detail
	beql	c_txt

	brw	disp_ret
	
c_txt:	nop

        pushaw  Get_txt_o
        pushaw  Get_txt_i
        pushal  mast_note_cont
        calls   #3,g^notes$note_get_text
        blbs    r0,67$
        cmpl    r0,#NOTES$_NO_MORE_text
        bneq    68$
        brw     disp_ret
68$:    nop
        ret
67$:	nop

                                                                     



        movab   rec,add_txt_st
	movw	#notes$k_continue,add_txt_i+2

	movw	rec_len, add_txt_len

        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  shad_note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


	brw	c_txt

disp_ret:	nop


	movw    #notes$k_text_end,add_txt_i+2


        cvtbw   null,add_txt_len
        movab   null+8,add_txt_st

	tstl	Forced_text_flag
	bneq	8$

	tstl	save_detail
	beql	8$
        cvtbw   null_base,add_txt_len
        movab   null_base+8,add_txt_st
8$:	nop





        pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  shad_note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


	pushaw	null
	pushaw	stamp_in
	pushal	shad_note_cont
	calls	#3,g^notes$note_modify
	check	r0,error



        pushaw  null
        pushaw  null
        pushal  mast_note_cont_tmp
        calls   #3,G^Notes$note_end
        check   r0,error                                                                       

;	calls	#0,re_set_max


	tstl	first_uid
	bneq	9$
	movl	tmp_uid, first_uid
9$:	nop



; now re-set the note id 

	brw	tst_re
;	brw	mg_loop

	tstl	topic_exists
	beql	991$
	brw	mg_loop
991$:	nop


	movl	#100,out
	$fao_s	ctrstr=ctr_xx,outbuf=out,outlen=out,-
		p1=topic_exists
;	pushaq	out
;	calls	#1,g^lib$put_output

	put_de	out


	clrl	res_flag



	cmpl	tmp_note_id_len,  note_id_len
	bneq	99$
	cmpc3	tmp_note_id_len, tmp_note_id, note_id
	bneq	99$


	brw	mg_loop_ch
99$:	nop	


	locc	#^a/./, note_id_len, note_id

	subl3	R0, note_id_len, Descr
	movab	note_id, Descr+4

;	pushaq	Descr
;	calls	#1,g^lib$put_output
	put_de	Descr

	movl	note_id_len, res_flag
	movl	descr, note_id_len



tst_re:	nop

; do we need to hack the note id ?????





	cmpl	tmp_note_id_len,  note_id_len
	bneq	99$
	cmpc3	tmp_note_id_len, tmp_note_id, note_id
	bneq	99$


	brw	mg_loop_ch
99$:	nop	


	calls	#0, change_base_note_replies


	tstl	res_flag
	beql	993$
	cmpc3	note_id_len, note_id, tmp_note_id
	bneq	993$
	brw	mg_loop_ch
993$:	nop



	movl	#100,out
	$fao_s	ctrstr=sh_1,outbuf=out,outlen=out,-
		p1=tmp_note_id_len,-
		p2=#tmp_note_id,-
		p3=note_id_len,-
		p4=#note_id
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out



	movl	note_id_len , descr
	movab	note_id, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output

	movw	note_id_len, n_l
	movab	note_id, n_s

	movl	tmp_note_id_len,descr
	movab	tmp_note_id, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output

	movw	tmp_note_id_len, o_l
	movab	tmp_note_id, o_s





	pushaw  add_tmp_o
        pushaw  move_i
        pushal  shad_note_cont
        calls   #3,g^notes$note_modify
	check	r0,error







; inv the cache

	pushaw  nl_o
        pushaw  nl_i
        pushal  shad_note_cont
        calls   #3,g^notes$note_get
        check   r0,error


; and get the returned note id


	pushaw  add_tmp_o
        pushaw  find_i
        pushal  shad_note_cont
        calls   #3,g^notes$note_get
        check   r0,error



	movl	#100,out
	$fao_s	ctrstr=ctr_99,outbuf=out,outlen=out,-
		p1=tmp_note_id_len,-
		p2=#tmp_note_id
;	pushaq	out
;	calls	#1,g^lib$put_output

	put_de	out


	brw	tst_re
	ret


; did we get the note id that we expected ???


	cmpl	tmp_note_id_len,  note_id_len
	beql	91$
	brw	99$
91$:	nop


	cmpc3	tmp_note_id_len, tmp_note_id, note_id
	beql	mg_loop_ch

	brw	99$

mg_loop_ch:	nop

	tstl	res_flag
	beql	400$

	movl	res_flag, note_id_len
	clrl	res_flag
	brw	tst_re

400$:	nop










	brw	mg_loop



shad_end:	nop



	pushaq	Dlm
	calls	#1,g^lib$put_output
	pushaq	Dlm
	calls	#1,g^lib$put_output

	calls	#0,g^lib$show_timer

; tell us how many added / not added



	movl	#100,out
	$fao_s	ctrstr=ctr_integer,outbuf=out,outlen=out,-
		p1=add_add


        PUSHAL  DCLFLAG                
        PUSHAQ  out		; value of symbol
        PUSHAQ  Shad_added  	; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    



	movl	#100,out
	$fao_s	ctrstr=ctr_tell,outbuf=out,outlen=out,-
		p1=not_add,-
		p2=add_add
	pushaq	out
	calls	#1,g^lib$put_output


; tell us the resulting file name


	pushaq	you_may
	calls	#1,g^lib$put_output

	cvtbl   NAM+NAM$B_RSL,Descr
	movab	result,Descr+4

	pushaq	descr
	calls	#1,g^lib$put_output


	tstl	add_add
	bneq	1221$
	ret
1221$:	nop


	tstl	only_doing_base_notes
	beql	55$

	pushaq	no_rep
	calls	#1,g^lib$put_output

	movl	#-1,only_doing_base_notes
	brw	heap
55$:	nop




; store max uid in conf

	tstl	uid_cld_flag
	bneq	999$
	brw	1000$
999$:	nop



	pushaq	res_nx_1
	calls	#1,g^lib$put_output


        pushaw  o_max
        pushaw  null
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error




; get the conf header record


	movab	null, rab+rab$l_kbf
	movb	#0,rab+rab$b_krf


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	$rab_store	rab=rab,rac=Key

	$get	rab=rab
	check	r0,error


	cmpl	high_uid, buffer+92
	beql	1001$

	pushaq	no_eq
	calls	#1,g^lib$put_output

	ret

1001$:	nop

; change the next uid field



	movw	max_uid,  buffer+92


	$update	rab=rab
	check	r0,error



; ------------------------------------------------------------

	tstl	tmp_uid
	beql	888$

	$rab_store	rab=rab,rac=key

	movab	tmp_uid, rab+rab$l_kbf

	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz

	$get	rab=rab
	check	r0,error

	brw	1000$

888$:	nop


; ------------------------------------------------------------


	$rab_store	rab=rab,rac=seq

	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz

	$get	rab=rab
	check	r0,error


1000$:	nop





; dont save start time if its not a full update


	tstl	add_add
	bneq	5$
	ret
5$:	nop

	tstl	master_topic_flag
	beql	10$
	ret
10$:	nop


	pushaq	save_tell
	calls	#1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_last2,outbuf=out,outlen=out,-
		p1=#start_time
	pushaq	out
	calls	#1,g^lib$put_output


        pushaw  open_o
        pushaw  st_i
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_modify
;	check	r0,error


; --------------------------------------------------
; --------------------------------------------------


	tstl	doing_unseen
	bneq	45$
	ret
45$:	nop


	pushaw	end_o
	pushaw	null
        pushal  shad_file_cont
	calls	#3,g^notes$notefile_end
	check	r0,error


; ......................................................
; update the entry

	tstl	shad_entry_len
	bneq	49$
	brw	50$
49$:	nop


	pushaq	sh_e_1
	calls	#1,g^lib$put_output



	movw	seen_map_len, se_mp1
	movw	shad_entry_len, mod_ent_i
	movab	shad_entry, mod_ent_i+4

	pushaw	null
	pushaw	mod_ent_i
	pushal	notebook_cont
	calls	#3,g^notes$entry_modify
	check	r0,error	



; ......................................................


	pushaq	sh_e_2
	calls	#1,g^lib$put_output




	movw	shad_entry_len, mod_up_i
	movab	shad_entry, mod_up_i+4

	pushaw	mod_up_o
	pushaw	mod_up_i
	pushal	notebook_cont
	calls	#3,g^notes$entry_update


	movl	#100,out
	$fao_s	ctrstr=ctr_un_est,outbuf=out,outlen=out,-
		p1=found_unseen
	pushaq	out
	calls	#1,g^lib$put_output


50$:	nop


	pushaq	seen
	calls	#1,g^cli$present
	blbs	r0,18$
	$exit_s	code=#1
18$:	nop





	pushaw	end_o
	pushaw	null
        pushal  mast_file_cont
	calls	#3,g^notes$notefile_end
	check	r0,error


; .........................................

	tstl	master_entry_len
	beql	60$


	pushaq	sh_e_3
	calls	#1,g^lib$put_output




; update the entry


	movw	seen_map_len, se_mp1
	movw	master_entry_len, mod_ent_i
	movab	master_entry, mod_ent_i+4



	pushaw	null
	pushaw	mod_ent_i
	pushal	notebook_cont
	calls	#3,g^notes$entry_modify
	check	r0,error	

60$:	nop



	ret



mod_up_o:	.word	4
		.word	notes$k_entry_unseen_est
		.long	found_unseen
		.long	0
;
		.word	4
		.word   notes$k_entry_last_status
		.long	entry_last_status
		.long	0
;
		.long	0


entry_last_status:	.blkl	1

ctr_un_est:	.ascid	/  !UL UNseen note!%S (Estimate)/
found_unseen:	.blkl	1




mod_up_i:	.word	0
		.word	notes$k_entry_name
		.long	entry_name
		.long	0
;

		.word   default_name_len
ppdb:		.word   notes$k_notefile_default_name
		.long   default_name
                .long   default_name_len
;
cl_na:		.word	0
		.word	notes$k_noop
		.long	0
		.long	0
;
		.long	0




Tmp2:	.blkl	1
Tmp1:	.blkl	1


mast_note_cont_tmp:	.blkl	1
mast_file_cont:	.blkl	1
mast_note_cont:	.blkl	1

Shadow:	.ascid	/SHADOW/

shad_file_cont:	.blkl	1

shad_note_cont:	.blkl	1






disp_i:		.word	note_id_i_len
		.word	notes$k_note_id
		.long	note_id_i
		.long	0
;
		.word	4
		.word	notes$k_nosignal
		.long	no_sig
		.long	0
;
		.word	4
mm1:		.word	notes$k_note_all_responses
		.long	cont
		.long	0
;
		.word	4
nlt1:		.word	notes$k_noop
		.long	cont
		.long	0
;
		.word	4
texthint:	.word	notes$k_noop
		.long	cont
		.long	0
;
		.long	0


select_start:	.blkl	2


note_id_i:	.ascii	/1.*-999999999.*/
note_id_i_len = . - note_id_i


cont:	.long	1


ctr_p3:		.ascid	/Note !7AD !20AD !30AD !4UL lines/



tst_o:	
		.word   20
                .word   notes$k_note_id
                .long   r_note_id
                .long   r_note_len
;
		.long	0


all_t:	.ascid	/note is already in the Target conference/


get_txt_i:  	.word   4
        	.word   notes$k_nosignal
        	.long   hint
        	.long   0
;
        	.long   0

get_txt_o:  	.word   1000
        	.word   notes$k_text_string
        	.long   rec
        	.long   rec_len
;
        	.long   0


ctr_dump:	.ascid	/calculated key..!XL/
keyid:		.blkl	1
key_id:		.blkl	
end_of:	.ascid	/(adding a reply count field!)/
ctr_type:	.ascid	/Type = !UB/



ctr_dM:	.ascid	/Byte !4UL   Type !5UB       (!AF)/


address:	.blkl	1
length:		.blkl	1
type:		.blkl	1




disp_i_text:	.word	note_id_i_len
		.word	notes$k_note_id
		.long	note_id_i
		.long	0
;
		.word	4
		.word	notes$k_nosignal
		.long	no_sig
		.long	0
;
		.word	4
		.word	notes$k_note_hint_get_text
		.long	cont
		.long	0
;
		.long	0






disp_ic:	.word	note_id_i_len
		.word	notes$k_note_id
		.long	note_id_i
		.long	0
;
		.word	4
		.word	notes$k_nosignal
		.long	no_sig
		.long	0
;
		.word	4
mm2:		.word	notes$k_note_all_responses
		.long	cont
		.long	0
;
		.word	4
nlt:		.word	notes$k_continue
		.long	cont
		.long	0
;
		.word	4
nlt2:		.word	notes$k_noop
		.long	cont
		.long	0
;
		.word	4
texthint1:	.word	notes$k_noop
		.long	cont
		.long	0
;
		.long	0




;	movw	#4, Disp_I
;	movw	#notes$k_continue, Disp_i+2
;	movab	cont, Disp_I+4	

sh_1:	.ascid	/Re-enter note !AD as note !AD <<<<<<<<<<<<<<<<<<<<<<<<<</
sh_2:	.ascid	/re-set the reply count /
sh_3:	.ascid	/re-set the author and date fields/



bas_I:		.word	0
		.word	notes$k_note_id
		.long	0
		.long	0
;
                .word   4
                .word   notes$k_nosignal
                .long   no_sig
                .long   0
;
		.long	0




bas_o:		.word	4
		.word	notes$k_note_uid
		.long	base_uid
		.long	0
;
		.word	100
		.word	notes$k_note_id
		.long	bas_note
		.long	bas_note_len	
;
		.long	0

base_uid:	.blkl	1

bas_note:	.blkb	100
bas_note_len:	.blkl	1


ctr_881:	.ascid	/base note UID is !XL/
ctr_45:		.ascid	/find uid for base note (!AS)  as reply !UL/






add_tmp_i_r:	.word   0
                .word   Notes$K_Note_pen_Name
                .long   ret_per_name
                .long   0
;
Xti_len:	.word   0
                .word   notes$k_note_title
                .long   ret_note_title
                .long   0
;
		.word	4
		.word	notes$k_note_blink_uid
		.long	base_uid
		.long	0
;
		.word	4
		.word	notes$k_note_hidden
		.long	note_hidden
		.long	0
;
Nf_2:		.word	0
		.word	notes$k_notefile_file_name
		.long	Notefile_file_name
		.long	
;
		.long	0







mod_en:	.ascid	/%PAN-I-MODP, Enable moderator privileges on the Target conference/




move_i:
n_l:	.word	0
	.word	NOTES$K_NOTE_NEW_ID
n_s:	.long	0
	.long	0
;
o_l:	.word	0
	.word	NOTES$K_NOTE_ID
o_s:	.long	0
	.long	0
;
        .word   4
        .word   notes$k_nosignal
        .long   no_sig
        .long   0
;
	.long	0



ctr_p22:	.ascid	/Tmp_uid = !XL /



find_i:	.word	4
	.word	notes$k_note_uid
	.long	tmp_uid
	.long	0
;
	.long	0



shad_note_cont_tmp:	.blkl	1

;ctr_99:	.ascid	/Returned note ID  !UW.!UW/
ctr_99:	.ascid	/Returned note ID  !AD/




ctr_991:	.ascid	/!UW.!UW/

first_uid:	.blkl	1





nl_i:	.word	4
	.word	notes$k_note_uid
	.long	first_uid
	.long	0
;
	.long	0




nl_o:	.word	4
	.word	notes$k_note_uid
	.long	first_uid
	.long	0
;
	.long	0



note_hidden_t:	.ascid	/>>>>>>>>>>>> Note text is hidden <<<<<<<<<<<</


VEC:    .LONG   2
        .BLKL   1
        .LONG   0
        .LONG   0



try_mod:	.ascid	/Try for moderator priv on the Source conference/

master_topic:	.ascid	/TOPIC/
new_topic:	.ascid	/NEW/



new_topic_number:	.blkl	1
new_topic_flag:		.blkl	1
ctr_nt:	.ascid	/!UL.!UL/

o_note_id_len:	.blkl	1
o_note_id:	.blkb	100



save_len:	.blkl	1
save_ch:	.blkb	100


seen:	.ascid	/SEEN/
unseen:	.ascid	/UNSEEN/

seen_flag:	.blkl	1

seen_status:	.blkl	1

note_s:	.blkb	100


get_I_seen:	.word	0
		.word	notes$k_note_id
		.long	note_s
		.long	0
;
		.word	4
		.word	NOTES$K_NOTE_UNSEEN   
		.long	seen_status
		.long	0
;
		.long	0



se_msg:	.ascid	+Modify Seen/UNseen status+


ctr_se:	.ascid	/New SEEN state is !UL/

ctr_ot1:	.ascid	/Lines::   Found !UL :: Notes !UL/

aa1:	.blkl	1
ctr_a1:	.ascid	/TYpe = !UB/


aaa1:	.blkl	1
get_mod:	.ascid	/%PAN-I-MODP, Enable moderator status/

ctr_last1:	.ascid	/!UL bytes read from Notefile_user_area   /


not_add:	.blkl	1
add_add:	.blkl	1


ctr_tell:	.ascid	/!UL notes not added   ::   !UL notes added /


master_topic_flag:	.blkl	1


save_tell:	.ascid	/saving time of last read note................./

start_time:	.blkl	2


st_i:		.word	8
		.word	notes$k_notefile_user_area
		.long	start_time
		.long	0
;
		.long	0

ctr_last2:	.ascid	/Last note time was !%D/




create_flag:	.blkl	1




notes_open_i_create:   .word   0
                .word   notes$k_notefile_file_name
                .long   input+8
                .long   0
;
		.word   default_name_len
                .word   notes$k_notefile_default_name
		.long   default_name
		.long   default_name_len
;
		.word	4
		.word	notes$k_notefile_create
		.long	create_flag
		.long	0
;
rs_fl1:		.word	create_not_len
		.word	notes$k_notefile_notice
		.long	create_not_len_st
		.long	0
;
rs_fl2:		.word	create_tit_len
		.word	notes$k_notefile_title
		.long	create_tit_st
		.long	0
;
		.word	4
res_fl:		.word	notes$k_notefile_restricted
		.long	no_sig
		.long	0
;
		.word	4
wr_lo:		.word	notes$k_notefile_writelock
		.long	Xnotefile_writelock
		.long	0
;
		.word	4
		.word	notes$k_notefile_restricted
		.long	Xnotefile_restricted
		.long	0
;
                .long   0




create_not_len_st:	.ascii	/Mail to notes/
create_not_len = . - create_not_len_st


		.BLKB	100



create_tit_st:	.ascii	/Mail - notes !!!!!/
create_tit_len = . - create_tit_st


create:	.ascid	/CREATE/


op_msg_cre:	.ascid	/..... (Creating new conference)...../





notes_open_i_create2:   .word   0
                .word   notes$k_notefile_file_name
                .long   input+8
                .long   0
;
		.word   default_name_len
                .word   notes$k_notefile_default_name
		.long   default_name
		.long   default_name_len
;
		.word	4
		.word	notes$k_notefile_create
		.long	create_flag
		.long	0
;
c_n_l:		.word	0
		.word	notes$k_notefile_notice
		.long	notice
		.long	0
;
c_t_l:		.word	0
		.word	notes$k_notefile_title
		.long	title
		.long	0
;
		.word	4
		.word	notes$k_notefile_writelock
		.long	Xnotefile_writelock
		.long	0
;
		.word	4
		.word	notes$k_notefile_restricted
		.long	Xnotefile_restricted
		.long	0
;
                .long   0


Xnotefile_restricted:	.long	0
Xnotefile_writelock:	.long	1

shad_n:	.ascii	/ (shadow copy) /
shad_n_l = . - shad_n


moderate:       .long   1       ; we want to be a Goderator  !!



	.entry	delete,0



	pushaq	Since
	calls	#1,g^cli$present
	blbc	r0,60$

	movl	#100,out
	Pushaw  Out
	pushaq  Out
	pushaq  Since
	calls   #3,g^cli$get_value 
	check	r0,error	


	$bintim_s	timbuf=Out,-
			timadr=s_quad
	check	r0,error


	movw	#notes$k_note_Since_time, g_st

60$:	nop




	pushaq	Before
	calls	#1,g^cli$present
	blbc	r0,50$

	movl	#100,out
	Pushaw  Out
	pushaq  Out
	pushaq  Before
	calls   #3,g^cli$get_value 
	check	r0,error	


	$bintim_s	timbuf=Out,-
			timadr=b_quad
	check	r0,error


	movw	#notes$k_note_before_time, g_bt

50$:	nop






	pushaq	op_msg
	calls	#1,g^lib$put_output




; get the conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  conf
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i



; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	300$
301$:	nop

	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

300$:	nop



        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error



	pushaq	try_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify


	MOVL    R0,VEC+4

        $PUTMSG_S       MSGVEC=VEC





        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movab	file_cont, notes_beg_i+4



        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       




        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  del_note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       


; confirm status ?

	pushaq	Confirm
	calls	#1,g^cli$Present
	blbs	r0, 10$
	movl	#1,confirm_flag
10$:	nop


nxt_end:	nop

	movl    #100,Out
	Pushaw  Out
	pushaq  Out
	pushaq  range
	calls   #3,g^cli$get_value 
	blbs	r0,9$
	movl	#1,r0


	calls	#0,g^lib$show_timer

	ret
9$:	nop


; ----------------------- if this is (say) 9.* then convert it to 9.9999-9.0


; are the last two chars   ".*"



	movab	out+8,R6
	addl2	out,R6
	subl2	#2, R6

	cmpw	#^a/.*/, (R6)
	bneq	50$


	movab	out+8,Descr+4
	movl	out,Descr
	subl2	#2, Descr

        pushal  Tmp
        pushaq  Descr
        calls   #2,g^OTS$CVT_TI_L
	blbc	r0,50$

	movl	#100,out
	$fao_s	ctrstr=ctr_d1,outbuf=out,outlen=out,-
		p1=Tmp,-
		p2=Tmp
	pushaq	out
	calls	#1,g^lib$put_output



50$:	nop

	movl	out,r_note_len
	movc3	out,@out+4,r_note_id


; and access that note

	movw	out,get_i

	clrl	flag

; if /FAST then just delete


	calls	#0,g^lib$init_timer






nxt_loop:	nop


	tstl	flag
	bneq	33$

	incl	flag


        pushaw  add_add_o
        pushaw  get_i
        pushal  note_cont
        calls   #3,g^notes$note_get
	blbs	r0,101$
	cmpl	r0,#NOTES$_NO_MORE_NOTES
	bneq	102$
	brw	nxt_end
102$:	ret
101$:	nop



	brw	34$

33$:	nop

        pushaw  add_add_o
        pushaw  disp_IC
        pushal  note_cont
        calls   #3,g^notes$note_get
	blbs	r0,201$
	cmpl	r0,#NOTES$_NO_MORE_NOTES
	bneq	202$
	brw	nxt_end
202$:	ret
201$:	nop


34$:	nop

	movl	#100,out
	$fao_s	ctrstr=ctr_p3,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
	pushaq	out
	calls	#1,g^lib$put_output





ask_loop:


	movaq	del_pmt, R6


	cmpl	#1, write_flag
	bneq	8000$
	movl	#0, note_hidden
	movaq	wrt_pmt, R6
8000$:	nop

	cmpl	#2, write_flag
	bneq	8001$
	movl	#1, note_hidden
	movaq	nowrt_pmt, R6
8001$:	nop



	cmpl	#1, hid_flag			; set note hidden
	bneq	111$
	movaq	hid_pmt, R6

	movl	#1, note_hidden
111$:	nop


	cmpl	#2, hid_flag			; clear hidden note
	bneq	112$
	movaq	un_hid_pmt, R6

	movl	#0, note_hidden
112$:	nop



	cmpl	#0,Confirm_Flag
	beql	50$
	brw	do_del
50$:	nop


	movl	#100,out
	pushaw	out
	pushl	R6
	pushaq	out
	calls	#3,g^lib$get_input
	check	r0,error

	tstl	out
	bneq	49$
	brw	nxt_loop
49$:	nop

	cmpl	#1,out
	beql	51$
	brw	ask_loop
51$:	nop

	pushaq	out
	pushaq	out
        calls   #2,g^str$upcase

	cmpb	#^a/Y/,Out+8
	beql	300$


	cmpb	#^a/N/,Out+8
	beql	299$
	brw	ask_loop
299$:	brw	nxt_loop


300$:	nop
; delete it !

do_del:	nop

	tstl	write_flag
	beql	8114$

	pushaq	ch_wrt_st
	calls	#1,g^lib$put_output

	movw	#notes$k_note_writelock, Hss

	brw	8112$

8114$:	nop


	tstl	hid_flag
	beql	114$

	pushaq	ch_hid_st
	calls	#1,g^lib$put_output




	movw	#notes$k_note_hidden, Hss

8112$:	pushaw	null
	pushaw	del_i
	pushal  del_note_cont
	calls   #3,g^notes$note_modify

	MOVL    R0,VEC+4
        $PUTMSG_S       MSGVEC=VEC




	brw	nxt_loop
114$:	nop


	pushaq	del_msg
	calls	#1,g^lib$put_output



        pushaw  add_add_o
        pushaw  del_i	
        pushal  del_note_cont
        calls   #3,g^notes$note_delete



	brw	nxt_loop




	ret

del_msg:	.ascid	/................ Deleting note ................/
ch_hid_st:	.ascid	/................ Change Hidden status ........./
ch_wrt_st:	.ascid	/................ Change write status ........../

m_delete:		.ascid	/DELETE/
delete_flag:	.blkl	1
del_pmt:	.ascid	/DELETE  ? [N]: /
wrt_pmt:	.ascid	/SET NOTE WRITE ? [N]: /
nowrt_pmt:	.ascid	/SET NOTE noWRITE ? [N]: /

un_hid_pmt:	.ascid	/UNhide note ? [N] /
hid_pmt:	.ascid	/Hide note ? [N] /

confirm:	.ascid	/CONFIRM/
confirm_flag:	.blkl	1

actr_dm:	.ascid	/Confirm flag  !UL/

del_note_cont:	.blkl	1

range:	.ascid	/RANGE/
range_flag:	.blkl	1



	.entry	keyword,0


	pushaq	list
	calls	#1,g^cli$Present
	blbc	r0,33$
	incl	list_flag
33$:	nop



	pushaq	dlm
	calls	#1,g^lib$put_output


	pushaq	dlm
	calls	#1,g^lib$put_output





	pushaq	op_msg_mast
	calls	#1,g^lib$put_output






; get the master conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Master
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i


; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	300$
301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in

	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

300$:	nop



	movw	#full_default_name_len, def_l
	movab	full_default_name, def_n


        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; try for mod status

	pushaq	try_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_modify


	MOVL    R0,VEC+4

        $PUTMSG_S       MSGVEC=VEC






; get note context...

	movab	mast_file_cont, notes_beg_i+4



        pushaw  null
        pushaw  notes_beg_i
        pushal  mast_note_cont
        calls   #3,G^Notes$KeyWord_begin
        check   r0,error                                                                       

; --------------------------------------------------------------

	pushaq	dlm
	calls	#1,g^lib$put_output


	pushaq	op_msg_shad
	calls	#1,g^lib$put_output





; get the shadow conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Shadow
	calls   #3,g^cli$get_value 
	check	r0,error



	movw	input,notes_open_i



; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,1301$			; skip if NOnotebook
	brw	1300$
1301$:	nop

	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output


; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

1300$:	nop


	movw	#default_name_len, def_l
	movab	default_name, def_n

        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


1123$:	nop





	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; enable mod priv !!

;	pushaq	mod_en
;	calls	#1,g^lib$put_output

;        pushaw  open_o
 ;       pushaw  open_m
  ;      pushal  shad_file_cont
   ;     calls   #3,G^Notes$notefile_modify
;	check	r0,error



        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output






; get note context...

	movab	shad_file_cont, notes_beg_i+4



        pushaw  null
        pushaw  notes_beg_i
        pushal  shad_note_cont
        calls   #3,G^Notes$keyword_begin
        check   r0,error                                                                       


nx_key:	nop


	pushaq	dlm
	calls	#1,g^lib$put_output


        pushaw  key_oo
        pushaw  key_i
        pushal  mast_note_cont
        calls   #3,G^Notes$KeyWord_get
        check   r0,error                                                                       


	movw	#notes$k_continue,key_i+2


ky_loop:	nop





        pushaw  key_o
        pushaw  key_ic
        pushal  mast_note_cont
        calls   #3,G^Notes$KeyWord_get_note
	blbs	r0,101$
	cmpl	r0,#NOTES$_NO_MORE_NOTES
	bneq	102$
	brw	nx_key
102$:	ret
101$:	nop

	tstl	note_id_len
	beql	ky_loop


	movl	#100,out
	$fao_s	ctrstr=ctr_key,outbuf=out,outlen=out,-
		p1=ret_key_name_len,-
		p2=#ret_key_name,-
		p3=note_id_len,-
		p4=#note_id
	pushaq	out
	calls	#1,g^lib$put_output


; set it !!

		movw	ret_key_name_len, key_set
		movw	note_id_len, ksi

	tstl	list_flag
	bneq	12$

        pushaw  Null
        pushaw  key_set
        pushal  shad_note_cont
        calls   #3,G^Notes$KeyWord_add
	blbs	r0,12$
	MOVL    R0,VEC+4
        $PUTMSG_S       MSGVEC=VEC
12$:	nop


	brw	ky_loop

	ret

key_i:	.word	1
	.word	notes$k_keyword_name
	.long	key_name
	.long	0
;
	.word	4
	.word	notes$k_keyword_hint_get_note
	.long	hint_get_note
	.long	0
;
	.long	0

hint_get_note:	.long	1
key_name:	.ascii	/*/




key_ic:	.word	4
	.word	notes$k_continue
	.long	CONT
	.long	0
;
	.word	4
	.word	notes$k_nosignal
	.long	cont
	.long	0
;
	.long	0




key_o:	.word	100
	.word	notes$k_note_id
	.long	note_id
	.long	note_id_len
;
	.long	0


ret_key_name:	.blkb	100
ret_key_name_len:	.blkl	1

ctr_key:	.ascid	/Keyword "!AD"    note !AD/





key_oo:	.word	100
	.word	notes$k_keyword_name
	.long	ret_key_name
	.long	ret_key_name_len
;
	.long	0


ctr_p333:	.ascid	/!AD, !AD, !%D/




key_set:	.word	0
		.word	notes$k_keyword_name
		.long	ret_key_name
		.long	0
;
ksi:		.word	0
		.word	notes$k_note_id
		.long	note_id
		.long	0
;
		.long	0


since:	.ascid	/SINCE/


skip_ch:	.ascid	/skiping check... (no notes in Target)/


shadnumber_of_notes:	.blkl	1

res_flag:	.blkl	1

no_top:	.ascid	/...........NOTES$_NO_TOPIC............./

ctr_890:	.ascid	/!AS.0/

mod_shad_note_cont:	.blkl	1


topic_exists:	.blkl	1
ctr_xx:		.ascid	/topic_exists = !UL/


se_i:	.word	8
	.word	notes$k_note_before_time
	.long	notefile_user_area
	.long	0
;
        .word   4
        .word   NOTES$K_NOTE_MARK_SEEN
        .long   no_sig
        .long   0
;
        .word   4
        .word   notes$k_nosignal
        .long   no_sig
        .long   0
;
	.long	0



se_o:	.word	1000
	.word	notes$k_seen_map
	.long	seen_map
	.long	seen_map_len
;
	.long	0

seen_map:	.blkb	3000
seen_map_len:	.blkl	1


map_bl:	.ascid	+Doing a "Notes> Set Seen /Before = <Date>"+

TIME:	.ASCID	/8-SEP-1954/

list:	.ascid	/LIST/
list_flag:	.blkl	1


se_fl:	.blkl	1


note_1:		.word   1
                .word   notes$k_note_id
                .long   note_1_st
                .long   0
;
		.long	0


note_1_st:	.ascii	/1/


in_msg:	.ascid	/inv the cache /


p_quad:	.blkl	2
b_quad:	.blkl	2
s_quad:	.blkl	2



only_doing_base_notes:	.blkl	1



sk_th:	.ascid	/skiping this note (looking for base notes only!)  /

no_rep:	.ascid	/<<<<<<<<<< now repeating scan (for replies) >>>>>>>>>/

ctr_ent:	.ascid	/%PAN-I-ENTO, Opening notebook entry !AS ............../
ctr_ent1:	.ascid	/%PAN-I-CONO, Opening conference     !AS ............../

notebook_file_cont:	.blkl	1

notebook_spec:		.long	100
			.long	notebook_spec+8
			.blkb	100


notebook:	.ascid	/NOTEBOOK/


notebook_in:	.word   0
                .word   notes$k_notefile_file_name
                .long   notebook_spec+8
                .long   0
;
		.word	notebook_def_len
		.word	notes$k_notefile_default_name
		.long	notebook_def_spec
		.long	0
;
		.long	0


notebook_def_spec:	.ascii	/SYS$LOGIN:notes$notebook.NOTE/
notebook_def_len = . - notebook_def_spec


book_in:	.word	4
		.word	notes$k_notefile_context
		.long	notebook_file_cont
		.long	0
;
		.long	0

notebook_cont:	.blkl	1


ent_in:		.word	0
		.word	notes$k_entry_name
		.long	0
		.long	0
;
		.word   default_name_len
cl_xy:          .word   notes$k_noop		;notes$k_notefile_default_name
		.long   default_name
                .long   default_name_len
;
		.long	0


ent_out:	.word	100
		.word	notes$k_notefile_file_name
		.long	Notefile_file_name
		.long	Notefile_file_name_len
;
		.word	4
		.word	notes$k_entry_last_status
		.long	last_status
		.long	0
;
		.word	4
		.word	notes$k_entry_unseen_est
		.long	unseen_est
		.long	0
;
		.word	100
		.word	notes$k_entry_name
		.long	entry_name
		.long	entry_name_len
;
		.word	3000
		.word	notes$k_seen_map
		.long	seen_map
		.long	seen_map_len
;
		.word	100
		.word	NOTES$K_ENTRY_USER_AREA
		.long	note_user_area
		.long	note_user_area_len
;
		.word	4
		.word	notes$k_notefile_entrytotal
		.long	entrytotal
		.long	0
;
		.word	4
		.word	notes$k_notefile_high_uid
		.long	high_uid
		.long	0
;
		.word	8
		.word	notes$k_notefile_lastrev
		.long	notefile_lastrev
		.long	0
;
		.word	300
		.word	notes$k_notefile_moderator
		.long	moderator_st
		.long	moderator_st_len
;
                .word   100
                .word   notes$k_notefile_notice
                .long   notice
                .long   notice_len
;
		.word   4
                .word   notes$k_notefile_numnotes
                .long   number_of_notes
                .long   0
;
		.word   100
                .word   notes$k_notefile_title
                .long   title
                .long   title_len
;
		.word	3000
		.word	notes$k_seen_map
		.long	seen_map
		.long	seen_map_len
;
		.long	0

                                                                  




entry_name:	.blkb	100
entry_name_len:	.blkl	1

last_status:	.blkl	1
unseen_est:	.blkl	1

write:		.ascid	/WRITE/

	.entry	r_create,0


	pushaq	write
	calls	#1,g^cli$present
	blbc	r0,55$
	movw	#notes$k_noop, wr_lo
55$:	nop

; get the conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  conf
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i_create
	movl	input+4,notes_open_i_create+4


	incl	create_flag
;	clrw	notes_open_i_create+12


;	movw	#l_default_name_len , notes_open_i_create+12
;	movab	l_default_name, notes_open_i_create+16



	movl    #100,out
	Pushaw  out
	pushaq  out
	pushaq  r_title
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	out, rs_fl2
	movc3	out, out+8, create_tit_st

	movab	create_tit_st, rs_fl2+4




	movl    #100,out
	Pushaw  out
	pushaq  out
	pushaq  r_notice
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	out, rs_fl1
	movc3	out, out+8, create_not_len_st


	movw	#notes$k_noop, res_fl

	pushaq	rest
	calls	#1,g^cli$present
	blbc	r0,10$

	movw	#notes$k_notefile_restricted, res_fl

10$:	nop


        pushaw  notes_open_o
        pushaw  notes_open_i_create
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
 ;       calls   #1,g^lib$put_output


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent9,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

; base note ???

	pushaq	base_note
	calls	#1,g^Cli$Present
	blbs	r0,100$
	movl	#1,R0
	ret
100$:	nop



        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       





	pushaq	add_base
	calls	#1,g^lib$put_output





	movl    #100,input
	Pushaw  input
	pushaq  input
	pushaq  in_file1
	calls   #3,g^cli$get_value 
	check	r0,error




	movl	#100,out
	$Fao_s	ctrstr=ctr_ent9x,outbuf=out,outlen=out,-
		p1=#input
	pushaq	out
	calls	#1,g^lib$put_output




	movb	input,Tfab+fab$b_fns
	movl	input+4,Tfab+fab$l_fna


	$Open	fab=Tfab
	check	r0,error

	$connect	rab=Trab
	check	r0,error




	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  atitle1
	calls   #3,g^cli$get_value 
	check	r0,error



	movw	input,add_add_i
	movab	input+8,add_add_i+4




; add a note
	clrw	add_add_i+12

        pushaw  add_add_o
        pushaw  add_add_i
        pushal  note_cont
        calls   #3,g^notes$note_add
        check   r0,error

; stamp it
	movl	uid, uid_to_stamp


; ....................................................

; now enter the text....


xr_loop:	nop


	movw	#10000,Trab+rab$w_rsz
	movw	#10000,Trab+rab$w_usz

	$get	rab=Trab
	blbs	r0,10$
	cmpl	r0,#rms$_eof
	beql	xr_loop_end
	ret
10$:	nop

	incl	text_lines


	movab	Tbuffer, add_txt_st
	movw	Trab+rab$w_rsz, add_txt_len


	pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error


	movw	#notes$k_continue,add_txt_i+2


	brw	xr_loop


xr_loop_end:	nop


	pushaq	dlm
	calls	#1,g^lib$put_output




	movw	#0, add_txt_len
	movw	#notes$k_text_end,add_txt_i+2


	pushaw  add_txt_o
        pushaw  add_txt_i
        pushal  note_cont
        calls   #3,g^notes$note_add_text
        check   r0,error



	pushaw	null
	pushaw	stamp_in
	pushal	note_cont
	calls	#3,g^notes$note_modify
	check	r0,error


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent9x1,outbuf=out,outlen=out,-
		p1=text_lines
	pushaq	out
	calls	#1,g^lib$put_output

	ret

ctr_ent9x1:	.ascid	/!UL lines written to the base note/


add_base:	.ascid	/Adding base note........../

r_title:	.ascid	/TITLE/
r_notice:	.ascid	/NOTICE/

rest:	.ascid	/RESTRICTED/

ctr_ent9:	.ascid	/Created notes file !AS/

base_note:	.ascid	/BASE_NOTE/

atitle1:	.ascid	/BASE_NOTE.TITLE/

ctr_ent9x:	.ascid	/Reading base note text from file !AS/
in_file1:	.ascid	/BASE_NOTE.FILE/

original_note_uid:	.blkl	1


uid_cld:	.ascid	/UID/

uid_cld_flag:	.blkl	1


ctr_ent9x2:	.ascid	/Setting note UID to !XL   (from !XL)/

ctr_123:	.ascid	/note UID !XL::/



o_max:	.word	4
	.word	notes$k_notefile_high_uid
	.long	high_uid
	.long	0
;
	.word	4
	.word	notes$k_notefile_numnotes
	.long	note_numnotes
	.long	0
;
	.long	0

note_numnotes:	.blkl	1

high_uid:	.blkl	1

res_nx:	.ascid	/re-set next uid field/

no_eq:	.ascid	/Unequal high_uid........................................../

max_uid:	.blkl	1
ctr_1235:	.ascid	/new maximum UID     !UW........................./

res_nx_1:	.ascid	/saving maximum uid/

append:		.ascid	/APPEND/


access_flag:	.blkl	1

	.entry	show,0


	pushaq	Access
	calls	#1,g^cli$Present
	blbc	r0, 34$
	movl	#1,access_flag
34$:	nop

; confirm status ?

	pushaq	Confirm
	calls	#1,g^cli$Present
	blbs	r0, 10$
	movl	#1,confirm_flag
10$:	nop


	pushaq	m_delete
	calls	#1,g^cli$Present
	blbc	r0,33$
	incl	delete_flag
33$:	nop


	pushaq	cld_mem
	calls	#1,g^cli$present
	blbc	r0,200$
	incl	show_mods_flag


; get the member name

	movl    #100,mail_li
	Pushaw  mail_li
	pushaq  mail_li
	pushaq 	cld_mem
	calls   #3,g^cli$get_value 
	check	r0,error	

	pad_star	mail_li

	movw	mail_li, mod_i
	movab	mail_li+8, mod_i+4

200$:	nop


	pushaq	append
	calls	#1,cli$present
	blbc	r0,2119$

	$fab_store	fab=Dfab,fop=<Cif,Nam>

	$rab_store	rab=Drab, rop=<Eof>

2119$:	nop


; output file

	pushaq	output
	calls	#1,cli$present
	blbs	r0,1119$
	brw	19$
1119$:	nop


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  output
	calls   #3,g^cli$get_value 
	check	r0,error	

	movb	input,Dfab+fab$b_fns
	movl	input+4,Dfab+fab$l_fna



	$create	fab=Dfab
	check	r0,error


	$connect	rab=Drab
	check	r0,error

	incl	output_flag

	cvtbl   NAM+NAM$B_RSL,Descr
	movab	result,Descr+4

	movl	#100,out
	$Fao_s	ctrstr=ctr_out_f,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


	movw	com_dlm, Drab+rab$w_rsz
	movw	com_dlm, Drab+rab$w_usz

	movab	com_dlm+8, 	Drab+rab$l_Rbf
	movab	com_dlm+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error





19$:	nop



	pushaq	op_msg
	calls	#1,g^lib$put_output








; /range ???


	pushaq	range
	calls	#1,g^cli$Present
	blbc	r0,459$
	incl	range_flag




;get the value to list

	movl    #100,range_v
	Pushaw  range_v
	pushaq  range_v
	pushaq  range
	calls   #3,g^cli$get_value 
	check	r0,error


459$:	nop







; get the conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  conf
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i


; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	no_note
301$:	nop

	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4


	incl	using_notebook

	pad_star	ent_in
repeat:	nop


	tstl	rep_fl
	beql	3390$
	$exit_s	code=#1
3390$:	nop
	incl	rep_fl

	tstl	symbol
	bneq	123$
	$exit_s	code=#1
123$:	nop


	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error

	movl	#notes$k_continue, ent_in+2


	movl	entry_name_len, descr
	movab	entry_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

; tell us a few things about the entry

	pushaq	dlm
	calls	#1,g^lib$put_output




no_note:	nop






        pushaw  notes_open_o_show
        pushaw  notes_open_i
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
;        check   r0,error

	blbs	r0,67$

        pushaw  null
        pushaw  null
        pushal  file_cont
        calls   #3,G^Notes$notefile_end

	brw	repeat
67$:	nop




	tstl	output_flag
	bneq	11123$
	brw	1123$
11123$:	nop



	movl	title_len,Descr
	movab	title,Descr+4

	movl	#100,out
	$fao_s	ctrstr=com_dlm1,outbuf=out,outlen=out,-
		p1=#Descr


	movw	Out, Drab+rab$w_rsz
	movw	Out, Drab+rab$w_usz

	movab	Out+8, 	Drab+rab$l_Rbf
	movab	Out+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error



; 


	movw	ft_1, Drab+rab$w_rsz
	movw	ft_1, Drab+rab$w_usz

	movab	ft_1+8, 	Drab+rab$l_Rbf
	movab	ft_1+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error


	movw	ft_2, Drab+rab$w_rsz
	movw	ft_2, Drab+rab$w_usz

	movab	ft_2+8, 	Drab+rab$l_Rbf
	movab	ft_2+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error




	movw	#1, Drab+rab$w_rsz
	movw	#1, Drab+rab$w_usz

	$put	rab=Drab
	check	r0,error
	$put	rab=Drab
	check	r0,error



1123$:	nop


	pushaq	dlm
	calls	#1,g^lib$put_output

	tstl	range_flag
	beql	600$
	brw	list_range
600$:	nop


	tstl	show_mods_flag
	beql	200$
	movl	#0, moderate
	brw	show_mods
	ret
200$:	nop





        movl    result_spec_len,Descr
        movab   result_spec,descr+4

; get out the filename

	$FileScan_s	Srcstr=Descr,-
			Valuelst=Valuelst
	check	r0,error

	movzwl	ValueLst, file_name
	movl	ValueLst+4, file_name+4


; if /symbol then use that instead...

	pushaq	symbol
	calls	#1,g^cli$present
	blbc	r0,3300$


	movl    #100,symbol_v
	Pushaw  symbol_v
	pushaq  symbol_v
	pushaq  symbol
	calls   #3,g^cli$get_value 
	check	r0,error

	movzwl	symbol_v, file_name
	movl	symbol_v+4, file_name+4

; nullify the PAD_STAR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	clrl	symbol

3300$:	nop


; symbol
; sym_6:	.ascid	/PAN$!AS_UNSEEN/


	movl	#100,out
	$fao_s	ctrstr=show_20,outbuf=out,outlen=out,-
		p1=unseen_est
	pushaq	out
	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_integer,outbuf=out,outlen=out,-
		p1=unseen_est
;	pushaq	out
;	calls	#1,g^lib$put_output


	movl	#100,Sout
	$fao_s	ctrstr=sym_6,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output




        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    


	$getmsg_s	msgid=last_status,-
			msglen=last_status_st,-
			bufadr=last_status_st
	check	r0,error



	movl	#100,out
	$fao_s	ctrstr=show_21,outbuf=out,outlen=out,-
		p1=#last_status_st
	pushaq	out
	calls	#1,g^lib$put_output





; symbol
; sym_3:	.ascid	/PAN$!AS_FILE/

	movl	#100,out
	$fao_s	ctrstr=show_1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_string,outbuf=out,outlen=out,-
		p1=#Descr
;	pushaq	out
;	calls	#1,g^lib$put_output



	movl	#100,Sout
	$fao_s	ctrstr=sym_3,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output



        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    


	movl	title_len,Descr
	movab	title,Descr+4

; symbol
; sym_1:	.ascid	/PAN$!AS_TITLE/

	movl	#100,out
	$fao_s	ctrstr=show_2,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




	movl	#100,out
	$fao_s	ctrstr=ctr_string,outbuf=out,outlen=out,-
		p1=#Descr
;	pushaq	out
;	calls	#1,g^lib$put_output




	movl	#100,Sout
	$fao_s	ctrstr=sym_1,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    

        movl    notice_len,Descr
        movab   notice,descr+4


; symbol
; sym_2:	.ascid	/PAN$!AS_NOTICE/

	movl	#100,out
	$fao_s	ctrstr=show_3,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




	movl	#100,out
	$fao_s	ctrstr=ctr_string,outbuf=out,outlen=out,-
		p1=#descr
;	pushaq	out
;	calls	#1,g^lib$put_output



	movl	#100,Sout
	$fao_s	ctrstr=sym_2,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    


; symbol
; sym_5:	.ascid	/PAN$!AS_TOPICS/

	movl	#100,out
	$fao_s	ctrstr=show_4,outbuf=out,outlen=out,-
		p1=notefile_numnotes
	pushaq	out
	calls	#1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_integer,outbuf=out,outlen=out,-
		p1=notefile_numnotes
;	pushaq	out
;	calls	#1,g^lib$put_output



	movl	#100,Sout
	$fao_s	ctrstr=sym_5,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    



	movab	no, R6
	tstl	notefile_reply_only
	beql	10$
	movab	yes, R6
10$:	nop

	movl	#100,out
	$fao_s	ctrstr=show_5,outbuf=out,outlen=out,-
		p1=R6
	pushaq	out
	calls	#1,g^lib$put_output



	movab	no, R6
	tstl	notefile_restricted
	beql	20$
	movab	yes, R6
20$:	nop

; symbol
; sym_8:	.ascid	/PAN$!AS_RESTRICT/

	movl	#100,out
	$fao_s	ctrstr=show_6,outbuf=out,outlen=out,-
		p1=R6
	pushaq	out
	calls	#1,g^lib$put_output




	movl	#100,out
	$fao_s	ctrstr=ctr_string,outbuf=out,outlen=out,-
		p1=R6
;	pushaq	out
;	calls	#1,g^lib$put_output



	movl	#100,Sout
	$fao_s	ctrstr=sym_8,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    



	movab	no, R6
	tstl	notefile_writelock
	beql	30$
	movab	yes, R6
30$:	nop


; symbol
; sym_7:	.ascid	/PAN$!AS_WRITE/

	movl	#100,out
	$fao_s	ctrstr=show_7,outbuf=out,outlen=out,-
		p1=R6
	pushaq	out
	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_string,outbuf=out,outlen=out,-
		p1=R6
;	pushaq	out
;	calls	#1,g^lib$put_output




	movl	#100,Sout
	$fao_s	ctrstr=sym_7,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    


	movl	#100,out
	$fao_s	ctrstr=show_9,outbuf=out,outlen=out,-
		p1=server_max_item
	pushaq	out
	calls	#1,g^lib$put_output






	movl	#100,out
	$fao_s	ctrstr=show_11,outbuf=out,outlen=out,-
		p1=entrytotal
	pushaq	out
	calls	#1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=show_12,outbuf=out,outlen=out,-
		p1=format
	pushaq	out
	calls	#1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=show_14,outbuf=out,outlen=out,-
		p1=notefile_high_uid
	pushaq	out
	calls	#1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=show_8,outbuf=out,outlen=out,-
		p1=#notefile_create_time
	pushaq	out
	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=show_15,outbuf=out,outlen=out,-
		p1=#notefile_lastrev
	pushaq	out
	calls	#1,g^lib$put_output


; symbol
; sym_4:	.ascid	/PAN$!AS_MODERATOR/

	movl	#100,out
	$fao_s	ctrstr=show_16,outbuf=out,outlen=out,-
		p1=moderator_st_len,-
		p2=#moderator_st
	pushaq	out
	calls	#1,g^lib$put_output


	movl	moderator_st_len, descr
	movab	moderator_st, descr+4

	movl	#100,out
	$fao_s	ctrstr=ctr_string,outbuf=out,outlen=out,-
		p1=#descr
;	pushaq	out
;	calls	#1,g^lib$put_output




	movl	#100,Sout
	$fao_s	ctrstr=sym_4,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    



	movab	yes, R6
	tstl	create_keyword
	beql	40$
	movab	no, R6
40$:	nop


	movl	#100,out
	$fao_s	ctrstr=show_17,outbuf=out,outlen=out,-
		p1=R6
	pushaq	out
	calls	#1,g^lib$put_output



; symbol
; sym_9:	.ascid	/PAN$!AS_PANCOPY_TIMESTAMP/


	movl	#100,out
	$fao_s	ctrstr=show_18,outbuf=out,outlen=out,-
		p1=#notefile_user_area
	pushaq	out
	calls	#1,g^lib$put_output




	movl	#100,out
	$fao_s	ctrstr=ctr_date,outbuf=out,outlen=out,-
		p1=#notefile_user_area
;	pushaq	out
;	calls	#1,g^lib$put_output


	movl	#100,Sout
	$fao_s	ctrstr=sym_9,outbuf=Sout,outlen=Sout,-
		p1=#file_name
;	pushaq	Sout
;	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  out   ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    

	tstl	notefile_user_area
	bneq	1800$
	tstl	notefile_user_area+4
	bneq	1800$




        PUSHAL  DCLFLAG                
        PUSHAQ  None ; value of symbol
        PUSHAQ  Sout  ; symbol to set
        CALLS   #3,G^LIB$SET_SYMBOL    



1800$:	nop



	movl	#100,Sout
	$fao_s	ctrstr=sym_def,outbuf=Sout,outlen=Sout,-
		p1=#file_name
	pushaq	Sout
	calls	#1,g^lib$put_output

	tstl	using_notebook
	bneq	5678$
	ret
5678$:	nop



	clrl	flag



        pushaw  null
        pushaw  null
        pushal  file_cont
        calls   #3,G^Notes$notefile_end


	brw	repeat




	ret

; here for a listing of note

list_range:	nop


        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       




;get the value to list



	movw	range_v, disp_i
	movl	range_v+4, disp_i+4


	tstl	flag
	beql	331$
	brw	33$
331$:	nop


        pushaw  add_add_o
        pushaw  disp_i
        pushal  note_cont
        calls   #3,g^notes$note_get
	blbs	r0,2000$
	cmpl	r0,#NOTES$_NO_MORE_NOTES
	bneq	2001$
	brw	end_of_list_range
2001$:	ret
2000$:	nop



	incl	flag
	brw	34$
33$:	nop

        pushaw  add_add_o
        pushaw  disp_IC
        pushal  note_cont
        calls   #3,g^notes$note_get
	blbs	r0,3000$
	cmpl	r0,#NOTES$_NO_MORE_NOTES
	bneq	3001$
	brw	end_of_list_range
3001$:	ret
3000$:	nop


34$:	nop



	movl	#100,out
	$fao_s	ctrstr=ctr_p3,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
	pushaq	out
	calls	#1,g^lib$put_output


; related conf ?

	tstl	Notefile_file_name_len
	beql	600$

	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$fao_s	ctrstr=ctr_p3R,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


600$:	nop


; stamped ???


	tstl	note_user_area_len
	beql	733$

	cmpl	#^a/Peb /, note_user_area
	bneq	733$


	movl	#^a/..../, note_user_area

	movl	#100,out
	$fao_s	ctrstr=ctr_stamped,outbuf=out,outlen=out,-
		p1=note_user_area_len,-
		p2=#note_user_area
	pushaq	out
	calls	#1,g^lib$put_output



733$:	brw	33$


	ret
; here for show moderators (and members)

show_mods:	nop

; begin user



        pushaw  null
        pushaw  notes_beg_i
        pushal  note_cont
        calls   #3,G^Notes$user_begin
	check	r0,error
	



	tstl	delete_flag
	beql	m_get


	pushaq	mod_en
	calls	#1,g^lib$put_output

	clrl	open_m+12

	movl	#1, moderate
        pushaw  open_o
        pushaw  open_m
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify
	clrl	moderate



        pushaw  null
        pushaw  notes_beg_i
        pushal  other_note_cont
        calls   #3,G^Notes$user_begin
	check	r0,error


m_get:	nop


	movl	#user_moderate_st_len , user_moderate_st
	subl2	#8, user_moderate_st


	movl	#sl_user_moderate_st_len , sl_user_moderate_st
	subl2	#8, sl_user_moderate_st


	pushaw	mod_o
	pushaw	mod_i
	pushal	note_cont
	calls	#3,g^notes$user_get
	blbs	r0,51$
	cmpl	r0,#NOTES$_NO_MORE_users
	bneq	50$
	brw	mod_end
50$:	ret
51$:	nop




; if we have an access list AND a node list.. then
; drop the node list


	movw	#notes$k_noop, m_a+2
	movw	#notes$k_user_nodename, k_aa+2

	tstl	user_nodename_len	; access list size
	beql	400$

	clrl	k_user_nodename_len
	movw	#notes$k_user_access_list, m_a+2
	movw	#notes$k_noop, k_aa+2
400$:	nop



	movw	user_name_len, mod_mem
                               




	incl	listed



	tstl	access_flag
	beql	333$


	pushaq	Dlm
	calls	#1,g^lib$put_output

	movl	user_nodename_len, descr
	movab	user_nodename, descr+4


	movl	#100,out
	$fao_s	ctrstr=show_mod1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

333$:	nop



	tstl	access_flag
	beql	332$

	movl	k_user_nodename_len , descr
	movab	k_user_nodename , descr+4

	movl	#100,out
	$fao_s	ctrstr=show_mod1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output





332$:	nop	


write_fl_s:	nop

	tstl	output_flag
	bneq	2000$
	brw	write_fl_e
2000$:	nop





	movl	user_nodename_len, Descr
	movab	user_nodename, Descr+4


	tstl	user_nodename_len
	bneq	4499$

	movl	k_user_nodename_len, Descr
	movab	k_user_nodename, Descr+4

4499$:	nop







798$:	;pushaq	descr
	;calls	#1,g^lib$put_output

	locc	#^a/,/,Descr,@Descr+4
	bneq	1801$
	brw	799$
1801$:	nop


	movl	Descr, Quad
	subl2	R0, Descr


;	pushaq	descr
;	calls	#1,g^lib$put_output



	movab	blank_nl, R8
	tstl	user_moderate
	beql	81003$
	movab	sl_user_moderate_st, R8
81003$:	nop


; if no mail add then giv him one !

	tstl	mail_addr_len
	bneq	5000$
	
	movl	descr, mail_addr_len
	movc3	descr, @descr+4, mail_addr

5000$:	nop


	movl	#500,out
	$fao_s	ctrstr=wr_mod_of,outbuf=out,outlen=out,-
		p1=mail_addr_len,-
		p2=#mail_addr,-

		p3=user_name_len,-
		p4=#user_name,-
;
		p5=R8,-
		p6=#Descr



	movw	out, Drab+rab$w_rsz
	movw	out, Drab+rab$w_usz

	movab	out+8, 	Drab+rab$l_Rbf
	movab	out+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error


	movl	#2, mail_addr_len
	movw	#^a/  /,mail_addr


	clrl	sl_user_moderate_st


	addl2	Descr, Descr+4
	subl3	descr, quad, descr

	decl	descr
	incl	descr+4

	
	brw	798$


799$:	nop

;	pushaq	Dlm
;	calls	#1,g^lib$put_output

;	pushaq	descr
;	calls	#1,g^lib$put_output



	movab	blank_nl, R8
	tstl	user_moderate
	beql	51003$
	movab	sl_user_moderate_st, R8
51003$:	nop

; if no mail add then giv him one !

	tstl	mail_addr_len
	bneq	5001$
	
	movl	descr, mail_addr_len
	movc3	descr, @descr+4, mail_addr

5001$:	nop




	movl	#500,out
	$fao_s	ctrstr=wr_mod_of,outbuf=out,outlen=out,-
		p1=mail_addr_len,-
		p2=#mail_addr,-

		p3=user_name_len,-
		p4=#user_name,-
;
		p5=R8,-
		p6=#Descr



	movw	out, Drab+rab$w_rsz
	movw	out, Drab+rab$w_usz

	movab	out+8, 	Drab+rab$l_Rbf
	movab	out+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error


800$:	nop



	brw	nxt

write_fl_e:	nop
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


	pushaq	blank
	calls	#1,g^lib$put_output

	pushaq	mem_header
	calls	#1,g^lib$put_output


	movl	user_nodename_len, Descr
	movab	user_nodename, Descr+4


	tstl	user_nodename_len
	bneq	4499$

	movl	k_user_nodename_len, Descr
	movab	k_user_nodename, Descr+4

4499$:	nop







798$:	;pushaq	descr
	;calls	#1,g^lib$put_output

	locc	#^a/,/,Descr,@Descr+4
	bneq	1801$
	brw	799$
1801$:	nop


	movl	Descr, Quad
	subl2	R0, Descr


;	pushaq	descr
;	calls	#1,g^lib$put_output



	movab	blank_nl, R8
	tstl	user_moderate
	beql	81003$
	movab	user_moderate_st, R8
81003$:	nop

	movl	#100,out
	$fao_s	ctrstr=ctr_shm,outbuf=out,outlen=out,-
		p1=user_name_len,-
		p2=#user_name,-
;
		p3=#Descr,-
;
		p4=mail_addr_len,-
		p5=#mail_addr,-
;
		p6=R8



	pushaq	out
	calls	#1,g^lib$put_output

	clrl	user_moderate_st
	clrl	user_name_len
	clrl	mail_addr_len


	addl2	Descr, Descr+4
	subl3	descr, quad, descr

	decl	descr
	incl	descr+4

	
	brw	798$


799$:	nop

;	pushaq	Dlm
;	calls	#1,g^lib$put_output

;	pushaq	descr
;	calls	#1,g^lib$put_output



	movab	blank_nl, R8
	tstl	user_moderate
	beql	51003$
	movab	user_moderate_st, R8
51003$:	nop

	movl	#100,out
	$fao_s	ctrstr=ctr_shm,outbuf=out,outlen=out,-
		p1=user_name_len,-
		p2=#user_name,-
;
		p3=#Descr,-
;
		p4=mail_addr_len,-
		p5=#mail_addr,-
;
		p6=R8
	pushaq	out
	calls	#1,g^lib$put_output


800$:	nop


; -------------------------------------------------------------
; are we deleting ???

	tstl	delete_flag
	bneq	8332$
	brw	8333$
8332$:	nop



	cmpl	#0,Confirm_Flag
	beql	950$
	brw	300$
950$:	nop



	movl	#100,out
	pushaw	out
	pushal	del_pmt
	pushaq	out
	calls	#3,g^lib$get_input
	check	r0,error

	tstl	out
	bneq	49$
	brw	8333$
49$:	nop

	cmpl	#1,out
	beql	851$
	brw	800$
851$:	nop

	pushaq	out
	pushaq	out
        calls   #2,g^str$upcase

	cmpb	#^a/Y/,Out+8
	beql	300$


	cmpb	#^a/N/,Out+8
	beql	8333$
	brw	800$

300$:	nop

	pushaq	del_mem
	calls	#1,g^lib$put_output



	movab	user_name, mod_mem+4
	clrl	mod_mem+12



	pushaw	null
	pushaw	mod_mem
	pushal	other_note_cont
	calls	#3,g^notes$user_delete

8333$:	nop
nxt:	nop
; -------------------------------------------------------------


	movw	#4, mod_i
	movw	#notes$k_continue,mod_i+2

	brw	m_get



mod_end:	nop

	movl	#100,out
	$fao_s	ctrstr=ctr_mod,outbuf=out,outlen=out,-
		p1=listed
	pushaq	out
	calls	#1,g^lib$put_output


	movw	#1, mod_i
	movw	#notes$k_user_name,mod_i+2


	clrl	flag

        pushaw  null
        pushaw  null
        pushal  note_cont
        calls   #3,G^Notes$user_end


        pushaw  null
        pushaw  null
        pushal  file_cont
        calls   #3,G^Notes$notefile_end



	tstl	using_notebook
	bneq	10$
	ret
10$:	nop



	brw	repeat





; ------------------------------------------------------
end_of_list_range:	nop



	clrl	flag

        pushaw  null
        pushaw  null
        pushal  note_cont
        calls   #3,G^Notes$note_end


        pushaw  null
        pushaw  null
        pushal  file_cont
        calls   #3,G^Notes$notefile_end



	tstl	using_notebook
	bneq	10$
	ret
10$:	nop



	brw	repeat

	ret

listed:	.blkl	1

ctr_mod:	.ascid	+!/..... !UL Members listed .....+

mod_o:	.word	255
	.word	notes$k_user_mail_addr
	.long	mail_addr
	.long	mail_addr_len
;
	.word	255
	.word	notes$k_user_name
	.long	user_name
	.long	user_name_len
;
	.word	255
	.word	notes$k_user_access_list
	.long	user_nodename
	.long	user_nodename_len
;
	.word	4
	.word	notes$k_user_moderate
	.long	user_moderate
	.long	0
;
	.word	4
	.word	notes$k_user_create_keyword
	.long	user_create_keyword
	.long	0
;
	.word	4
	.word	notes$k_user_write_bypass
	.long	write_bypass
	.long	0
;
	.word	300
	.word	notes$k_user_nodename
	.long	k_user_nodename
	.long	k_user_nodename_len
;
	.long	0


k_user_nodename:	.blkb	300
k_user_nodename_len:	.blkl	1

user_create_keyword:		.blkl	1
write_bypass:		.blkl	1

user_moderate:		.blkl	1

mail_addr:		.blkb	255
mail_addr_len:		.blkl	1

user_nodename:		.blkb	255
user_nodename_len:	.blkl	1

user_name:		.blkb	255
user_name_len:		.blkl	1

mod_name:	.ascii	/*/

	movw	#4, mod_i
	movw	#notes$k_continue,mod_i+2


mod_i:	.word	1
	.word	notes$k_user_name
	.long	mod_name
	.long	0
;
	.word	4
	.word	notes$k_nosignal
	.long	no_sig
	.long	0
;
;	.word	4
;	.word	notes$k_user_moderate
;	.long	moderate
;	.long	0
;
	.long	0








notes_open_o_show:
		.word   100
                .word   notes$k_notefile_title
                .long   title
                .long   title_len
;
                .word   150
                .word   notes$k_notefile_result_spec
                .long   result_spec
                .long   result_spec_len
;
                .word   100
                .word   notes$k_notefile_notice
                .long   notice
                .long   notice_len
;
		.word	4
		.word	notes$k_notefile_entrytotal
		.long	entrytotal
		.long	0
;
		.word	4
		.word	notes$k_notefile_format
		.long	format
		.long	0
;
		.word	4
		.word	notes$k_notefile_high_uid
		.long	notefile_high_uid
		.long	0
;
		.word	8
		.word	notes$k_notefile_lastrev
		.long	notefile_lastrev
		.long	0
;
		.word	300
		.word	notes$k_notefile_moderator
		.long	moderator_st
		.long	moderator_st_len
;
		.word	4
		.word	notes$k_notefile_numnotes
		.long	notefile_numnotes
		.long	0
;
		.word	4
		.word	notes$k_notefile_reply_only
		.long	notefile_reply_only
		.long	0
;
		.word	4
		.word	notes$k_notefile_restricted
		.long	notefile_restricted
		.long	0
;
		.word	4
		.word	notes$k_notefile_writelock
		.long	notefile_writelock
		.long	0
;
		.word	8
		.word	notes$k_notefile_create_time
		.long	notefile_create_time
		.long	0
;
		.word	4
		.word	notes$k_server_max_item
		.long	server_max_item
		.long	0

;
		.word	4
		.word	notes$k_user_create_keyword
		.long	create_keyword
		.long	0
;
		.word	100
		.word	notes$k_notefile_user_area
		.long	notefile_user_area
		.long	notefile_user_area_len
;
                .long   0



create_keyword:		.blkl	1

entrytotal:		.blkl	1
format:			.blkl	1
notefile_high_uid:	.blkl	1
notefile_lastrev:	.blkl	2
moderator_st:		.blkb	500
moderator_st_len:	.blkl	1
notefile_numnotes:	.blkl	1
notefile_reply_only:	.blkl	1
notefile_restricted:	.blkl	1
notefile_writelock:	.blkl	1
notefile_create_time:	.blkl	2
server_max_item:	.blkl	1




show_1:		.ascid	/                       File = !AS/
show_2:		.ascid	/                      Title = !AS/
show_3:		.ascid	/                     Notice = !AS/
show_4:		.ascid	/                     Topics = !UL/
show_5:		.ascid	/                 Reply_Only = !AS/
show_6:		.ascid	/               Members Only = !AS/
show_7:		.ascid	/                Writelocked = !AS/
show_8:		.ascid	/                    Created = !%D/
show_9:		.ascid	/            Server_Max_Item = !UL/
show_11:	.ascid	/         Topics and Replies = !UL/
show_12:	.ascid	/                     Format = !UL/
show_14:	.ascid	/                   High_Uid = !XL/
show_15:	.ascid	/                    Updated = !%D/
show_16:	.ascid	/                  Moderator = !AD/
show_17:	.ascid	/Keyword Creation Restricted = !AS/
show_20:	.ascid	/          Unseen (estimate) = !UL/
show_21:	.ascid	/         Last update status = !AS/
show_18:	.ascid	/         Last Shadow Update = !%D/

last_status_st:	.long	100
		.long	last_status_st+8
		.blkb	100

yes:	.ascid	/Yes/
no:	.ascid	/No/



cld_mod:	.ascid	/MODERATORS/
cld_mem:	.ascid	/MEMBERS/

blank_nl:	.ascid	//
blank:		.ascid	/ /

user_create_keyword_st:	.ascid	/Create_Keywords/
write_bypass_st:	.ascid	/Write_Regardless/
user_moderate_st:	.ascid	/Moderate/
user_moderate_st_len = . - user_moderate_st



sl_user_moderate_st:	.ascid	+/Mod+
sl_user_moderate_st_len = . - sl_user_moderate_st

show_mod:	.ascid	/User "!AD", Mail "!AD"  Privs=(!AS !AS !AS)/
Show_mod1:	.ascid	/Access = !AS/

ctr_d1:	.ascid	/!UL.99999-!UL.0/

list_mem:	.Ascid	/ Listing Members of this conference/
list_mod:	.Ascid	/ Listing Members with Moderator privileges /

Valuelst:	.word	0
		.word	Fscn$_name
		.long	0
;
		.long	0

sym_1:	.ascid	/PAN$!AS_TITLE/
sym_2:	.ascid	/PAN$!AS_NOTICE/
sym_3:	.ascid	/PAN$!AS_FILE/
sym_4:	.ascid	/PAN$!AS_MODERATOR/
sym_5:	.ascid	/PAN$!AS_TOPICS/
sym_6:	.ascid	/PAN$!AS_UNSEEN_ESTIMATE/
sym_7:	.ascid	/PAN$!AS_WRITELOCKED/
sym_8:	.ascid	/PAN$!AS_MEMBERS_ONLY/
sym_9:	.ascid	/PAN$!AS_PANCOPY_TIMESTAMP/

sym_def:	.ascid	/(PAN$!AS_* DCL symbols created)/

next_uid:	.blkl	1

next_e:	.ascid	/!!!!!!!!! NEXT UID EXISTS !!!!!!!!!!!/



Sout:	.long	100
	.long	Sout+8
	.blkb	100

ctr_integer:	.ascid	/!UL/
ctr_string:	.ascid	/!AS/
ctr_date:	.ascid	/!%D/


DCLFLAG:        .LONG   LIB$K_CLI_GLOBAL_SYM  




none:	.ascid	/<None>/



ctr_stamp:	.ascid	/Peb !AS::!AD/
stamp:		.long	100
		.long	stamp+8
		.blkb	100




syi_item:	.word	50
		.word	syi$_NodeName
		.long	nodename+8
		.long	nodename
;
		.long	0


jpi_item:   	.word   8
        	.word   jpi$_procpriv
        	.long   priv
        	.long   0
;
		.word	20
		.word	jpi$_username
		.long	username
		.long	0
;
        	.long   0


username:	.blkb	20

nodename:	.long	50
		.long	nodename+8
		.blkb	50




stamp_in:	.word	4
		.word	notes$k_note_uid
		.long	uid_to_stamp
		.long	0
;
stamp_l:	.word	0
		.word	notes$k_note_user_area
		.long	Stamp+8
		.long	0
;
		.long	0

uid_to_stamp:	.blkl	1

ctr_stamped:	.ascid	/Note changed by !AD/

Rest_of_line:	.ascid	/REST_OF_LINE/

thank:		.ascid	/Thank you for using this software/

ctr_p3R:	.ascid	/Conference Pointer !AS/

show_mods_flag:	.blkl	1

using_notebook:	.blkl	1

range_v:	.long	100
		.long	range_v+8
		.blkb	100


a_title:	.ascid	/TITLE/
a_notice:	.ascid	/NOTICE/
a_mod:		.ascid	/MODERATOR/

set_mod_flag:	.blkl	1


	.entry	set_conf,0



	pushaq	a_mod
	calls	#1,g^cli$present
	blbc	r0,9$
	incl	set_mod_flag	
9$:	nop



	pushaq	op_msg
	calls	#1,g^lib$put_output




; get the conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  conf
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i

	movl	input,result_spec_len
	movc3	input, @input+4, result_spec

; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	300$
301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, result_spec_len
	movc3	Notefile_file_name_len,  Notefile_file_name, result_spec

	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

300$:	nop


	tstl	set_mod_flag	
	beql	1901$
	brw	1900$
1901$:	nop

        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error




	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




1900$:	nop



        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




; --------------------------------------------



	tstl	set_mod_flag
	bneq	399$
	brw	400$
399$:	nop

	pushal	dlm
	calls	#1,g^lib$put_output

	pushal	set_mod
	calls	#1,g^lib$put_output


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  a_mod
	calls   #3,g^cli$get_value 
	check	r0,error


; open the file for RMS access

	pushaq	o_msg
	calls	#1,g^lib$put_output


        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




	movb	descr,fab+fab$b_fns
	movl	descr+4,fab+fab$l_fna




	movb	default_note, fab+fab$b_dns
	movl	default_note+4, fab+fab$l_dna


	$open	fab=fab
	check	r0,error

	$connect	rab=rab
	check	r0,error


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


	$rab_store	rab=rab,rac=key,kbf=uid
	movl	#16, uid

	$get	rab=rab
	check	r0,error




	movab	buffer+77, R6





	movzbl	(R6), Type
	incl	R6
	movzbl	(R6), Length

	incl	r6

	cmpb	#conf_moderator , type
	bneq	150$
	brw	1000$
150$:	nop	




	addl2	Length, R6

; -------------------------------------------
	incl	R6

	movzbl	(R6), Type
	incl	R6
	movzbl	(R6), Length
	

	incl	R6


	cmpb	#conf_moderator , type
	bneq	160$
	brw	1000$
160$:	nop	





	addl2	Length, R6
; -------------------------------------------
	incl	R6

	movzbl	(R6), Type
	incl	R6
	movzbl	(R6), Length
	
	incl	r6

	cmpb	#conf_moderator , type
	bneq	170$
	brw	1000$
170$:	nop	


	pushaq	end_of_loop
	calls	#1,g^lib$put_output
	ret


	pushaq	san_fail
	calls	#1,g^lib$put_output
	ret




; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

1000$:	nop

; check 

	movl	length, descr
	movl	R6, Descr+4



	movl	#100,out
	$fao_s	ctrstr=old_mod,outbuf=out,outlen=out,-
		p1=#descr
	pushaq	out
	calls	#1,g^lib$put_output



	$FileScan_s	Srcstr=Descr,-
			Valuelst=Valuelst
	check	r0,error



	movl	#100,out
	pushal	out
	pushaq	old_ask
	pushaq	out
	calls	#3,g^lib$get_input
	check	r0,error

	pushaq	out
	pushaq	out
	calls	#2,g^str$upcase

	cmpb	#^a/Y/, Out+8
	beql	14000$
	$EXit_s
14000$:	nop

	pushaq	do_rep
	calls	#1,g^lib$put_output

	brw	250$

	cmpl	length, moderator_st_len
	beql	250$

	pushaq	Descr
	calls	#1,g^lib$put_output

	pushaq	san_fail
	calls	#1,g^lib$put_output
250$:	nop


	brw	260$

	cmpc3	length, moderator_st, (R6)
	beql	260$

	pushaq	Descr
	calls	#1,g^lib$put_output

	pushaq	san_fail
	calls	#1,g^lib$put_output
260$:	nop

; -----------------------------------------------------

; save

	addl3	length, R6, R7
	movc3	#3000,(R7), Save_1	

	decl	R6
	movb	Input, (R6)
	incl	R6
	movc3	input, input+8, (R6)

	addl3	input, R6, R7
	movc3	#3000, Save_1, (R7)

	movzwl	rab+rab$w_rsz, R3
	subl2	length, R3
	addl2	input, R3

	movw	R3, rab+rab$w_rsz
	movw	R3, rab+rab$w_usz


	$update	rab=rab
	check	r0,error

	$close	Fab=Fab
	check	r0,error
	
	$exit_s	code=#1

400$:	nop



; do TITLE ?


	pushaq	a_title
	calls	#1,g^cli$present
	blbs	r0,99$
	brw	100$
99$:	nop

	pushaq	dlm
	calls	#1,g^lib$put_output

	pushal	set_title
	calls	#1,g^lib$put_output

	tstl	get_mod
	beql	3000$

	pushaq	get_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

	clrl	get_mod

3000$:	nop


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  a_title
	calls   #3,g^cli$get_value 
	check	r0,error




	movw	input, nl_i
	movw	#notes$k_notefile_title, nl_i+2
	movl	input+4, nl_i+4

        pushaw  Null
        pushaw  Nl_I
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

100$:	nop


; --------------------------------------------------------

	pushaq	a_notice
	calls	#1,g^cli$present
	blbs	r0,199$
	brw	200$
199$:	nop


	pushaq	dlm
	calls	#1,g^lib$put_output

	pushal	set_notice
	calls	#1,g^lib$put_output




	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  a_notice
	calls   #3,g^cli$get_value 
	check	r0,error



	tstl	get_mod
	beql	4000$

	pushaq	get_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

	clrl	get_mod

4000$:	nop




	movw	input, nl_i
	movw	#notes$k_notefile_notice, nl_i+2
	movl	input+4, nl_i+4

        pushaw  Null
        pushaw  Nl_I
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

200$:	nop


	movl	#1, R0

	ret


end_of_loop:	.ascid	/ Unable to find "Last Moderator" field/


set_mod:	.ascid	/Setting Moderator field/
set_title:	.ascid	/Setting title field/
set_notice:	.ascid	/Setting notice field/



debug:		.ascid	/DEBUG_FILE/
ctr_debug:	.ascid	+(/DEBUG_FILE)  Creating Debug message file !AS +

by_user:	.ascid	/BY_USER/
by_user_flag:	.blkl	1

other_note_cont:	.blkl	1

ctr_by:	.ascid	/Mail from !AD/


find_top_o:	.word	4
		.word	notes$k_note_uid
		.long	find_top_uid
		.long	0
;
		.long	0

find_top_uid:	.blkl	1


find_top_i:	.word	0
		.word	notes$k_note_title
		.long	out+8
		.long	0
;
		.word	4
		.word	notes$k_nosignal
		.long	no_sig
		.long	0
;
		.word	a_note_id_i_len
		.word	notes$k_note_id
		.long	a_note_id_i
		.long	0
;
		.long	0


a_note_id_i:	.ascii	/999999-1/
a_note_id_i_len = . - a_note_id_i


cre_empty:	.ascid	/---------- Creating an empty base note ----------/





; create folder action routine

	.entry	action,^m<r2,r3,r4,r5,r6,r7,r8,r9>  


	pushaq	Created
	calls	#1,g^lib$put_output

	movl	8(ap),r6

	movw	(R6),Descr
	Movl	4(R6),Descr+4

;	pushaq	descr
;	calls	#1,g^lib$put_output
	put_de	descr


	nop
	nop

	movl	#1,r0
	ret





copy_out:	.word	4
		.word	mail$_message_folder_created
		.long	folder_created
		.long	0
;
		.long	0


folder_created:	.blkl	1
delete_msg:	.long	1


copy_in:	.word	4
		.word	mail$_message_delete
		.long	delete_msg
		.long	0
;
defl:		.word	0
		.word	Mail$_message_default_name
		.long	Mail_dir
		.long	0
;
Nfl:		.word	0
		.word	mail$_message_folder
		.long	newfolder_name
		.long	0
;
		.word	4
		.word	mail$_message_folder_action
		.long	action
		.long	0
;
		.word	4
		.word	mail$_message_id
		.long	id
		.long	0
;
		.long	0
		

newfolder_name:	.blkb	100

bell = 7

Created:        .Ascid  /Output folder CREATED /<Bell>

newfolder:	.ascid	/NEWFOLDER/


ctr_459:	.ascid	/!AS.0/


no_bas_fnd:	.ascid	/The required base note was not found/



	.entry	select_uid,0

; hack the UID ??


	tstl	uid_cld_flag
	bneq	999$
	brw	1000$
999$:	nop


;	pushaq	res_nx
;	calls	#1,g^lib$put_output
	put_de	res_nx



        pushaw  o_max
        pushaw  null
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error

;	movl	original_note_uid, next_uid


1700$:	nop

; get the conf header record


	movab	null, rab+rab$l_kbf
	movb	#0,rab+rab$b_krf


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	$rab_store	rab=rab,rac=Key

	$get	rab=rab
	check	r0,error


; --------------------------------------------------------------
; if we are doing /SINCE AND this is the setup for a base
; note THEN set it so that it creates the right topic
; number


	tstl	fast_wind
	bneq	18$
	brw	20$
18$:	nop

	tstl	topic_number
	bneq	19$
	brw	20$
19$:	nop

;	pushaq	ch_top
;	calls	#1,g^lib$put_output
	put_de	ch_top

	cmpl	note_numnotes,buffer+100
	beql	25$
	pushaq	san_fail
	calls	#1,g^lib$put_output
	ret
25$:	nop

	movl	topic_number, buffer+100	
	decl	buffer+100


; is this a new maximum note number ???


	cmpl	topic_number, max_note_number
	bleq	20$

	movl	#100,out
	$fao_s	ctrstr=ctr_max_top,outbuf=out,outlen=out,-
		p1=max_note_number
	put_de	out


	movl	topic_number, max_note_number
	incl	max_note_number

20$:	nop
; --------------------------------------------------------------

	cmpl	high_uid, buffer+92
	beql	1001$

	tstl	high_uid
	beql	1001$
	
	pushaq	no_eq
	calls	#1,g^lib$put_output

	ret

1001$:	nop

; change the next uid field




	movl	next_uid, buffer+92

;****	decw	buffer+92
	decl	buffer+92

	$update	rab=rab
	check	r0,error

; ----------------------------------------------------------

; make sure that 'next-uid' dont exist



	movab	next_uid, rab+rab$l_kbf
	movb	#0,rab+rab$b_krf


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	$rab_store	rab=rab,rac=Key

	$get	rab=rab
	cmpl	r0,#rms$_rnf
	beql	1600$
	

	pushaq	next_e
	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_uid,outbuf=out,outlen=out,-
		p1=buffer,-
		p2=buffer+74,-
		p3=buffer+72
	pushaq	out
	calls	#1,g^lib$put_output



	$Exit_s

1600$:	nop


; ------------------------------------------------------------

	brw	888$
	tstl	tmp_uid
	beql	888$

	$rab_store	rab=rab,rac=key

	movab	tmp_uid, rab+rab$l_kbf

	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz

	$get	rab=rab
	check	r0,error

	brw	1000$

888$:	nop


; ------------------------------------------------------------

	$rab_store	rab=rab,rac=Seq

	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz

	$get	rab=rab
	check	r0,error


1000$:	nop

	ret


topic_number:	.blkl	1
fast_wind:	.blkl	1

ch_top:	.ascid	/re-setting  the topic number /

max_note_number:	.blkl	1



	.entry	re_set_max,0

;	movl	#9999, max_note_number

	tstl	max_note_number
	bneq	15$
	ret
15$:	nop

	tstl	fast_wind
	bneq	1700$

	ret

1700$:	nop


        pushaw  o_max
        pushaw  null
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error






	put_de	do_re_mas




;	pushaq	re_max_msg
;	calls	#1,g^lib$put_output
	put_de	re_max_msg

; get the conf header record


	movab	null, rab+rab$l_kbf
	movb	#0,rab+rab$b_krf


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	$rab_store	rab=rab,rac=Key

	$get	rab=rab
	check	r0,error



	cmpl	note_numnotes,buffer+100
	beql	25$
	pushaq	san_fail
	calls	#1,g^lib$put_output
	ret
25$:	nop

	movl	max_note_number, buffer+100	


	$update	rab=rab
	check	r0,error



	ret

re_max_msg:	.ascid	/re set the number of topics/

base_note_uid:	.blkl	1

ch_msg:		.ascid	/.entry  change_base_note_replies,0/

	.entry	change_base_note_replies,0

	put_de	ch_msg

	tstl	reply_number
	bneq	5$
	ret
5$:	nop

	tstl	topic_number
	beql	10$

	ret

10$:	nop



	tstl	fast_wind
	bneq	1700$

	ret

1700$:	nop


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	movab	base_note_uid, rab+rab$l_kbf
	movb	#0,rab+rab$b_krf


	$rab_store	rab=rab,rac=Key

	$get	rab=rab
	check	r0,error




	movab	buffer, R6
	addl2	#76, R6

200$:	nop

	movb	(R6), type
	incl	r6
	movzbl	(R6), type_len



	cmpb	type,  #type_un1    
	bneq	888$
;	movl	#1, Type_Len	


	cmpb	#49, Type_Len
	bneq	888$

	incl	R6

	movzbl  (R6), type_len

888$:	nop


	movl	#100,out
	$fao_s	ctrstr=ctr_hhhhh,outbuf=out,outlen=out,-
		p1=type,-
		p2=type_len
;	pushaq	out
;	calls	#1,g^lib$put_output
	put_de	out


	tstb	type
	bneq	44$
	pushaq	bad_type
	calls	#1,g^lib$put_output
	ret
44$:	nop


	cmpb	type, #type_rep
	beql	250$


	addl2	type_len, r6

	incl	R6


	brw	200$

250$:	nop

	incl	R6



	movl	#100,out
	$fao_s	ctrstr=ctr_chhhhh,outbuf=out,outlen=out,-
		p1=reply_number,-
		p2=(R6)
	put_de	out


	cmpl	reply_number,(R6)
	bleq	443$
	brw	444$
443$:	nop

	put_de	no_way


	$update	rab=rab
	check	r0,error

	ret
444$:	nop


	


	movl	reply_number, (R6)
;	clrl	reply_number
	decl	(R6)


	$update	rab=rab
	check	r0,error

	ret



type_len:	.blkl	1
ctr_hhhhh:	.ascid	/type = !5UB,  Len = !UL/

reply_number:	.blkl	1

uid_ne:	.ascid	/****** created UID .NE. original UID ******/

ctr_sh:	.ascid	/max_note_number = !UL/

ctr_max_top:	.ascid	/New max topic number is !UL/	

do_re_mas:	.ascid	/doing re-set number of topics/

actr_p333:		.ascid	/Note !7AD !20AD !%D !4UL lines/

doing_unseen:		.blkl	1

master_entry_len:	.blkl	1
master_entry:		.blkb	300

shad_entry_len:		.blkl	1
shad_entry:		.blkb	300

set_map_se:	
.ascid	/save seen map for the master (and set 'forced' base notes to seen)/
you_may:	.ascid	/You may want to delete the DEBUG log file.../

ctr_title:	.ascid	/%PAN-I-TI,  Title = "!AS"/
ctr_notice:	.ascid	/%PAN-I-NO, Notice = "!AS"/

null_base:	
.ascid /           >>>>>>>>>>>>> forced base note text omited <<<<<<<<<<<<< /

force_base:	.blkl	1

test_create_flag:	.blkl	1

Shad_sym_name:		.ascid	/PAN$SHADOW_FILENAME/
shad_added:		.ascid	/PAN$SHADOW_ADDED_NOTES/
Shad_created:		.ascid	/PAN$SHADOW_FILE_CREATED/

True:			.ascid	/TRUE/


ctr_filn:	.ascid	/%PAN-I-CONF, Conference file is "!AS"/

sh_e_1:	.ascid	/Save seen map for the master/
sh_e_2:	.ascid	/Update shadow entry/
sh_e_3:	.ascid	/save the seen map for the master entry/


symbol:		.ascid	/SYMBOL/
symbol_v:	.long	100
		.long	symbol_v+8
		.blkb	100

Forced_text:		.ascid	/FORCED_TEXT/
Forced_text_flag:	.blkl	1
no_way:	.ascid	/'am  not going to set the reply number DOWN!/
ctr_chhhhh:	.ascid	/Reply number to set !UL, existing reply number !UL/

ctr_larep:	.ascid	/Last Reply_number !UL/
nul_auth:	.ascid	/no::author/

nreplace:	.ascid	/REPLACE/

	.entry	members,0


	pushaq	nreplace
	calls	#1,g^cli$present
	blbs	r0,129$

	clrl	nreplace

129$:	nop




	pushaq	dlm
	calls	#1,g^lib$put_output


; get the member name

	movl    #100,mail_li
	Pushaw  mail_li
	pushaq  mail_li
	pushaq 	cld_mem
	calls   #3,g^cli$get_value 
	check	r0,error	

	movw	mail_li, mod_i
	movab	mail_li+8, mod_i+4


	pushaq	op_msg_mast
	calls	#1,g^lib$put_output






; get the master conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Master
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i


; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	2300$
301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

2300$:	nop



	movw	#full_default_name_len, def_l
	movab	full_default_name, def_n


        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; try for mod status

	pushaq	try_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_modify


	MOVL    R0,VEC+4

        $PUTMSG_S       MSGVEC=VEC






; get note context...

	movab	mast_file_cont, notes_beg_i+4



        pushaw  null
        pushaw  notes_beg_i
        pushal  mast_note_cont
        calls   #3,G^Notes$User_begin
        check   r0,error                                                                       

; --------------------------------------------------------------

	pushaq	dlm
	calls	#1,g^lib$put_output


	pushaq	op_msg_shad
	calls	#1,g^lib$put_output





; get the shadow conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Shadow
	calls   #3,g^cli$get_value 
	check	r0,error



	movw	input,notes_open_i



; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,1301$			; skip if NOnotebook
	brw	1300$
1301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output


	tstl	notebook_file_cont
	bneq	300$

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

300$:	nop

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4


	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

1300$:	nop


	movw	#default_name_len, def_l
	movab	default_name, def_n

        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error


1123$:	nop





	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; enable mod priv !!

	pushaq	mod_en
	calls	#1,g^lib$put_output

        pushaw  open_o
        pushaw  open_m
        pushal  shad_file_cont
        calls   #3,G^Notes$notefile_modify
	check	r0,error



        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output






; get note context...

	movab	shad_file_cont, notes_beg_i+4



        pushaw  null
        pushaw  notes_beg_i
        pushal  shad_note_cont
        calls   #3,G^Notes$User_begin
        check   r0,error                                                                       


; ----------------------------------------------------------

	pushaq	dlm
	calls	#1,g^lib$put_output



mem_loop:	nop

	pushaq	blank
	calls	#1,g^lib$put_output


	pushaw	mod_o
	pushaw	mod_i
	pushal	mast_note_cont
	calls	#3,g^notes$user_get
	check	r0,error


; if we have an access list AND a node list.. then
; drop the node list


	movw	#notes$k_noop, m_a+2
	movw	#notes$k_user_nodename, k_aa+2

	tstl	user_nodename_len	; access list size
	beql	400$

	pushaq	discard
	calls	#1,g^lib$put_output

	clrl	k_user_nodename_len
	movw	#notes$k_user_access_list, m_a+2
	movw	#notes$k_noop, k_aa+2
400$:	nop


	movw	#4, mod_i
	movw	#notes$k_continue,mod_i+2




	incl	listed


	movab	Blank_nl, R6
	tstl	user_create_keyword
	beql	1001$
	movab	user_create_keyword_st, R6
1001$:	nop



	tstl	user_moderate
	bneq	555$
	tstl	user_create_keyword
	bneq	555$
	tstl	write_bypass
	bneq	555$
	movab	none, R6
555$:	nop




	movab	Blank_nl, R7
	tstl	write_bypass
	beql	1002$
	movab	write_bypass_st, R7
1002$:	nop

	movab	blank_nl, R8
	tstl	user_moderate
	beql	21003$
	movab	user_moderate_st, R8
21003$:	nop


	movl	#100,out
	$fao_s	ctrstr=show_mod,outbuf=out,outlen=out,-
		p1=user_name_len,-
		p2=#user_name,-
;
		p3=mail_addr_len,-
		p4=#mail_addr,-
;
		p5=R6,-
		p6=R7,-
		p7=R8
	pushaq	out
	calls	#1,g^lib$put_output




	movl	user_nodename_len, descr
	movab	user_nodename, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=show_mod1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


	movl	k_user_nodename_len , descr
	movab	k_user_nodename , descr+4

	movl	#100,out
	$fao_s	ctrstr=show_mod1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output














; set it !!

	movw	mail_addr_len, add_m
	movw	user_name_len, m_u
	movw	user_nodename_len, m_a
	movw	k_user_nodename_len, k_aa




	pushaw	null
	pushaw	add_m
	pushal	shad_note_cont
	calls	#3,g^notes$user_add
	blbs	r0,123$

	cmpl	r0, #notes$_Alrexists_u
	bneq	123$


	tstl	nreplace
	beql	123$


	pushaq	rep_u
	calls	#1,g^lib$put_output

	pushaw	null
	pushaw	add_m
	pushal	shad_note_cont
	calls	#3,g^notes$user_modify



123$:	nop

	brw	mem_loop


	ret


rep_u:	.ascid	/... Replacing Member .../

add_m:	.word	0
	.word	notes$k_user_mail_addr
	.long	mail_addr
	.long	0
;
m_u:	.word	0
	.word	notes$k_user_name
	.long	user_name
	.long	0
;
m_a:	.word	0
	.word	notes$k_user_access_list
	.long	user_nodename
	.long	0
;
	.word	4
	.word	notes$k_user_moderate
	.long	user_moderate
	.long	0
;
	.word	4
	.word	notes$k_noop	;notes$k_user_create_keyword
	.long	user_create_keyword
	.long	0
;
	.word	4
	.word	notes$k_noop	;notes$k_user_write_bypass
	.long	write_bypass
	.long	0
;
k_aa:	.word	0
	.word	notes$k_user_nodename
	.long	k_user_nodename
	.long	0
;
	.long	0

output:		.ascid	/OUTPUT/

brief:		.ascid	/BRIEF/
brief_flag:	.blkl	1


	.entry	Directory,0

;        Qualifier       Class , value(default="*"),default
;        parameter P1, prompt="What Entry ?", value(default="*"),label=Class


; brief ?

	pushaq	brief
	calls	#1,g^cli$present
	blbc	r0, 77$
	incl	brief_flag
77$:	nop


; output file

	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  output
	calls   #3,g^cli$get_value 
	check	r0,error	

	movb	input,Dfab+fab$b_fns
	movl	input+4,Dfab+fab$l_fna

	$create	fab=Dfab
	check	r0,error

	$connect	rab=Drab
	check	r0,error


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in



        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error



	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error



	pushaw	Null
	pushaw	class_i
	pushal	class_cont
	calls	#3,g^notes$class_begin
	check	r0,error





	Pushaw  Patt
	pushaq  Patt
	pushaq  Entry
	calls   #3,g^cli$get_value 
	check	r0,error	

	pad_star	patt

cl_loop_start:	nop


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Class
	calls   #3,g^cli$get_value 
	blbs	r0,5$
	brw	cl_loop_end
5$:	nop


	movw	input,get_class
	movw	#notes$k_class_name, get_class+2



cl_loop_1:	nop	

	pushaw	class_out
	pushaw	get_class
	pushal	class_cont	
	calls	#3,g^notes$class_get
	blbs	r0,10$

	MOVL    R0,VEC+4
        $PUTMSG_S       MSGVEC=VEC

	brw	cl_loop_start

10$:	nop



	movw	#notes$k_continue,get_class+2

	movl	#100,out
	$fao_s	ctrstr=ctr_class,outbuf=out,outlen=out,-
		p1=class_name_len,-
		p2=#class_name
	pushal	out
	calls	#1,g^lib$put_output



	tstl	brief_flag
	bneq	77$	

	movw	dir_head, Drab+rab$w_rsz
	movw	dir_head, Drab+rab$w_usz

	movab	dir_head+8, 	Drab+rab$l_Rbf
	movab	dir_head+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error

77$:	nop




cl_loop:	nop

	pushaw	cl_en_o
	pushaw	cl_en_i
	pushal	class_cont	
	calls	#3,g^notes$class_get_entry
	blbs	r0,10$
	brw	cl_loop_1
10$:	nop

	movl	entry_name_len, descr
	movab	entry_name, descr+4
;	pushaw	descr
;	calls	#1,g^lib$put_output

	pushaq	Patt
	pushaq	descr
	calls	#2,g^STR$MATCH_WILD  

	cmpl	R0,#STR$_MATCH
	beql	101$

	brw	cl_loop

101$:	nop


; get the entry

	movw	entry_name_len, ent_in
	movab	entry_name, ent_in+4


	clrl	UNseen_Est
	clrq	Notefile_lastrev
	clrl	number_of_notes


	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
;	check	r0,error


	movl	#100,out
	$fao_s	ctrstr=xctr_class,outbuf=out,outlen=out,-
		p1=entry_name_len,- 
		p2=#entry_name, -
		p3=unseen_est,-
		p4=#Notefile_lastrev,-
		p5=number_of_notes


	addl2	unseen_est,  total_unseen_est
	incl	listed

	tstl	brief_flag
	beql	77$

	movw	entry_name_len, Drab+rab$w_rsz
	movw	entry_name_len, Drab+rab$w_usz

	movab	entry_name, Drab+rab$l_Rbf
	movab	entry_name, Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error

	brw	cl_loop


77$:	nop

	movw	out, Drab+rab$w_rsz
	movw	out, Drab+rab$w_usz

	movab	out+8, 	Drab+rab$l_Rbf
	movab	out+8, 	Drab+rab$l_Ubf

	$put	rab=Drab
	check	r0,error


	brw	cl_loop





cl_loop_end:	nop




	movl	#100,out
	$fao_s	ctrstr=ctr_class_10,outbuf=out,outlen=out,-
		p1=Listed,-
		p2=total_unseen_est
	pushaq	out
	calls	#1,g^lib$put_output




	ret

cl_en_i:	.word	4
		.word	notes$k_continue
		.long	no_sig
		.long	0
;
		.long	0

cl_en_o:	.word	100
		.word	notes$k_entry_name
		.long	entry_name
		.long	entry_name_len
;
		.long	0



class_out:	.word	100
		.word	notes$k_class_name
		.long	class_name
		.long	class_name_len
;
		.long	0

class_name:	.blkb	100
class_name_len:	.blkl	1

get_class:	.word	0
		.word	notes$k_class_name
		.long	input+8
		.long	0
;
		.long	0


class_i:	.word	4
		.word	notes$k_notefile_context
		.long	notebook_file_cont
		.long	0
;
		.long	0


class:		.ascid	/CLASS/


class_cont:	.blkl	1


entry:	.ascid	/ENTRY/
patt:	.long	100
	.long	patt+8
	.blkb	100





name:		.ascid	/NAME/
user_area:	.ascid	/USER_AREA/
filename:	.ascid	/FILENAME/

before:		.ascid	/BEFORE/

	.entry	Entry_add  ,0


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in

; open notebook

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error



	pushaw	Null
	pushaw	book_in
	pushal	class_cont
	calls	#3,g^notes$class_begin
	check	r0,error


	pushaw	Null
	pushaw	book_in
	pushal	profile_cont
	calls	#3,g^notes$profile_begin
	check	r0,error

; get the uses default class (in case no class given)



	pushaw	profile_out
	pushaw	null
	pushal	profile_cont
	calls	#3,g^notes$profile_get
	check	r0,error

	movw	#notes$k_class_name, e_cn+2
	movw	Class_in, e_cn	

; entry name




	Pushaw  Entry_in
	pushaq  Entry_in
	pushaq  Entry
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	Entry_in, entry_in_list
	movl	entry_in+4, entry_in_list+4


; if there is a filename then skip this !

	pushaq	filename
	calls	#1,g^cli$present
	blbc	r0,123$
	brw	124$
123$:	nop

	movw	Entry_in, entry_in_list

        movzwl  Entry_in, FileName_in
	movc3	FileName_in, Entry_in+8, FileName_in+8



	movw	#notes$k_notefile_file_name, E_fn+2
	movw	FileName_in, E_fn



; get out the filename

	$FileScan_s	Srcstr=Entry_in,-
			Valuelst=Valuelst
	check	r0,error

	movzwl	ValueLst, entry_in
	movc3	entry_in, @ValueLst+4, Entry_in+8





	movw	Entry_in, entry_in_list

124$:	nop



; name ?


	pushaq	Name
	calls	#1,g^cli$present
	blbc	r0,20$

	movl	#100, Entry_in
	Pushaw  Entry_in
	pushaq  Entry_in
	pushaq  Name
	calls   #3,g^cli$get_value 
	check	r0,error	


	movw	Entry_in, entry_in_list

20$:	nop





	pushaq	User_area
	calls	#1,g^cli$present
	blbc	r0,30$

	Pushaw  User_area_in
	pushaq  User_area_in
	pushaq  User_Area
	calls   #3,g^cli$get_value 
	check	r0,error	

	movw	#notes$k_entry_user_area, e_ua+2
	movw	User_area_in, e_ua

30$:	nop



	pushaq	filename
	calls	#1,g^cli$present
	blbc	r0,40$

	movl	#100, FileName_in
	Pushaw  FileName_in
	pushaq  FileName_in
	pushaq  FileName
	calls   #3,g^cli$get_value 
	check	r0,error	


	movw	#notes$k_notefile_file_name, E_fn+2
	movw	FileName_in, E_fn

40$:	nop




	pushaq	Before
	calls	#1,g^cli$present
	blbc	r0,50$

	movl	#100,out
	Pushaw  Out
	pushaq  Out
	pushaq  Before
	calls   #3,g^cli$get_value 
	check	r0,error	


	$bintim_s	timbuf=Out,-
			timadr=quad
	check	r0,error


	movw	#notes$k_note_before_time, e_bt+2
	movw	#8, e_bt


50$:	nop




	pushaq	Since
	calls	#1,g^cli$present
	blbc	r0,60$

	movl	#100,out
	Pushaw  Out
	pushaq  Out
	pushaq  Since
	calls   #3,g^cli$get_value 
	check	r0,error	


	$bintim_s	timbuf=Out,-
			timadr=quad
	check	r0,error


	movw	#notes$k_note_Since_time, e_st+2
	movw	#8, e_st

60$:	nop





; class ?



	pushaq	class
	calls	#1,g^cli$present
	blbs	r0,8$
	brw	10$
8$:	nop

	movc3	Class_in, Class_in+8, save_2


	movl	#100, Class_in
	Pushaw  Class_in
	pushaq  Class_in
	pushaq  Class
	calls   #3,g^cli$get_value 
	blbs	r0,888$
	brw	tell_us
888$:	nop

; no NULL class !

	tstl	Class_in
	bneq	99$

	movw	e_cn, Class_in
	movc3	Class_in, save_2, Class_in+8

	pushaq	no_null
	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=no_null1,outbuf=out,outlen=out,-	
		p1=#Class_in
	pushaq	out
	calls	#1,g^lib$put_output

99$:	nop

	movw	#notes$k_class_name, e_cn+2
	movw	Class_in, e_cn	


; verify the class 

	movw	Class_in, get_class
	movw	#notes$k_class_name, get_class+2
	movl	class_in+4, get_class+4


	pushal	null
	pushal	get_class
	pushal	class_cont
	calls	#3,g^notes$class_get
	blbs	r0,10$

	cmpl	r0,#NOTES$_NO_SUCH_CLASS
	beql	9$
	$exit_s	code=r0
9$:	nop

	pushal	null
	pushal	get_class
	pushal	class_cont
	calls	#3,g^notes$class_add
	check	r0,error


10$:	nop





; add the entry


	pushaw  ent_out			; entry_out_list
	pushaw	entry_in_list
	pushal	notebook_cont
	calls	#3,g^notes$entry_add
	check	r0,error

	clrl	E_fn

	brw	8$

tell_us:	nop
; find what class it is in


	movw	entry_name_len, ent_in
	movab	entry_name, ent_in+4


	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error	

10$:	pushaw	class_out
	pushaw	null
        pushal  notebook_cont
	calls	#3,g^notes$entry_get_class
	blbs	r0,20$
	cmpl	r0,#NOTES$_NO_MORE_CLASSES
	bneq	30$
	movl	#1,r0
30$:	ret
20$:	nop

	movw	#notes$k_continue, null+2

	movl	#100,out
	$fao_s	ctrstr=ctr_class_1,outbuf=out,outlen=out,-
		p1=entry_name_len,-
		p2=#Entry_Name,-
		p3=class_name_len,-
		p4=#class_name
	pushal	out
	calls	#1,g^lib$put_output

	clrl	entry_name_len

	brw	10$




	movl	#100,out
	$fao_s	ctrstr=ctr_map_d1,outbuf=out,outlen=out,-
		p1=seen_map_len,-
		p2=seen_map,-
		p3=seen_map+4,-
		p4=seen_map+8,-
		p5=seen_map+12,-
		p6=seen_map+16
;	pushal	out
;	calls	#1,g^lib$put_output




	ret

	.entry	Entry_delete  ,0




	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


; open notebook

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error



; entry name




	Pushaw  Entry_in
	pushaq  Entry_in
	pushaq  Entry
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	Entry_in, entry_in_list


; class ?

	pad_star	entry_in_list

	pushaq	class
	calls	#1,g^cli$present
	blbc	r0,10$

	Pushaw  Class_in
	pushaq  Class_in
	pushaq  Class
	calls   #3,g^cli$get_value 
	check	r0,error	

	movw	#notes$k_class_name, e_cn+2
	movw	Class_in, e_cn	

	tstw	Class_in
	bneq	10$

	pushaq	wrong_1
	calls	#1,g^lib$put_output
	pushaq	wrong_2
	calls	#1,g^lib$put_output

	$exit_s	code=#1


10$:	nop



	pushaw  ent_out			; entry_out_list
	pushaw	entry_in_list
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error



; find what class it is in



	pushaw	class_out
	pushaw	null
        pushal  notebook_cont
	calls	#3,g^notes$entry_get_class
	check	r0,error




	movl	#100,out
	$fao_s	ctrstr=ctr_class_2,outbuf=out,outlen=out,-
		p1=entry_name_len,-
		p2=#entry_name,-
;
		p3=class_name_len,-
		p4=#class_name
	pushaq	out
	calls	#1,g^lib$put_output

	movw	entry_name_len, entry_in_list
	movab	entry_name, entry_in_list+4

	pushaq	Dlm
	calls	#1,g^lib$put_output


	pushaw  null		; entry_out_list
	pushaw	entry_in_list
	pushal	notebook_cont
	calls	#3,g^notes$entry_delete
	check	r0,error






	ret

	.entry	Entry_modify  ,0

	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in



; open notebook

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error



; entry name




	Pushaw  Entry_in
	pushaq  Entry_in
	pushaq  Entry
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	Entry_in, entry_in_list



; name ?


	pushaq	Name
	calls	#1,g^cli$present
	blbc	r0,20$

	Pushaw  new_Entry_in
	pushaq  new_Entry_in
	pushaq  Name
	calls   #3,g^cli$get_value 
	check	r0,error	



	movw	new_Entry_in, e_nm
	movw	#NOTES$K_ENTRY_NEW_NAME   , e_nm+2
	movab	new_Entry_in+8,  e_nm+4

20$:	nop





	pushaq	User_area
	calls	#1,g^cli$present
	blbc	r0,30$

	Pushaw  User_area_in
	pushaq  User_area_in
	pushaq  User_Area
	calls   #3,g^cli$get_value 
	check	r0,error	


	movw	#notes$k_entry_user_area, e_ua+2
	movw	User_area_in, e_ua

30$:	nop



	pushaq	filename
	calls	#1,g^cli$present
	blbc	r0,40$

	Pushaw  FileName_in
	pushaq  FileName_in
	pushaq  FileName
	calls   #3,g^cli$get_value 
	check	r0,error	


	movw	#notes$k_notefile_file_name, E_fn+2
	movw	FileName_in, E_fn

40$:	nop




	pushaq	Before
	calls	#1,g^cli$present
	blbc	r0,50$

	movl	#100,out
	Pushaw  Out
	pushaq  Out
	pushaq  Before
	calls   #3,g^cli$get_value 
	check	r0,error	


	$bintim_s	timbuf=Out,-
			timadr=quad
	check	r0,error


	movw	#notes$k_note_before_time, e_bt+2
	movw	#8, e_bt



50$:	nop




	pushaq	Since
	calls	#1,g^cli$present
	blbc	r0,60$

	movl	#100,out
	Pushaw  Out
	pushaq  Out
	pushaq  Since
	calls   #3,g^cli$get_value 
	check	r0,error	


	$bintim_s	timbuf=Out,-
			timadr=quad
	check	r0,error


	movw	#notes$k_note_Since_time, e_st+2
	movw	#8, e_st



60$:	nop


; add the entry

	pushaq	Dlm
	calls	#1,g^lib$put_output

	pushaw  ent_out			; entry_out_list
	pushaw	entry_in_list
	pushal	notebook_cont
	calls	#3,g^notes$entry_modify
	check	r0,error

; find what class it is in


	pushaq	Dlm
	calls	#1,g^lib$put_output

	movw	entry_name_len, ent_in
	movab	entry_name, ent_in+4


	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error	


	pushaq	Dlm
	calls	#1,g^lib$put_output

	pushaw	class_out
	pushaw	null
        pushal  notebook_cont
	calls	#3,g^notes$entry_get_class
	check	r0,error


	pushaq	Dlm
	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_class_3,outbuf=out,outlen=out,-
		p1=#entry_in,-
		p2=class_name_len,-
		p3=#class_name
	pushal	out
	calls	#1,g^lib$put_output







	ret

	.entry	Entry_show  ,0


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


; open notebook

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error



; entry name




	Pushaw  Entry_in
	pushaq  Entry_in
	pushaq  Entry
	calls   #3,g^cli$get_value 
	check	r0,error

	movw	Entry_in, entry_in_list


; class ?

	pad_star	entry_in_list

	pushaq	class
	calls	#1,g^cli$present
	blbc	r0,10$

	Pushaw  Class_in
	pushaq  Class_in
	pushaq  Class
	calls   #3,g^cli$get_value 
	check	r0,error	

	movw	#notes$k_class_name, e_cn+2
	movw	Class_in, e_cn	




10$:	nop



	pushaw  ent_out			; entry_out_list
	pushaw	entry_in_list
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movw	#notes$k_continue,entry_in_list+2

; find what class it is in



	pushaw	class_out
	pushaw	null
        pushal  notebook_cont
	calls	#3,g^notes$entry_get_class
	check	r0,error



	movl	#100,out
	$fao_s	ctrstr=ctr_sh_et1,outbuf=out,outlen=out,-
		p1=unseen_est,-
		p2=entry_name_len,-
		p3=#entry_name,-
		p4=number_of_notes
	pushaq	out
	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_sh_et2,outbuf=out,outlen=out,-
		p1=entrytotal,-
		p2=title_len,-
		p3=#Title
	pushaq	out
	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_sh_et3,outbuf=out,outlen=out,-
		p1=Notefile_file_name_len,-
		p2=#Notefile_file_name,-
		p3=class_name_len,-
		p4=#class_name
	pushaq	out
	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_sh_et4,outbuf=out,outlen=out,-
		p1=notice_len,-
		p2=#Notice
	pushaq	out
	calls	#1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_sh_et5,outbuf=out,outlen=out,-
		p1=moderator_st_len,-
		p2=#moderator_st,-
		p3=note_user_area_len,-
		p4=#note_user_area
	pushaq	out
	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_sh_et6,outbuf=out,outlen=out,-
		p1=seen_map_len,-
		p2=seen_map,-		
		p3=seen_map+4,-		
		p4=seen_map+8,-		
		p5=seen_map+12,-		
		p6=seen_map+16
;	pushaq	out
;	calls	#1,g^lib$put_output

	pushaq	Dlm
	calls	#1,g^lib$put_output


	brw	10$


	ret




entry_in_list:	.word	0
		.word	notes$k_entry_name
		.long	entry_in+8
		.long	0
;
e_cn:		.word	0
		.word	notes$k_noop
		.long	Class_in+8
		.long	0
;
E_fn:		.word	0
		.word	notes$k_noop
		.long	FileName_in+8
		.long	0
;
e_ua:		.word	0
		.word	notes$k_noop
		.long	User_area_in+8
		.long	0
;
e_bt:		.word	0
		.word	notes$k_noop
		.long	quad
		.long	0
;
e_st:		.word	0
		.word	notes$k_noop
		.long	quad
		.long	0
;
e_nm:           .word   0
                .word   notes$k_noop
                .long   0
                .long   0		
;
		.long	0




Entry_in:	.long	100
		.long	entry_in+8
		.blkb	100	


new_Entry_in:	.long	100
		.long	new_entry_in+8
		.blkb	100	

Class_in:	.long	100
		.long	class_in+8
		.blkb	100

User_area_in:	.long	100
		.long	User_area_in+8
		.blkb	100

filename_in:	.long	100
		.long	filename_in+8
		.blkb	100

ctr_class_1:	.ascid	/%PAN-I-ENTRADDED, Entry !AD added to class !AD/
ctr_class_2:	.ascid	/Deleting Entry !AD from class !AD/
ctr_class_3:	.ascid	/Entry !AS (class !AD) modified/


ctr_map_d1:	.ascid	/Seen_map (!UL Bytes) = !XL !XL !XL !XL !XL/


ctr_sh_et1:	.ascid	/!34<!UL unseen note!%S!>  !29<Entry !AF!> !UL topic notes/
ctr_sh_et2:	.ascid	/!UL total notes  "!AF"/
ctr_sh_et3:	.ascid	/!63< File:  !AF!>  In class: !AF/
ctr_sh_et4:	.ascid	/               -< !AF >- /
ctr_sh_et5:	.ascid	/ Moderator:  !AF          User_Data = -< !AF >-/
ctr_sh_et6:	.ascid	/Seen Map (!UL Bytes) !XL !XL !XL !XL !XL/

source_title_len:	.blkl	1
source_title:		.blkb	100


single_flag:	.blkl	1
single:		.ascid	/SINGLE/

xctr_class:	.ascid	/ !20AD !4UL  !%D  !4UL/
ctr_class:	
.ascid	/                        Directory of Notebook class !AD/


dir_head:	
.ascid	/ Entry Name          Unseen  Last new note           Topics  /

total_unseen_est:	.blkl	1
ctr_class_10:	.ascid	/!UL Entrys listed.....    !UL Unseen notes/

all:	.ascid	/ALL/

	.entry	entry_update, 0


	pushaq	all
	calls	#1,g^cli$present
	blbc	r0,8$
	clrl	all
8$:	nop



	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error



	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error



	pushaw  null
	pushaw	book_in
	pushal	other_notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error



	pushaw	Null
	pushaw	class_i
	pushal	class_cont
	calls	#3,g^notes$class_begin
	check	r0,error





	Pushaw  Patt
	pushaq  Patt
	pushaq  Entry
	calls   #3,g^cli$get_value 
	check	r0,error	

	pushaq	patt
	pushaq	patt
        calls   #2,g^str$upcase

Ucl_loop_start:	nop


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Class
	calls   #3,g^cli$get_value 
	blbs	r0,5$
	brw	cl_loop_end
5$:	nop




; ***************************************

	movw	Input, cl_na
	movw	#notes$k_class_name, cl_na+2
	movl	input+4, cl_na+4

	movw	patt, mod_up_i
	movl	patt+4, mod_up_i+4

	movw	#notes$k_entry_name, mod_up_i+2


10$:	nop

	clrl	UNseen_Est
	clrq	Notefile_lastrev
	clrl	number_of_notes

	pad_star mod_up_i


	movw	#notes$k_noop, ppdb

	pushaw	ent_out
	pushaw	mod_up_i
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	blbs	r0,325$
	pushaq	dlm
	calls	#1,g^lib$put_output
	brw	Ucl_loop_start
325$:	nop

	movw	#notes$k_continue, mod_up_i+2





	tstl	all
	beql	7711$

	tstl	unseen_est
	beql	7711$


	movw	entry_name_len, descr
	movab	entry_name, descr+4
	movl	#100,out
	$fao_s	ctrstr=ctr_skt,outbuf=out,outlen=out,-
		p1=#Descr,-
		p2=Unseen_Est
	pushaq	out
	calls	#1,g^lib$put_output




	brw	10$

7711$:	nop

	movw	#notes$k_notefile_default_name, cl_xy

	movw	entry_name_len, ent_in
	movab	entry_name, ent_in+4

	
	pushaw	ent_out
	pushaw	ent_in
	pushal	other_notebook_cont
	calls	#3,g^notes$entry_update
	blbs	r0,25$
	pushaq	dlm
	calls	#1,g^lib$put_output
	brw	Ucl_loop_start
25$:	nop


	movl	#100,out
	$fao_s	ctrstr=ctr_un_est,outbuf=out,outlen=out,-
		p1=unseen_est
	pushaq	out
	calls	#1,g^lib$put_output


	addl2	unseen_est,  total_unseen_est
	incl	listed



	brw	10$


	brw	Ucl_loop_start
; ***************************************





	movw	input,get_class
	movw	#notes$k_class_name, get_class+2



Ucl_loop_1:	nop	

	pushaw	class_out
	pushaw	get_class
	pushal	class_cont	
	calls	#3,g^notes$class_get
	blbs	r0,10$

	MOVL    R0,VEC+4
        $PUTMSG_S       MSGVEC=VEC

	brw	Ucl_loop_start

10$:	nop



	movw	#notes$k_continue,get_class+2

	movl	#100,out
	$fao_s	ctrstr=ctr_class,outbuf=out,outlen=out,-
		p1=class_name_len,-
		p2=#class_name
	pushal	out
	calls	#1,g^lib$put_output






Ucl_loop:	nop

	pushaw	cl_en_o
	pushaw	cl_en_i
	pushal	class_cont	
	calls	#3,g^notes$class_get_entry
	blbs	r0,10$
	brw	Ucl_loop_1
10$:	nop

	movl	entry_name_len, descr
	movab	entry_name, descr+4


	pushaq	descr
	pushaq	descr
        calls   #2,g^str$upcase


;	pushaw	descr
;	calls	#1,g^lib$put_output




	pushaq	Patt
	pushaq	descr
	calls	#2,g^STR$MATCH_WILD  

	cmpl	R0,#STR$_MATCH
	beql	101$

	brw	Ucl_loop

101$:	nop


; get the entry

	movw	entry_name_len, ent_in
	movab	entry_name, ent_in+4


	movw	entry_name_len, mod_up_i
	movab	entry_name, mod_up_i+4


	clrl	UNseen_Est
	clrq	Notefile_lastrev
	clrl	number_of_notes



	pushaw	null
	pushaw	mod_up_i
	pushal	notebook_cont
	calls	#3,g^notes$entry_update

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
;	check	r0,error


	movl	#100,out
	$fao_s	ctrstr=xctr_class,outbuf=out,outlen=out,-
		p1=entry_name_len,- 
		p2=#entry_name, -
		p3=unseen_est,-
		p4=#Notefile_lastrev,-
		p5=number_of_notes
	pushaq	out
	calls	#1,g^lib$put_output


	addl2	unseen_est,  total_unseen_est
	incl	listed



	brw	Ucl_loop





Ucl_loop_end:	nop




	movl	#100,out
	$fao_s	ctrstr=ctr_class_10,outbuf=out,outlen=out,-
		p1=Listed,-
		p2=total_unseen_est
	pushaq	out
	calls	#1,g^lib$put_output

	ret



	.entry	add_members, 0



	pushaq	a_mod
	calls	#1,g^cli$present
	blbc	r0,4$
	incl	user_moderate
4$:	nop

; get the master conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Master
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i


; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	2300$
301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

2300$:	nop



	movw	#full_default_name_len, def_l
	movab	full_default_name, def_n


        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; try for mod status

	pushaq	try_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_modify


	MOVL    R0,VEC+4

        $PUTMSG_S       MSGVEC=VEC






; get note context...

	movab	mast_file_cont, notes_beg_i+4



        pushaw  null
        pushaw  notes_beg_i
        pushal  mast_note_cont
        calls   #3,G^Notes$User_begin
        check   r0,error                                                                       


; get the member name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  cld_mem
	calls   #3,g^cli$get_value 
	check	r0,error	


	movw	input         , m_u
	movab	input         +8, m_u+4



	movw	#notes$k_noop, m_a+2
	
	pushaq	access
	calls	#1,g^cli$present
	blbc	r0,10$

	movl    #100,acc_li
	Pushaw  acc_li
	pushaq  acc_li
	pushaq  access
	calls   #3,g^cli$get_value 
	check	r0,error	



	movw	acc_li,  m_a
	movab	acc_li+8, m_a+4

	movw	#notes$k_user_access_list, m_a+2

10$:	nop


	movw	#notes$k_noop,add_m+2

	pushaq	mail_adr
	calls	#1,g^cli$present
	blbc	r0,20$

	movl    #100,mail_li
	Pushaw  mail_li
	pushaq  mail_li
	pushaq 	mail_adr
	calls   #3,g^cli$get_value 
	check	r0,error	

	pushaq	mail_li
	calls	#1,g^lib$put_output


	movw	mail_li, add_m
	movab	mail_li+8, add_m+4

	movw	#notes$k_user_mail_addr,add_m+2
20$:	nop















	pushaw	null
	pushaw	add_m
	pushal	mast_note_cont
	calls	#3,g^notes$user_add
	check	r0,error

	movl	#100,out
	$fao_s	ctrstr=ctr_mem_add,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

	ret

ctr_mem_add:	.ascid	/Member !AS added/

access:		.ascid	/ACCESS/
acc_li:		.long	100
		.long	acc_li+8
		.blkb	100

mail_adr:	.ascid	/MAIL_ADR/
mail_li:	.long	100
		.long	mail_li+8
		.blkb	100




	.entry	add_access,0




; get the master conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  Master
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i


; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	2300$
301$:	nop


	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in

	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

2300$:	nop



	movw	#full_default_name_len, def_l
	movab	full_default_name, def_n


        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


; try for mod status

	pushaq	try_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  mast_file_cont
        calls   #3,G^Notes$notefile_modify


	MOVL    R0,VEC+4

        $PUTMSG_S       MSGVEC=VEC






; get note context...

	movab	mast_file_cont, notes_beg_i+4



        pushaw  null
        pushaw  notes_beg_i
        pushal  mast_note_cont
        calls   #3,G^Notes$User_begin
        check   r0,error                                                                       


; get the member name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  cld_mem
	calls   #3,g^cli$get_value 
	check	r0,error	


	movw	input         , mod_i
	movab	input         +8, mod_i+4


; get current access


	pushaw	mod_o
	pushaw	mod_i
	pushal	mast_note_cont
	calls	#3,g^notes$user_get
	check	r0,error


	movl	user_nodename_len, descr
	movab	user_nodename, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=show_mod_old,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



; get new access


	movl    #100,acc_li
	Pushaw  acc_li
	pushaq  acc_li
	pushaq  access
	calls   #3,g^cli$get_value 
	check	r0,error	

; append it

	movab	user_nodename, R6
	addl2	user_nodename_len, R6
	incl	R6
	movb	#^a/,/, (R6)
	incl	R6

	movc3	acc_li, acc_li+8, (R6)

	addl3	user_nodename_len, acc_li, user_nodename_len
	addl2	#2, user_nodename_len

	movw	user_nodename_len, new_ac





	movl	user_nodename_len, descr
	movab	user_nodename, descr+4
;	pushaq	descr
;	calls	#1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=show_mod_new,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movw	input         , mod_mem
	movab	input         +8, mod_mem+4

	pushaw	null	
	pushaw	mod_mem
	pushal	mast_note_cont
	calls	#3,g^notes$user_modify
	check	r0,error



	ret


mod_mem:	.word	1
		.word	notes$k_user_name
		.long	mod_name
		.long	0
;
new_ac:		.word	0
		.word	notes$k_user_access_list
		.long	user_nodename
		.long	0
;
		.long	0



show_mod_old:	.ascid	/OLd Access list = "!AS"/
show_mod_new:	.ascid	/New Access list = "!AS"/


	.entry	null_routine,0
	ret


dev_1:	.ascid	/Peter E. Bailey (VANISH::BAILEY)/
dev_2:	.ascid	/Andy Leslie     (LESLIE::LESLIE)/

	.entry	show_dev,0

	pushaq	dev_1
	calls	#1,g^lib$put_output


	pushaq	dev_2
	calls	#1,g^lib$put_output

	ret

ctr_ver:	.ascid	/This is PAN version !AS/

pan_ver:	.ascid	/PAN$VERSION/

	.entry	show_ver,0


	movl	#100,out
	$fao_s	ctrstr=ctr_ver,outbuf=out,outlen=out,-
		p1=#version
	pushaq	out
	calls	#1,g^lib$put_output


        PUSHAL  DCLFLAG                
        PUSHAQ  version
        PUSHAQ  pan_ver
        CALLS   #3,G^LIB$SET_SYMBOL    

	calls	#0,link_date

	ret

no_qual:	.ascid	/You must specify a Qualifier to SET NOTE/

	.entry	null_note,0
	pushaq	no_qual
	calls	#1,g^lib$put_output
	ret


hid_yes:	.ascid	/Yes..  Hide/
hid_no:		.ascid	/UN Hide/

hid_flag:	.blkl	1


	.entry	set_write,0
	pushaq	write_yes
        calls   #1,g^lib$put_output
	
	movl	#1, write_flag

	calls	#0, delete
	ret
write_yes:	.ascid	/Set notes Writable/
write_no:	.ascid	/Set notes NOT  Writable/

write_flag:	.blkl	1

	.entry	set_NOwrite,0
	pushaq	write_no
        calls   #1,g^lib$put_output
	
	movl	#2, write_flag

	calls	#0, delete
	ret



	.entry	set_hid,0
	pushaq	hid_yes
	calls	#1,g^lib$put_output

	movl	#1,hid_flag

	calls	#0,delete
	ret


	.entry	clr_hid,0
	pushaq	hid_no
	calls	#1,g^lib$put_output

	movl	#2,hid_flag

	calls	#0,delete
	ret









output_flag:	.blkl	1


Continued:	.ascid	/- !Record Continued /
Continued_len = . - Continued

slash_mail:	.ascid	+/Mail = +
slash_mail_len = . - slash_mail

mail_flag:	.blkl	1
mail:		.ascid	/MAIL/

wr_mod4:	.ascid	/!35AD  !! Mail for member "!AD" of "!AD"/

wr_mod2:	.ascid	+/Access=("!AD")+
wr_mod1:	.ascid	+/Node=("!AD") !AS+


slash:		.ascid	+/+



ctr_out_f:	.ascid	/Output file is !AS/

del_mem:	.ascid	/... Deleting Member ... /


enote_com:	.ascid	/.../

command_line::	.long	1000
		.long	command_line+8
		.blkb	1000


old_mod:	.ascid	/Replace old moderator "!AS" /
old_ask:	.ascid	/Yes or No [NO] ? /

default_note:	.ascid	/NOTES$LIBRARY:.NOTE/



do_rep:		
.ascid	/>>>>>>>>>>>>>>>>>>>>>>>>> Replacing Moderator <<<<<<<<<<<<<<<<<<<<<<</

mem_header:	
.ascid	/Member           Access               Mail Address                   Privileges/

ctr_shm:	.ascid	/!17AD!20AS !31AD!AS/
ctr_skt:	.ascid	/NOT updating entry !AS as it has !UL Unseen notes/
other_notebook_cont:	.blkl	1

	.entry	set_note_date,0

	pushaq	op_msg
	calls	#1,g^lib$put_output




; get the conf name


	movl    #100,input         
	Pushaw  Input
	pushaq  Input
	pushaq  conf
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	input,notes_open_i



; should we treat this as being a notebook entry ?

	pushaq	notebook
	calls	#1,g^Cli$Present
	blbs	r0,301$			; skip if NOnotebook
	brw	300$
301$:	nop

	movl    #100,notebook_spec      
	Pushaw  notebook_spec
	pushaq  notebook_spec
	pushaq  notebook
	calls   #3,g^cli$get_value 
	check	r0,error
	movw	notebook_spec, notebook_in


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent,outbuf=out,outlen=out,-
		p1=#Input
	pushaq	out
	calls	#1,g^lib$put_output

; open notebook (if its not open already!)

        pushaw  null
        pushaw  notebook_in
        pushal  notebook_file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error

; begin

	pushaw  null
	pushaw	book_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_begin
	check	r0,error

; get the entry

	movw	input, ent_in
	movl	input+4, ent_in+4

	pad_star	ent_in

	pushaw	ent_out
	pushaw	ent_in
	pushal	notebook_cont
	calls	#3,g^notes$entry_get
	check	r0,error


	movl	Notefile_file_name_len, descr
	movab	Notefile_file_name, descr+4


	movl	#100,out
	$Fao_s	ctrstr=ctr_ent1,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output

	movl	Descr, Input
	movc3	Input, @Descr+4, Input+8

	movw	input,notes_open_i

300$:	nop



        pushaw  notes_open_o
        pushaw  notes_open_i
        pushal  file_cont
        calls   #3,G^Notes$notefile_begin
        check   r0,error



	pushaq	try_mod
	calls	#1,g^lib$put_output



        pushaw  open_o
        pushaw  open_m
        pushal  file_cont
        calls   #3,G^Notes$notefile_modify


	MOVL    R0,VEC+4

        $PUTMSG_S       MSGVEC=VEC





        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movl	title_len,Descr
	movab	title,Descr+4
;	pushaq	Descr
;	calls	#1,g^lib$put_output

	movl	#100,out
	$fao_s	ctrstr=ctr_title,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output


        movl    notice_len,Descr
        movab   notice,descr+4
;       pushaq  descr
;       calls   #1,g^lib$put_output


	movl	#100,out
	$fao_s	ctrstr=ctr_notice,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output



	movab	file_cont, notes_beg_i+4



        pushaw  notes_beg_o
        pushaw  notes_beg_i
        pushal  note_cont
        calls   #3,G^Notes$note_begin
        check   r0,error                                                                       



        movl    result_spec_len,Descr
        movab   result_spec,descr+4
;        pushaq  descr
;        calls   #1,g^lib$put_output



	movl	#100,out
	$fao_s	ctrstr=ctr_filn,outbuf=out,outlen=out,-
		p1=#Descr
	pushaq	out
	calls	#1,g^lib$put_output




	movb	descr,fab+fab$b_fns
	movl	descr+4,fab+fab$l_fna


	pushaq	o_msg
	calls	#1,g^lib$put_output

	$open	fab=fab
	check	r0,error

	$connect	rab=rab
	check	r0,error



	movl    #100,out
	Pushaw  out
	pushaq  out
	pushaq  range
	calls   #3,g^cli$get_value 
	check	r0,error


	movw	#notes$k_noop, mm1

	movw	out, disp_i
	movl	out+4, disp_i+4



        pushaw  add_add_o
        pushaw  disp_i
        pushal  note_cont
        calls   #3,g^notes$note_get
	check	r0,error


	movl	#100,out
	$fao_s	ctrstr=ctr_p1,outbuf=out,outlen=out,-
		p1=note_id_len,-
		p2=#note_id,-
		p3=ret_note_author_len,-
		p4=#ret_note_author,-
		p5=ret_note_title_len,-
		p6=#ret_note_title,-
		p7=number_of_lines
	pushaq	out
	calls	#1,g^lib$put_output



	movl    #100,out
	Pushaw  out
	pushaq  out
	pushaq  since
	calls   #3,g^cli$get_value 
	check	r0,error

; convert to binary


	$bintim_s	timbuf=Out,-
			timadr=notefile_user_area
	check	r0,error			




	movab	uid, rab+rab$l_kbf
	movb	#0,rab+rab$b_krf


	movw	#10000,rab+rab$w_rsz
	movw	#10000,rab+rab$w_usz


	$rab_store	rab=rab,rac=Key

	$get	rab=rab
	check	r0,error





	

; sanity check....


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Author


; ret_note_author
; ret_note_author_len




; hack the author field....

	movzbl	buffer+77,descr
	movab	buffer+78,descr+4



; date
; ret_note_time

	addl3	descr,descr+4,R6

	addl2	#2,R6


	movq	(R6),Quad




	cmpl	quad, ret_note_time
	tst

	cmpl	quad+4, ret_note_time+4
	tst


	
	movq	notefile_user_area, (R6)

	movl	#100,out
	$fao_s	ctrstr=xctr1,outbuf=out,outlen=out,-
		p1=#Quad
;	pushaq	out
;	calls	#1,g^lib$put_output






	$update	rab=rab
	check	r0,error


	ret

ctr_apd:	.ascid	/!AD !AD/


profile_cont:	.blkl	1



profile_out:	.word	100
		.word	notes$k_profile_class_name
		.long	class_in+8
		.long	Class_in
;
		.long	0


no_null:	.ascid	/%PAN-I-NOCLASS, no class specified/
no_null1:	.ascid	/%PAN-I-DEFCLSUSD, your default class of !AS will be used/


wrong_1:	.ascid	/%PAN-F-NOSUCHCLASS, no such class/
wrong_2:	.ascid	/%PAN-F-ILLGALCLASS, illegal class specification, please specify existing class/

wr_mod:		.ascid	+!25AD !! !30</Name="!AD"!>  !9<!AS!AS!> {!AS} +
wr_mod_of:	.ascid	+!28AD !! !25<"!AD"!> !4AS {!AS} +

rep_fl:	.blkl	1


com_dlm1:	.ascid	+!!-- Members of conference "!AS"+
com_dlm:	.ascid	+!-- Membership/Mail List produced by PAN ... Everything after the } is a COMMENT!+
ft_1:		.ascid	/!-- (if the mail address is blank (or "") then the access given/
ft_2:		.ascid	/!--  will be appended to the existing access for the named member)/

discard:	.ascid	/Discarding V1 node access list/


fail_over:	
.ascid	<bell>+%PAN-W-FAILO, Failing over to /NOCOPY mode+<bell>



ESC	=	27

REV_OFF:	.ASCID	<ESC>/[0m/


rev_on:		.ASCID  <ESC>/[0;7m /

due_to:	.ascid	/Due to bad update status NO create done/

ctr_uid:	.ascid	/UID !XL is note !UW.!UW/
ctr_uidd:	.ascid	/Wanted UID !XL .. but got UID !XL/

	.end	start


