\chapter{Topic overviews}\label{overviews}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

This chapter contains a selection of topic overviews.

\section{Window styles}\label{windowstyles}

Window styles are used to specify alternative behaviour and appearances for windows, when they are
created. The symbols are defined in such as way that they can be combined in a `bit-list' using the
C++ {\it bitwise-or} operator. For example:

\begin{verbatim}
  wxCAPTION | wxMINIMIZE_BOX | wxMINIMIZE_BOX | wxTHICK_FRAME
\end{verbatim}

\subsection{wxFrame styles}

The following styles apply to wxFrame windows.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxICONIZE}}{Display the frame iconized (minimized) (Windows only).}
\twocolitem{\indexit{wxCAPTION}}{Puts a caption on the frame (Windows and XView only).}
\twocolitem{\indexit{wxDEFAULT\_FRAME}}{Defined as wxMINIMIZE\_BOX \pipe wxMAXIMIZE\_BOX \pipe wxTHICK\_FRAME \pipe wxSYSTEM\_MENU \pipe wxCAPTION.}
\twocolitem{\indexit{wxMDI\_CHILD}}{Specifies a Windows MDI (multiple document interface) child frame.}
\twocolitem{\indexit{wxMDI\_PARENT}}{Specifies a Windows MDI (multiple document interface) parent frame.}
\twocolitem{\indexit{wxMINIMIZE}}{Identical to {\bf wxICONIZE}.}
\twocolitem{\indexit{wxMINIMIZE\_BOX}}{Displays a minimize box on the frame (Windows and Motif only).}
\twocolitem{\indexit{wxMAXIMIZE}}{Displays the frame maximized (Windows only).}
\twocolitem{\indexit{wxMAXIMIZE\_BOX}}{Displays a maximize box on the frame (Windows and Motif only).}
\twocolitem{\indexit{wxSDI}}{Specifies a normal SDI (single document interface) frame.}
\twocolitem{\indexit{wxSTAY\_ON\_TOP}}{Stay on top of other windows (Windows only).}
\twocolitem{\indexit{wxSYSTEM\_MENU}}{Displays a system menu (Windows and Motif only).}
\twocolitem{\indexit{wxTHICK\_FRAME}}{Displays a thick frame around the window (Windows and Motif only).}
\twocolitem{\indexit{wxRESIZE\_BORDER}}{Displays a resizeable border around the window (Motif only).}
\twocolitem{\indexit{wxTINY\_CAPTION\_HORIZ}}{Under Windows 3.1, displays a small horizontal caption if USE\_ITSY\_BITSY is
set to 1 in wx\_setup.h and the Microsoft ItsyBitsy library has been compiled. Use instead of
wxCAPTION.}
\twocolitem{\indexit{wxTINY\_CAPTION\_VERT}}{Under Windows 3.1, displays a small vertical caption if USE\_ITSY\_BITSY is
set to 1 in wx\_setup.h and the Microsoft ItsyBitsy library has been compiled. Use instead of
wxCAPTION.}
\end{twocollist}

\subsection{wxDialogBox styles}

The following styles apply to wxDialogBox windows.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxCAPTION}}{Puts a caption on the dialog box (Motif only).}
\twocolitem{\indexit{wxDEFAULT\_DIALOG\_STYLE}}{Equivalent to wxCAPTION \pipe wxSYSTEM\_MENU \pipe wxTHICK\_FRAME}
\twocolitem{\indexit{wxRESIZE\_BORDER}}{Display a resizeable frame around the window (Motif only).}
\twocolitem{\indexit{wxSYSTEM\_MENU}}{Display a system menu (Motif only).}
\twocolitem{\indexit{wxTHICK\_FRAME}}{Display a thick frame around the window (Motif only).}
\twocolitem{\indexit{wxUSER\_COLOURS}}{Under Windows, overrides standard control
processing to allow setting of the dialog box background colour.}
\twocolitem{\indexit{wxVSCROLL}}{Give the dialog box a vertical scrollbar (XView only).}
\end{twocollist}

\subsection{wxItem styles}

The following styles apply to all \helpref{wxItem}{wxitem} derived windows.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxHORIZONTAL\_LABEL}}{The item will be created with a horizontal label.}
\twocolitem{\indexit{wxVERTICAL\_LABEL}}{The item will be created with a vertical label.}
\twocolitem{\indexit{wxFIXED\_LENGTH}}{\index{aligning items}Allows the values of a column of items to be left-aligned. Create an item with this
style, and pad out your labels with spaces to the same length. The item labels will initially created
with a string of identical characters, positioning all the values at the same x-position. Then the
real label is restored.}
\end{twocollist}

\subsection{wxButton styles}

There are no styles specific to \helpref{wxButton}{wxbutton}.

\subsection{wxComboBox}

The following styles apply to \helpref{wxComboBox}{wxcombobox} items.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxCB\_SIMPLE}}{Creates a combobox with a permanently displayed list.}
\twocolitem{\indexit{wxCB\_DROPDOWN}}{Creates a combobox with a drop-down list.}
\twocolitem{\indexit{wxCB\_READONLY}}{Creates a combo box consisting of a drop-down list and static text item
displaying the current selection.}
\twocolitem{\indexit{wxCB\_SORT}}{Sorts the entries in the list alphabetically (Windows only).}
\end{twocollist}

\subsection{wxGauge styles}

The following styles apply to \helpref{wxGauge}{wxgauge} items.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxGA\_HORIZONTAL}}{The item will be created as a horizontal gauge.}
\twocolitem{\indexit{wxGA\_VERTICAL}}{The item will be created as a vertical gauge.}
\twocolitem{\indexit{wxGA\_PROGRESSBAR}}{Under Windows 95, the item will be created as a horizontal progress bar.}
\end{twocollist}

\subsection{wxGroupBox styles}

There are no styles specific to \helpref{wxGroupBox}{wxgroupbox}.

\subsection{wxListBox styles}

The following styles apply to \helpref{wxListBox}{wxlistbox} items.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxNEEDED\_SB}}{Create scrollbars if needed.}
\twocolitem{\indexit{wxLB\_NEEDED\_SB}}{Same as wxNEEDED\_SB.}
\twocolitem{\indexit{wxALWAYS\_SB}}{Create scrollbars immediately.}
\twocolitem{\indexit{wxLB\_ALWAYS\_SB}}{Same as wxALWAYS\_LB.}
\twocolitem{\indexit{wxLB\_SINGLE}}{Single-selection list.}
\twocolitem{\indexit{wxLB\_MULTIPLE}}{Multiple-selection list.}
\twocolitem{\indexit{wxLB\_EXTENDED}}{Extended-selection list (Motif only).}
\twocolitem{\indexit{wxHSCROLL}}{Create horizontal scrollbar if contents are too wide (Windows only).}
\end{twocollist}

\subsection{wxMessage styles}

There are no styles specific to \helpref{wxMessage}{wxmessage}.

\subsection{wxRadioBox}

The following styles apply to \helpref{wxRadioBox}{wxradiobox} items.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxVERTICAL}}{Lays the radiobox out in columns.}
\twocolitem{\indexit{wxHORIZONTAL}}{Lays the radiobox out in rows.}
\end{twocollist}

\subsection{wxRadioButton}

The following styles apply to \helpref{wxRadioButton}{wxradiobutton} items.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxRB\_GROUP}}{Specifies the start or end of a group of radio buttons under MS Windows.}
\end{twocollist}

\subsection{wxSlider styles}

The following styles apply to \helpref{wxSlider}{wxslider} items.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxHORIZONTAL}}{The item will be created as a horizontal slider.}
\twocolitem{\indexit{wxVERTICAL}}{The item will be created as a vertical slider.}
\end{twocollist}

\subsection{wxText/wxMultiText styles}

The following styles apply to \helpref{wxText}{wxtext} and \helpref{wxMultiText}{wxmultitext} items.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxTE\_PROCESS\_ENTER}}{The callback function will
receive the event wxEVENT\_TYPE\_TEXT\_ENTER\_COMMAND. Note
that this will break tab traversal for this panel item under
Windows. Single-line text only.}
\twocolitem{\indexit{wxTE\_PASSWORD}}{The text will be echoed as asterisks. Single-line text only.}
\twocolitem{\indexit{wxTE\_READONLY}}{The text will not be user-editable.}
\twocolitem{\indexit{wxHSCROLL}}{A horizontal scrollbar will be displayed.
If wxHSCROLL is omitted, only a vertical
scrollbar is displayed, and lines will be wrapped. This parameter
is ignored under XView. Multi-line text only.}
\end{twocollist}

\subsection{wxTextWindow styles}

The following styles apply to \helpref{wxTextWindow}{wxtextwindow} objects.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxBORDER}}{Use this style to draw a thin border in Windows 3 (non-native
implementation only).}
\twocolitem{\indexit{wxNATIVE\_IMPL}}{Use this style to allow editing under Windows 3.1, albeit
with a 64K limitation.}
\twocolitem{\indexit{wxREADONLY}}{Use this style to disable editing.}
\twocolitem{\indexit{wxHSCROLL}}{Use this style to enable a horizontal scrollbar, or leave it out to allow
line wrapping. Windows and Motif only.}
\end{twocollist}

\subsection{wxPanel styles}

The following styles apply to \helpref{wxPanel}{wxpanel} windows.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxBORDER}}{Draws a thin border around the panel.}
\twocolitem{\indexit{wxUSER\_COLOURS}}{Under Windows, overrides standard control
processing to allow setting of the panel background colour.}
\twocolitem{\indexit{wxVSCROLL}}{Gives the dialog box a vertical scrollbar (XView only).}
\end{twocollist}

\subsection{wxCanvas styles}

The following styles apply to \helpref{wxCanvas}{wxcanvas} windows.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxBORDER}}{Gives the canvas a thin border (Windows 3 and Motif only).}
%\twocolitem{\indexit{wxBACKINGSTORE}}{Gives the canvas an X-implemented backing store
%(XView and Motif only). The X server may choose to ignore this request, whereas
%wxRETAINED is always implemented under X.}
\twocolitem{\indexit{wxRETAINED}}{Gives the canvas a wxWindows-implemented backing store, making
repainting much faster but at a potentially costly memory premium (XView and Motif only).}
\end{twocollist}

\subsection{wxToolBar styles}

The following styles apply to \helpref{wxToolBar}{wxtoolbar} objects.

\begin{twocollist}\itemsep=0pt
\twocolitem{\indexit{wxTB\_3DBUTTONS}}{Gives a 3D look to the buttons, but not to the same
extent as wxButtonBar.}
\end{twocollist}

\section{Run time class information overview}\label{runtimeclassoverview}

Classes: \helpref{wxObject}{wxobject}, \helpref{wxClassInfo}{wxclassinfo}.

One of the failings of C++ is that no run-time information is provided
about a class and its position in the inheritance hierarchy.
Another is that instances of a class cannot be created just by knowing the name of a class,
which makes facilities such as persistent storage hard to implement.

Most C++ GUI frameworks overcome these limitations by means of a set of
macros and functions and wxWindows (from version 1.62) is no exception.
Each class that you wish to be known the type system should have
a macro such as DECLARE\_DYNAMIC\_CLASS just inside the class declaration.
The macro IMPLEMENT\_DYNAMIC\_CLASS should be in the implementation file.

Variations on these \helpref{macros}{macros} are used for multiple inheritance, and abstract
classes that cannot be instantiated dynamically or otherwise.

DECLARE\_DYNAMIC\_CLASS inserts a static wxClassInfo declaration into the
class, initialized by IMPLEMENT\_DYNAMIC\_CLASS. When initialized, the
wxClassInfo object inserts itself into a linked list (accessed through
wxClassInfo::first and wxClassInfo::next pointers). The linked list
is fully created by the time all global initialisation is done.

IMPLEMENT\_DYNAMIC\_CLASS is a macro that not only initialises the static
wxClassInfo member, but defines a global function capable of creating a
dynamic object of the class in question. A pointer to this function is
stored in wxClassInfo, and is used when an object should be created
dynamically.

wxObject::IsKindOf uses the linked list of wxClassInfo. It takes
a wxClassInfo argument, so use CLASSINFO(className) to return an
appropriate wxClassInfo pointer to use in this function.

The function \helpref{wxCreateDynamicObject}{wxcreatedynamicobject} can be used
to construct a new object of a given type, by supplying a string name.
If you have a pointer to the wxClassInfo object instead, then you
can simply call wxClassInfo::CreateObject.

\subsection{wxClassInfo}\label{wxclassinfooverview}

\overview{Run time class information overview}{runtimeclassoverview}

Class: \helpref{wxClassInfo}{wxclassinfo}

This class stores meta-information about classes. An application
may use macros such as DECLARE\_DYNAMIC\_CLASS and IMPLEMENT\_DYNAMIC\_CLASS
to record run-time information about a class, including:

\begin{itemize}\itemsep=0pt
\item its position in the inheritance hierarchy;
\item the base class name(s) (up to two base classes are permitted);
\item a string representation of the class name;
\item a function that can be called to construct an instance of this class.
\end{itemize}

The DECLARE\_... macros declare a static wxClassInfo variable in a class, which is initialized
by macros of the form IMPLEMENT\_... in the implementation C++ file. Classes whose instances may be
constructed dynamically are given a global constructor function which returns a new object.

You can get the wxClassInfo for a class by using the CLASSINFO macro, e.g. CLASSINFO(wxFrame).
You can get the wxClassInfo for an object using wxObject::GetClassInfo.

See also \helpref{wxObject}{wxobject} and \helpref{wxCreateDynamicObject}{wxcreatedynamicobject}.

\subsection{Example}

In a header file wx\_frame.h:

\begin{verbatim}
class wxFrame: public wxWindow
{
  DECLARE_DYNAMIC_CLASS(wxFrame)

 private:
  char *frameTitle;
 public:
  ...
};
\end{verbatim}

In a C++ file wx\_frame.cc:

\begin{verbatim}
IMPLEMENT_DYNAMIC_CLASS(wxFrame, wxWindow)

wxFrame::wxFrame(void)
{
...
}
\end{verbatim}


\section{Document/view overview}\label{docviewoverview}

Classes: \helpref{wxDocument}{wxdocument}, \helpref{wxView}{wxview}, \helpref{wxDocTemplate}{wxdoctemplate},\rtfsp
\helpref{wxDocManager}{wxdocmanager}, \helpref{wxDocParentFrame}{wxdocparentframe}, \helpref{wxDocChildFrame}{wxdocchildframe},
\rtfsp\helpref{wxCommand}{wxcommand}, \helpref{wxCommandProcessor}{wxcommandprocessor}

The document/view framework is found in most application frameworks, because it
can dramatically simplify the code required to build many kinds of application.

The idea is that you can model your application primarily in terms of {\it documents} to store data
and provide interface-independent operations upon it, and {\it views} to visualise and manipulate
the data. Documents know how to do input and output given stream objects, and views are responsible
for taking input from physical windows and performing the manipulation on the document data.
If a document's data changes, all views should be updated to reflect the change.

The framework can provide many user-interface elements based on this model. Once you have defined
your own classes and the relationships between them, the framework takes care
of popping up file selectors, opening and closing files, asking the user to save
modifications, routing menu commands to appropriate (possibly default) code, even
some default print/preview functionality and support for command undo/redo.
The framework is highly modular, allowing overriding and replacement of functionality
and objects to achieve more than the default behaviour.

These are the overall steps involved in creating an application based on the document/view framework:

\begin{enumerate}\itemsep=0pt
\item Define your own document and view classes, overriding a minimal set of
member functions e.g. for input/output, drawing and initialization.
\item Define any subwindows
(such as a canvas) that are needed for the view(s). You may need to route some events
to views or documents, for example OnPaint needs to be routed to wxView::OnDraw.
\item Decide what style of interface you will use: Microsoft's MDI (multiple
document child frames surrounded by an overall frame), SDI (a separate, unconstrained frame
for each document), or single-window (one document open at a time, as in Windows Write).
\item Use the appropriate wxDocParentFrame and wxDocChildFrame classes. Construct an instance
of wxDocParentFrame in your wxApp::OnInit, and a wxDocChildFrame (if not single-window) when
you initialize a view. Create menus using standard menu ids (such as wxID\_OPEN, wxID\_PRINT),
routing non-application-specific identifiers to the base frame's OnMenuCommand.
\item Construct a single wxDocManager instance at the beginning of your wxApp::OnInit, and then
as many wxDocTemplate instances as necessary to define relationships between documents and
views. For a simple application, there will be just one wxDocTemplate.
\end{enumerate}

If you wish to implement Undo/Redo, you need to derive your own class(es) from wxCommand
and use wxCommandProcessor::Submit instead of directly executing code. The framework will
take care of calling Undo and Do functions as appropriate, so long as the wxID\_UNDO and
wxID\_REDO menu items are defined in the view menu.

Here are a few examples of the tailoring you can do to go beyond the default framework
behaviour:

\begin{itemize}\itemsep=0pt
\item Override wxDocument::OnCreateCommandProcessor to define a different Do/Undo strategy,
or a command history editor.
\item Override wxView::OnCreatePrintout to create an instance of a derived \helpref{wxPrintout}{wxprintout}\rtfsp
class, to provide multi-page document facilities.
\item Override wxDocManager::SelectDocumentPath to provide a different file selector.
\item Limit the maximum number of open documents and the maximum number of undo commands.
\end{itemize}

Note that to activate framework functionality, you need to use some or all of
the wxWindows \helpref{predefined command identifiers}{predefinedids} in your menus.

\subsection{wxDocument overview}\label{wxdocumentoverview}

\overview{Document/view framework overview}{docviewoverview}

Class: \helpref{wxDocument}{wxdocument}

The wxDocument class can be used to model an application's file-based
data. It is part of the document/view framework supported by wxWindows,
and cooperates with the \helpref{wxView}{wxview}, \helpref{wxDocTemplate}{wxdoctemplate}\rtfsp
and \helpref{wxDocManager}{wxdocmanager} classes.

Using this framework can save a lot of routine user-interface programming,
since a range of menu commands -- such as open, save, save as -- are supported automatically.
The programmer just needs to define a minimal set of classes and member functions
for the framework to call when necessary. Data, and the means to view and edit
the data, are explicitly separated out in this model, and the concept of multiple {\it views} onto
the same data is supported.

Note that the document/view model will suit many but not all styles of application.
For example, it would be overkill for a simple file conversion utility, where there
may be no call for {\it views} on {\it documents} or the ability to open, edit and save
files. But probably the majority of applications are document-based.

See the example application in {\tt samples/docview}.

To use the abstract wxDocument class, you need to derive a new class and override
at least the member functions SaveObject and LoadObject. SaveObject and
LoadObject will be called by the framework when the document needs to be saved
or loaded.

Use the macros DECLARE\_DYNAMIC\_CLASS and IMPLEMENT\_DYNAMIC\_CLASS in order
to allow the framework to create document objects on demand. When you create
a \helpref{wxDocTemplate}{wxdoctemplate} object on application initialization, you
should pass CLASSINFO(YourDocumentClass) to the wxDocTemplate constructor
so that it knows how to create an instance of this class.

If you do not wish to use the wxWindows method of creating document
objects dynamically, you must override wxDocTemplate::CreateDocument
to return an instance of the appropriate class.

\subsection{wxView overview}\label{wxviewoverview}

\overview{Document/view framework overview}{docviewoverview}

Class: \helpref{wxView}{wxview}

The wxView class can be used to model the viewing and editing component of
an application's file-based data. It is part of the document/view framework supported by wxWindows,
and cooperates with the \helpref{wxDocument}{wxdocument}, \helpref{wxDocTemplate}{wxdoctemplate}
and \helpref{wxDocManager}{wxdocmanager} classes.

See the example application in {\tt samples/docview}.

To use the abstract wxView class, you need to derive a new class and override
at least the member functions OnCreate, OnDraw, OnUpdate and OnClose. You'll probably
want to override OnMenuCommand to respond to menu commands from the frame containing the
view.

Use the macros DECLARE\_DYNAMIC\_CLASS and IMPLEMENT\_DYNAMIC\_CLASS in order
to allow the framework to create view objects on demand. When you create
a \helpref{wxDocTemplate}{wxdoctemplate} object on application initialization, you
should pass CLASSINFO(YourViewClass) to the wxDocTemplate constructor
so that it knows how to create an instance of this class.

If you do not wish to use the wxWindows method of creating view
objects dynamically, you must override wxDocTemplate::CreateView
to return an instance of the appropriate class.

\subsection{wxDocTemplate overview}\label{wxdoctemplateoverview}

\overview{Document/view framework overview}{docviewoverview}

Class: \helpref{wxDocTemplate}{wxdoctemplate}

The wxDocTemplate class is used to model the relationship between a
document class and a view class. The application creates a document
template object for each document/view pair. The list of document
templates managed by the wxDocManager instance is used to create
documents and views. Each document template knows what file filters
and default extension are appropriate for a document/view combination,
and how to create a document or view.

For example, you might write a small doodling application that can load
and save lists of line segments. If you had two views of the data -- graphical,
and a list of the segments -- then you would create one document class DoodleDocument,
and two view classes (DoodleGraphicView and DoodleListView). You would also
need two document templates, one for the graphical view and another for the
list view. You would pass the same document class and default file extension to both
document templates, but each would be passed a different view class. When
the user clicks on the Open menu item, the file selector is displayed
with a list of possible file filters -- one for each wxDocTemplate. Selecting
the filter selects the wxDocTemplate, and when
a file is selected, that template will be used for creating a document
and view. Under non-Windows platforms, the user will be prompted for
a list of templates before the file selector is shown, since most file selectors
do not allow a choice of file filters.

For the case where an application has one document type and one view type,
a single document template is constructed, and dialogs will be appropriately
simplified.

wxDocTemplate is part of the document/view framework supported by wxWindows,
and cooperates with the \helpref{wxView}{wxview}, \helpref{wxDocument}{wxdocument}
and \helpref{wxDocManager}{wxdocmanager} classes.

See the example application in {\tt samples/docview}.

To use the wxDocTemplate class, you do not need to derive a new class.
Just pass relevant information to the constructor including CLASSINFO(YourDocumentClass) and
CLASSINFO(YourViewClass) to allow dynamic instance creation.
If you do not wish to use the wxWindows method of creating document
objects dynamically, you must override wxDocTemplate::CreateDocument
and wxDocTemplate::CreateView to return instances of the appropriate class.

{\it NOTE}: the document template has nothing to do with the C++ template construct. C++
templates are not used anywhere in wxWindows.

\subsection{wxDocManager overview}\label{wxdocmanageroverview}

\overview{Document/view framework overview}{docviewoverview}

Class: \helpref{wxDocManager}{wxdocmanager}

The wxDocManager class is part of the document/view framework supported by wxWindows,
and cooperates with the \helpref{wxView}{wxview}, \helpref{wxDocument}{wxdocument}\rtfsp
and \helpref{wxDocTemplate}{wxdoctemplate} classes.

A wxDocManager instance coordinates documents, views and document templates. It keeps a list of document and
and template instances, and much functionality is routed through this object, such
as providing selection and file dialogs. The application can use this class `as is' or
derive a class and override some members to extend or change the functionality.
Create an instance of this class near the beginning of your application initialization,
before any documents, views or templates are manipulated.

There may be multiple wxDocManager instances in an application.

See the example application in {\tt samples/docview}.

\subsection{wxCommand overview}\label{wxcommandoverview}

\overview{Document/view framework overview}{docviewoverview}

Classes: \helpref{wxCommand}{wxcommand}, \helpref{wxCommandProcessor}{wxcommandprocessor}

wxCommand is a base class for modelling an application command,
which is an action usually performed by selecting a menu item, pressing
a toolbar button or any other means provided by the application to
change the data or view.

Instead of the application functionality being scattered around
switch statements and functions in a way that may be hard to
read and maintain, the functionality for a command is explicitly represented
as an object which can be manipulated by a framework or application.
When a user interface event occurs, the application {\it submits} a command
to a \helpref{wxCommandProcessor}{wxcommandprocessoroverview} object to execute and
store.

The wxWindows document/view framework handles Undo and Redo by use of
wxCommand and wxCommandProcessor objects. You might find further uses
for wxCommand, such as implementing a macro facility that stores, loads
and replays commands.

An application can derive a new class for every command, or, more likely, use
one class parameterized with an integer or string command identifier.

\subsection{wxCommandProcessor overview}\label{wxcommandprocessoroverview}

\overview{Document/view framework overview}{docviewoverview}

Classes: \helpref{wxCommandProcessor}{wxcommandprocessor}, \helpref{wxCommand}{wxcommand}

wxCommandProcessor is a class that maintains a history of wxCommand
instances, with undo/redo functionality built-in. Derive a new class from this
if you want different behaviour.

\subsection{wxFileHistory overview}\label{wxfilehistoryoverview}

\overview{Document/view framework overview}{docviewoverview}

Classes: \helpref{wxFileHistory}{wxfilehistory}, \helpref{wxDocManager}{wxdocmanager}

wxFileHistory encapsulates functionality to record the last few files visited, and
to allow the user to quickly load these files using the list appended to the File menu.

Although wxFileHistory is used by wxDocManager, it can be used independently. You may wish
to derive from it to allow different behaviour, such as popping up a scrolling
list of files.

By calling wxFileHistory::FileHistoryUseMenu you can associate a file menu with
the file history, that will be used for appending the filenames. They are
appended using menu identifiers in the range wxID\_FILE1 to wxID\_FILE9.

In order to respond to a file load command from one of these identifiers,
you need to handle them in your wxFrame::OnMenuCommand. Below is the
code used by the default document/view parent frame.

\begin{verbatim}
void wxDocParentFrame::OnMenuCommand(int id)
{
  switch (id)
  {
    case wxID_EXIT:
    {
      if (GetEventHandler()->OnClose())
        delete this;
      break;
    }
    case wxID_FILE1:
    case wxID_FILE2:
    case wxID_FILE3:
    case wxID_FILE4:
    case wxID_FILE5:
    case wxID_FILE6:
    case wxID_FILE7:
    case wxID_FILE8:
    case wxID_FILE9:
    {
      char *f = docManager->GetHistoryFile(id-wxID_FILE1);
      if (f)
        (void)docManager->CreateDocument(f, wxDOC_SILENT);
      break;
    }
    default:
    {
      docManager->OnMenuCommand(id);
    }
  }
}
\end{verbatim}

\subsection{wxWindows predefined command identifiers}\label{predefinedids}

To allow communication between the application's menus and the
document/view framework, several command identifiers are predefined for you
to use in menus. The framework recognizes them and processes them if you
forward commands from wxFrame::OnMenuCommand (or perhaps from toolbars and
other user interface constructs).

\begin{itemize}\itemsep=0pt
\item wxID\_OPEN (5000)
\item wxID\_CLOSE (5001)
\item wxID\_NEW (5002)
\item wxID\_SAVE (5003)
\item wxID\_SAVEAS (5004)
\item wxID\_REVERT (5005)
\item wxID\_EXIT (5006)
\item wxID\_UNDO (5007)
\item wxID\_REDO (5008)
\item wxID\_HELP (5009)
\item wxID\_PRINT (5010)
\item wxID\_PRINT\_SETUP (5011)
\item wxID\_PREVIEW (5012)
\end{itemize}

\section{Printing overview}\label{printingoverview}

Classes: \helpref{wxPrintout}{wxprintout}, \helpref{wxPrinter}{wxprinter},\rtfsp
\helpref{wxPrintPreview}{wxprintpreview}, \helpref{wxPrinterDC}{wxprinterdc},\rtfsp
\helpref{wxPrintDialog}{wxprintdialog}.

The printing framework relies on the application to provide classes
whose member functions can respond to particular requests, such
as `print this page' or `does this page exist in the document?'.
This method allows wxWindows to take over the housekeeping duties of
turning preview pages, calling the print dialog box, creating
the printer device context, and so on: the application can concentrate
on the rendering of the information onto a device context.
The printing framework is mainly a Windows feature; PostScript
support under non-Windows platforms is emerging but has not been rigorously tested.

The \helpref{document/view framework}{docviewoverview} creates a default wxPrintout
object for every view, calling wxView::OnDraw to achieve a
prepackaged print/preview facility.

A document's printing ability is represented in an application by a
derived wxPrintout class. This class prints a page on request, and can
be passed to the Print function of a wxPrinter object to actually print
the document, or can be passed to a wxPrintPreview object to initiate
previewing. The following code (from the printing sample) shows how easy
it is to initiate printing, previewing and the print setup dialog, once the wxPrintout
functionality has been defined. Notice the use of MyPrintout for
both printing and previewing. All the preview user interface functionality
is taken care of by wxWindows. For details on how MyPrintout is defined,
please look at the printout sample code.

\begin{verbatim}
    case WXPRINT_PRINT:
    {
      wxPrinter printer;
      MyPrintout printout("My printout");
      printer.Print(this, &printout, TRUE);
      break;
    }
    case WXPRINT_PREVIEW:
    {
      // Pass two printout objects: for preview, and possible printing.
      wxPrintPreview *preview = new wxPrintPreview(new MyPrintout, new MyPrintout);
      wxPreviewFrame *frame = new wxPreviewFrame(preview, this, "Demo Print Preview", 100, 100, 600, 650);
      frame->Centre(wxBOTH);
      frame->Initialize();
      frame->Show(TRUE);
      break;
    }
    case WXPRINT_PRINT_SETUP:
    {
      wxPrintDialog printerDialog(this);
      printerDialog.GetPrintData().SetSetupDialog(TRUE);
      printerDialog.Show(TRUE);
      break;
    }
\end{verbatim}

\section{Interprocess communication overview}\label{ipcoverview}

Classes: \helpref{wxServer}{wxserver}, \helpref{wxConnection}{wxconnection},
\rtfsp\helpref{wxClient}{wxclient}.

The following describes how wxWindows implements DDE.  The following
three classes are central.

\begin{enumerate}\itemsep=0pt
\item wxClient. This represents the client application, and is used
only within a client program.
\item wxServer. This represents the server application, and is used
only within a server program.
\item wxConnection. This represents the connection from the current
client or server to the other application (server or client), and can be used
in both server and client programs. Most DDE
transactions operate on this object.
\end{enumerate}

Messages between applications are usually identified by three variables:
connection object, topic name and item name.  A data string is a fourth
element of some messages. To create a connection (a conversation in
Windows parlance), the client application sends the message
MakeConnection to the client object, with a string service name to
identify the server and a topic name to identify the topic for the
duration of the connection. Under UNIX, the service name must contain an
integer port identifier.

The server then responds and either vetos the connection or allows it.
If allowed, a connection object is created which persists until the
connection is closed.  The connection object is then used for subsequent
messages between client and server.

To create a working server, the programmer must:

\begin{enumerate}\itemsep=0pt
\item Derive a class from wxServer.
\item Override the handler OnAcceptConnection for accepting or rejecting a connection,
on the basis of the topic argument. This member must create and return a connection
object if the connection is accepted.
\item Create an instance of your server object, and call Create to
activate it, giving it a service name.
\item Derive a class from wxConnection.
\item Provide handlers for various messages that are sent to the server
side of a wxConnection.
\end{enumerate}

To create a working client, the programmer must:

\begin{enumerate}\itemsep=0pt
\item Derive a class from wxClient.
\item Override the handler OnMakeConnection to create and return
an appropriate connection object.
\item Create an instance of your client object.
\item Derive a class from wxConnection.
\item Provide handlers for various messages that are sent to the client
side of a wxConnection.
\item When appropriate, create a new connection by sending a MakeConnection
message to the client object, with arguments host name (processed in UNIX only),
service name, and topic name for this connection. The client object will call OnMakeConnection
to create a connection object of the desired type.
\item Use the wxConnection member functions to send messages to the server.
\end{enumerate}

\subsection{Data transfer}

These are the ways that data can be transferred from one application to
another.

\begin{itemize}\itemsep=0pt
\item {\bf Execute:} the client calls the server with a data string representing
a command to be executed. This succeeds or fails, depending on the
server's willingness to answer. If the client wants to find the result
of the Execute command other than success or failure, it has to explicitly
call Request.
\item {\bf Request:} the client asks the server for a particular data string
associated with a given item string. If the server is unwilling to
reply, the return value is NULL. Otherwise, the return value is a string
(actually a pointer to the connection buffer, so it should not be
deallocated by the application).
\item {\bf Poke:} The client sends a data string associated with an item
string directly to the server. This succeeds or fails.
\item {\bf Advise:} The client asks to be advised of any change in data
associated with a particular item. If the server agrees, the server will
send an OnAdvise message to the client along with the item and data.
\end{itemize}

The default data type is wxCF\_TEXT (ASCII text), and the default data
size is the length of the null-terminated string. Windows-specific data
types could also be used on the PC.

\subsection{Examples}

See the sample programs {\it server}\/ and {\it client}\/ in the IPC
samples directory.  Run the server, then the client. This demonstrates
using the Execute, Request, and Poke commands from the client, together
with an Advise loop: selecting an item in the server list box causes
that item to be highlighted in the client list box.

See also the source for wxHelp, which is a DDE server, and the files
wx\_help.h and wx\_help.cc which implement the client interface to
wxHelp.

\subsection{Remote Procedure Call}

DDE is quite a low level protocol, and all encoding and decoding of
messages must be done by the client and server applications. The
wxWindows extension {\it PrologIO}\/ implements a remote procedure call
protocol (RPC) so that a server can implement a library of functions for
a client to call.  PrologIO makes it easy for applications to pack and
unpack the arguments and return value(s) of procedure calls, and
provides a mechanism for the server to register its available calls and
automatically handle the routing of calls to appropriate server
callbacks, one to a procedure definition. All this makes calling or
implementing server facilities childishly simple. Since PrologIO sits on
top of the DDE wrapper, it is also platform independent. See the
separate PrologIO manual and \helpref{PrologIO}{prologio}.

\subsection{More DDE details}

A wxClient object represents the client part of a client-server DDE
(Dynamic Data Exchange) conversation (available in both
Windows and UNIX).

To create a client which can communicate with a suitable server,
you need to derive a class from wxConnection and another from wxClient.
The custom wxConnection class will intercept communications in
a `conversation' with a server, and the custom wxServer is required
so that a user-overriden \helpref{wxClient::OnMakeConnection}{wxclientonmakeconnection} member can return
a wxConnection of the required class, when a connection is made.

For example:

\begin{verbatim}
class MyConnection: public wxConnection
{
 public:
  MyConnection(void)::wxConnection(ipc_buffer, 3999) {}
  ~MyConnection(void) { }
  Bool OnAdvise(char *topic, char *item, char *data, int size, int format)
  { wxMessageBox(topic, data); }
};

class MyClient: public wxClient
{
 public:
  MyClient(void) {}
  wxConnection *OnMakeConnection(void) { return new MyConnection; }
};

\end{verbatim}

Here, {\bf MyConnection} will respond to \helpref{OnAdvise}{wxconnectiononadvise} messages sent
by the server.

When the client application starts, it must first call \helpref{wxIPCInitialize}{wxipcinitialize}\rtfsp
before creating an instance of the derived wxClient. In the following, command line
arguments are used to pass the host name (the name of the machine the server is running
on) and the server name (identifying the server process). Calling \helpref{wxClient::MakeConnection}{wxclientmakeconnection}\rtfsp
implicitly creates an instance of {\bf MyConnection} if the request for a
connection is accepted, and the client then requests an {\it Advise} loop
from the server, where the server calls the client when data has changed.

\begin{verbatim}
  wxIPCInitialize();

  char *server = "4242";
  char hostName[256];
  wxGetHostName(hostName, sizeof(hostName));

  char *host = hostName;

  if (argc > 1)
    server = argv[1];
  if (argc > 2)
    host = argv[2];

  // Create a new client
  MyClient *client = new MyClient;
  the_connection = (MyConnection *)client->MakeConnection(host, server, "IPC TEST");

  if (!the_connection)
  {
    wxMessageBox("Failed to make connection to server", "Client Demo Error");
    return NULL;
  }
  the_connection->StartAdvise("Item");
\end{verbatim}

\section{Font overview}\label{wxfontoverview}

Class: \helpref{wxFont}{wxfont}

A font is an object which determines the appearance of text, primarily
when drawing text to a canvas or device context. A font is determined by
up to six parameters:

\begin{twocollist}\itemsep=0pt
\twocolitem{Point size}{This is the standard way of referring to text size.}
\twocolitem{Family}{Supported families are:
  {\bf wxDEFAULT, wxDECORATIVE, wxROMAN, wxSCRIPT, wxSWISS, wxMODERN}.
  {\bf wxMODERN} is a fixed pitch font; the others are either fixed or variable pitch.}
\twocolitem{Style}{The value can be {\bf wxNORMAL, wxSLANT} or {\bf wxITALIC}.}
\twocolitem{Weight}{The value can be {\bf wxNORMAL, wxLIGHT} or {\bf wxBOLD}.}
\twocolitem{Underlining}{The value can be TRUE or FALSE.}
\twocolitem{Face name}{An optional string specifying the actual typeface to be used. If NULL,
a default typeface will chosen based on the family.}
\end{twocollist}

Specifying a family, rather than a specific typeface name, ensures a degree of portability
across platforms because a suitable font will be chosen for the given font family.

Under Windows, the face name can be one of the installed fonts on the user's system. Since
the choice of fonts differs from system to system, either choose standard Windows fonts,
or if allowing the user to specify a face name, store the family id with any file that
might be transported to a different Windows machine or other platform.

Under X, the situation is more complicated because X does not support a simple naming scheme
that will allow consistent naming of screen and printer fonts. To address this, wxWindows
implements a \helpref{font name directory}{wxfontnamedirectoryoverview} with a naming convention
to support screen and PostScript fonts. Under this scheme, the `family' parameter can also
be used as a font identifier. However, if you wish, you may still
use the family parameter in exactly the same way as before without needing to understand
the enhanced usage.

\normalbox{{\bf Note:} There is currently a difference between the appearance of fonts on the
two platforms, if the mapping mode is anything other than MM\_TEXT.
Under X, font size is always specified in points. Under MS Windows, the
unit for text is points but the text is scaled according to the
current mapping mode. However, user scaling on a device canvas will
also scale fonts under both environments.}

\subsection{Font name directory overview}\label{wxfontnamedirectoryoverview}

Class: \helpref{wxFontNameDirectory}{wxfontnamedirectory}

The font name directory helps implement the portable font scheme used
in the X versions of wxWindows, and optionally under Windows.

To draw text, you need a font id, weight, style, size, and underline
flag. The combination font id x weight x style maps to a``real" 
platform-specific font.

Every font id is associated to one of a fixed number of family ids.
Each of these family ids can be used as a font id, specifying a
default font for that family. When font information is stored in a
document that may cross platforms, the family id should be specified
so that a reasonable default font can be selected on the new platform.

Each font id is associated to a name (corresponding to the ``facename"
in Windows). This name should be used to store information about a
font on disk, since the font id used for a particular font name can
change when a wxWindows application is restarted.

The font constructor:

\begin{verbatim}
 wxFont(int pointSize, int damilyOrFontId, int style, int weight, 
        Bool underline = FALSE, char *faceName = NULL);
\end{verbatim}

has changed if the new scheme is in operation. When faceName is NULL,
familyOrFontId (formerly familyId) can be any font id. Recall that a
family id can always be used as a font id. When faceName is not NULL,
then familyOrFontId must be a family id. If the specified faceName
cannot be found, then a default font for the family id (passed as
familyOrFontId) will be used. 

The mappings:

\begin{itemize}\itemsep=0pt
\item font id, weight, style to real screen/PostScript font
\item font id to font name
\item font id to family
\item font name to font id
\end{itemize}

are managed by a single instance of wxFontNameDirectory.


\section{Device context overview}\label{dcoverview}

Classes: \helpref{wxDC}{wxdc}, \helpref{wxPostScriptDC}{wxpostscriptdc},\rtfsp
\rtfsp\helpref{wxMetaFileDC}{wxmetafiledc}, \helpref{wxMemoryDC}{wxmemorydc}, \helpref{wxPrinterDC}{wxprinterdc},\rtfsp
\helpref{wxScreenDC}{wxscreendc}.

A wxDC is a {\it device context} onto which graphics and text can be drawn.
It is intended to represent a number of output devices in a generic way,
so a canvas has a device context and a printer also has a device context.
In this way, the same piece of code may write to a number of different devices,
if the device context is used as a parameter.

To determine whether a device context is colour or monochrome, test the
\rtfsp{\bf Colour} Bool member variable. To override wxWindows monochrome
graphics drawing behaviour, set this member to TRUE.

wxDC is abstract and cannot be used to create
device context objects. Instead, use a derived class. \helpref{wxCanvasDC}{wxcanvasdc}\rtfsp
is a context that cannot be created by the user but can be retrieved from
a \helpref{wxCanvas}{wxcanvas} by using \helpref{wxCanvas::GetDC}{wxcanvasgetdc}.

When writing code to draw into a device context, use {\bf wxDC} as a
parameter whenever possible, to allow the most general use of your
drawing code.  You can then pass a device context object of any
derived type. See the demo in {\tt samples/hello} for code which
uses this device-independent method of drawing.

\section{wxApp overview}\label{wxappoverview}

Classes: \helpref{wxApp}{wxapp}

A wxWindows
application does not have a {\it main} procedure; the equivalent is the
\rtfsp\helpref{OnInit}{wxapponinit} member defined for a class derived from wxApp.\rtfsp
\rtfsp{\it OnInit} must create and return a main window frame as a bare minimum.
If NULL is returned from {\it OnInit}, the application will exit.
Note that the program's command line arguments, represented by {\it
argc} and {\it argv}, are available from within wxApp member functions.

An application closes by destroying all windows. Because all frames must
be destroyed for the application to exit, it is advisable to use parent
frames wherever possible when creating new frames, so that deleting the
top level frame will automatically delete child frames. The alternative
is to explicitly delete child frames in the top-level frame's \helpref{wxFrame::OnClose}{wxframeonclose}\rtfsp
member.

In emergencies the \helpref{wxExit}{wxexit} function can be called to kill the
application.

An example of defining an application follows:

\begin{verbatim}
class DerivedApp: public wxApp
{
 public:
  wxFrame *OnInit(void);
};

wxFrame *DerivedApp::OnInit(void)
{
  wxFrame *the_frame = new wxFrame(NULL, argv[0]);
  ...
  return the_frame;
}

MyApp DerivedApp;
\end{verbatim}

\section{Bitmaps overview}\label{wxbitmapoverview}

Classes: \helpref{wxBitmap}{wxbitmap}, \helpref{wxIcon}{wxicon}, \helpref{wxCursor}{wxcursor}.

The wxBitmap class encapsulates the concept of a platform-dependent bitmap,
either monochrome or colour. Platform-specific methods for creating a
wxBitmap object from an existing file are catered for, and
this is an occasion where conditional compilation will probably be
required.

A bitmap created dynamically or loaded from a file can be selected
into a memory device context (instance of \helpref{wxMemoryDC}{wxmemorydc}). This
enables the bitmap to be copied to a canvas or memory device context
using \helpref{wxDC::Blit}{wxdcblit}, or to be used as a drawing surface.  The {\bf
wxToolBar} class was implemented using bitmaps, and the toolbar demo
shows one of the toolbar bitmaps being used for drawing a miniature
version of the graphic which appears on the main canvas.

wxWindows contains code to `grey out' a bitmap when used in an insensitive
panel item. Under X, this code is contained in the wxBitmap class.
Under Windows, the user-contributed Fafa library is responsible for this.

See \helpref{wxMemoryDC}{wxmemorydc} for an example of drawing onto a bitmap.

The following shows the conditional compilation required to load a
bitmap in X and in Windows 3. The alternative is to use the string
version of the bitmap constructor, which loads a file under X and a
resource under Windows 3, but has the disadvantage of requiring the
X icon file to be available at run-time.

\begin{verbatim}
#ifdef wx_x
#include "aiai.xbm"
#endif
#ifdef wx_msw
  wxIcon *icon = new wxBitmap("aiai");
#endif
#ifdef wx_x
  wxIcon *icon = new wxBitmap(aiai_bits, aiai_width, aiai_height);
#endif
\end{verbatim}

\subsection{Loading bitmaps: further information}

See also the DIB and wxImage libraries distributed with
wxWindows. DIB allows loading of .BMP files under Windows, and
wxImage allows loading of a variety of bitmap formats under X.
wxBuilder makes use of both of these packages: search for wxLoadBitmap
for example of usage.

There is now (from version 1.61) extra provision for a number of bitmap
formats via the standard wxBitmap class. These extra facilities can
be enabled using settings in wx\_setup.h; by default they are switched off.

XPM colour pixmaps may be loaded and saved under Windows and X, with
some restrictions imposed by the lack of colourmap facility when
using XPM files. The user may elect to use XPM files as a cross-platform
stabdard, or translate between XPM and BMP files using a suitable
utility (one is under preparation for wxWindows users).

Also, under Windows, DIBs (device independent bitmaps with extension BMP)
may be dynamically loaded and saved. Under X, GIF and BMP files may be
loaded but not saved.

\section{Dialog box overview}\label{wxdialogboxoverview}

Classes: \helpref{wxDialogBox}{wxdialogbox}, \helpref{wxEnhDialogBox}{wxenhdialogbox}

A dialog box is similar to a panel, in that it is a window which can
be used for placing panel items, with the following exceptions:

\begin{enumerate}
\item A surrounding frame is implicitly created.
\item Extra functionality is automatically given to the dialog box,
  such as tabbing between items (currently Windows only).
\item If the dialog box is {\it modal}, the calling program is blocked
  until the dialog box is dismissed.
\end{enumerate}

Under XView, some panel items may display incorrectly in a modal dialog,
and two modal dialogs may not be open simultaneously. This can
be corrected using a patch (see install/install.txt and install/xview.txt).

Under implementations that permit it, wxDialogBox inherits from wxCanvas
via wxPanel, and has a wxPanelDC that the application can draw on.

The panel device context associated with wxDialogBox behaves slightly
differently than for a panel or canvas: drawing to it {\it requires} enclosing
code in BeginDrawing, EndDrawing calls. This is because under Windows, dialog
box device contexts are not 'retained' and settings would be lost if the
device context were retrieved and released for each drawing operations.

Under Windows 3, modal dialogs have to be emulated using
modeless dialogs and a message loop. This is because Windows 3 expects
the contents of a modal dialog to be loaded from a resource file or
created on receipt of a dialog initialization message. This is too
restrictive for wxWindows, where any window may be created and displayed
before its contents are created.

For a set of dialog convenience functions, including file selection, see
\rtfsp\helpref{Dialog functions}{dialogfunctions}.

See also \helpref{wxPanel}{wxpanel} and \helpref{wxWindow}{wxwindow} for inherited
member functions.


\section{Common dialogs overview}\label{commondialogsoverview}

Classes and functions: \helpref{wxColourDialog}{wxcolourdialog}, \helpref{wxFontDialog}{wxfontdialog},
\rtfsp\helpref{wxPrintDialog}{wxprintdialog}, \rtfsp\helpref{dialog functions}{dialogfunctions}

Common dialog classes and functions encapsulate commonly-needed dialog box requirements.
They are mostly `modal', grabbing the flow of control until the user dismisses the dialog,
to make them easy to use within an application.

Some dialogs have both platform-dependent and platform-independent implementations,
so that if underlying windowing systems that do not provide the required functionality,
the generic classes and functions can stand in. For example, under MS Windows, wxColourDialog
uses the standard colour selector. There is also an equivalent called wxGenericColourDialog
for other platforms, and a macro defines wxColourDialog to be the same as wxGenericColourDialog
on non-MS Windows platforms. However, under MS Windows, the generic dialog can also be
used, for testing or other purposes.

Not all common dialogs have classes; some are still in functional form, awaiting
an object-oriented make-over, such as the message box and file selector
dialogs. A few familiar MS Windows-style common dialogs have yet to be implemented,
such as the text search dialog and a directory selector.

\subsection{wxColourDialog overview}\label{wxcolourdialogoverview}

Classes: \helpref{wxColourDialog}{wxcolourdialog}, \helpref{wxColourData}{wxcolourdata}

The wxColourDialog presents a colour selector to the user, and returns
with colour information.

{\bf The MS Windows colour selector}

Under Windows, the native colour selector common dialog is used. This
presents a dialog box with three main regions: at the top left, a
palette of 48 commonly-used colours is shown. Under this, there is a
palette of 16 `custom colours' which can be set by the application if
desired. Additionally, the user may open up the dialog box to show
a right-hand panel containing controls to select a precise colour, and add
it to the custom colour palette.

{\bf The generic colour selector}

Under non-MS Windows platforms, the colour selector is a simulation of
most of the features of the MS Windows selector. Two palettes of 48
standard and 16 custom colours are presented, with the right-hand area
containing three sliders for the user to select a colour from red,
green and blue components. This colour may be added to the custom colour
palette, and will replace either the currently selected custom colour,
or the first one in the palette if none is selected. The RGB colour sliders
are not optional in the generic colour selector. The generic colour
selector is also available under MS Windows; use the name
wxGenericColourDialog.

wxColourDialog is available under Motif and Windows. Under XView there
seem to be some problems, probably related to modal dialogs.

{\bf Example}

In the samples/dialogs directory, there is an example of using
the wxColourDialog class. Here is an excerpt, which
sets various parameters of a wxColourData object, including
a grey scale for the custom colours. If the user did not cancel
the dialog, the application retrieves the selected colour and
uses it to set the background of a canvas.

\begin{verbatim}
  wxColourData data;
  data.SetChooseFull(TRUE);
  for (int i = 0; i < 16; i++)
  {
    wxColour colour(i*16, i*16, i*16);
    data.SetCustomColour(i, colour);
  }
      
  wxColourDialog dialog(this, &data);
  if (dialog.Show(TRUE))
  {
    wxColourData retData = dialog.GetColourData();
    wxColour col = retData.GetColour();
    wxBrush *brush = wxTheBrushList->FindOrCreateBrush(&col, wxSOLID);
    myCanvas->SetBackground(brush);
    myCanvas->Clear();
    myCanvas->Refresh();
  }
\end{verbatim}

\subsection{wxFontDialog overview}\label{wxfontdialogoverview}

Classes: \helpref{wxFontDialog}{wxfontdialog}, \helpref{wxFontData}{wxfontdata}

The wxFontDialog presents a font selector to the user, and returns
with font and colour information.

{\bf The MS Windows font selector}

Under Windows, the native font selector common dialog is used. This
presents a dialog box with controls for font name, point size, style, weight,
underlining, strikeout and text foreground colour. A sample of the
font is shown on a white area of the dialog box. Note that
in the translation from full MS Windows fonts to wxWindows font
conventions, strikeout is ignored and a font family (such as
Swiss or Modern) is deduced from the actual font name (such as Arial
or Courier). The full range of Windows fonts cannot be used in wxWindows
at present.

wxFontDialog is available under Motif and Windows. Under XView there
seem to be some problems, probably related to modal dialogs.

{\bf The generic font selector}

Under non-MS Windows platforms, the font selector is simpler.
Controls for font family, point size, style, weight,
underlining and text foreground colour are provided, and
a sample is shown upon a white background. The generic font selector
is also available under MS Windows; use the name wxGenericFontDialog.

In both cases, the application is responsible for deleting the
new font returned from calling wxFontDialog::Show (if any).
This returned font is guaranteed to be a new object and not
one currently in use in the application.

{\bf Example}

In the samples/dialogs directory, there is an example of using
the wxFontDialog class. The application uses the returned font
and colour for drawing text on a canvas. Here is an excerpt:

\begin{verbatim}
  wxFontData data;
  data.SetInitialFont(canvasFont);
  data.SetColour(*canvasTextColour);
      
  wxFontDialog dialog(this, &data);
  if (dialog.Show(TRUE))
  {
    wxFontData retData = dialog.GetFontData();
    canvasFont = retData.GetChosenFont();
    (*canvasTextColour) = retData.GetColour();
    myCanvas->Refresh();
  }
\end{verbatim}

\subsection{wxPrintDialog overview}\label{wxprintdialogoverview}

Classes: \helpref{wxPrintDialog}{wxprintdialog}, \helpref{wxPrintData}{wxprintdata}

This class represents the print and print setup common dialogs.
You may obtain a \helpref{wxPrinterDC}{wxprinterdc} device context from
a successfully dismissed print dialog.

The samples/printing example shows how to use it: see \helpref{Printing overview}{printingoverview} for
an excerpt from this example.

\section{Constraints overview}\label{constraintsoverview}

Classes: \helpref{wxLayoutConstraints}{wxlayoutconstraints}, \helpref{wxIndividualLayoutConstraint}{wxindividuallayoutconstraint}.

Objects of class wxLayoutConstraint can be associated with a window to define the
way its subwindows are laid out, with respect to their siblings or parent.

The class consists of the following eight constraints of class wxIndividualLayoutConstraint,
some or all of which should be accessed directly to set the appropriate
constraints.

\begin{itemize}\itemsep=0pt
\item {\bf left:} represents the left hand edge of the window
\item {\bf right:} represents the right hand edge of the window
\item {\bf top:} represents the top edge of the window
\item {\bf bottom:} represents the bottom edge of the window
\item {\bf width:} represents the width of the window
\item {\bf height:} represents the height of the window
\item {\bf centreX:} represents the horizontal centre point of the window
\item {\bf centreY:} represents the vertical centre point of the window
\end{itemize}

Most constraints are initially set to have the relationship wxUnconstrained,
which means that their values should be calculated by looking at known constraints.
The exceptions are {\it width} and {\it height}, which are set to wxAsIs to
ensure that if the user does not specify a constraint, the existing
width and height will be used, to be compatible with panel items which often
have take a default size. If the constraint is wxAsIs, the dimension will
not be changed.

To call the \helpref{wxWindow::Layout}{wxwindowlayout} function which evaluates
constraints, you can either call wxWindow::SetAutoLayout to tell
default OnSize handlers to call Layout, or override OnSize and call Layout yourself.

\subsection{Constraint layout: more detail}

By default, windows do not have a wxLayoutConstraints object. In this case, much layout
must be done explicitly, by performing calculations in OnSize members, except
for the case of frames that have one subwindow, where wxFrame::OnSize takes care
of resizing the child.

To avoid the need for these rather awkward calculations, the user can create
a wxLayoutConstraints object and associate it with a window with wxWindow::SetConstraints.
This object contains a constraint for each of the window edges, two for the centre point,
and two for the window size. By setting some or all of these constraints appropriately,
the user can achieve quite complex layout by defining relationships between windows.

In wxWindows, each window can be constrained relative to either its {\it
siblings} on the same window, or the {\it parent}. The layout algorithm
therefore operates in a top-down manner, finding the correct layout for
the children of a window, then the layout for the grandchildren, and so
on. Note that this differs markedly from native Motif layout, where
constraints can ripple upwards and can eventually change the frame
window or dialog box size. We assume in wxWindows that the {\it user} is
always `boss' and specifies the size of the outer window, to which
subwindows must conform. Obviously, this might be a limitation in some
circumstances, but it suffices for most situations, and the
simplification avoids some of the nightmarish problems associated with
programming Motif.

When the user sets constraints, many of the constraints for windows
edges and dimensions remain unconstrained. For a given window,
the wxWindow::Layout algorithm first resets all constraints
in all children to have unknown edge or dimension values, and then iterates through the constraints,
evaulating them. For unconstrained edges and dimensions, it
tries to find the value using known relationships that always hold. For example,
an unconstrained {\it width} may be calculated from the {\it left} and {\it right edges}, if
both are currently known. For edges and dimensions with user-supplied constraints, these
constraints are evaulated if the inputs of the constraint are known.

The algorithm stops when all child edges and dimension are known (success), or there
there are unknown edges or dimensions but there has been no change in this cycle (failure).

It then sets all the window positions and sizes according to the values it has found.

Because the algorithm is iterative, the order in which constraints are considered is
irrelevant.

\subsection{Window layout examples}\label{layoutexamples}

\subsubsection{Example 1: subwindow layout}

This example specifies a panel and a canvas side by side,
with a text subwindow below it. 

\begin{verbatim}
  frame->panel = new wxPanel(frame, 0, 0, 1000, 500, 0);
  frame->canvas = new MyCanvas(frame, 0, 0, 400, 400, wxRETAINED);
  frame->text_window = new MyTextWindow(frame, 0, 250, 400, 250, wxNATIVE_IMPL);

  // Set constraints for panel subwindow
  wxLayoutConstraints *c1 = new wxLayoutConstraints;

  c1->left.SameAs       (frame, wxLeft);
  c1->top.SameAs        (frame, wxTop);
  c1->right.PercentOf   (frame, wxWidth, 50);
  c1->height.PercentOf  (frame, wxHeight, 50);

  frame->panel->SetConstraints(c1);

  // Set constraints for canvas subwindow
  wxLayoutConstraints *c2 = new wxLayoutConstraints;

  c2->left.SameAs       (frame->panel, wxRight);
  c2->top.SameAs        (frame, wxTop);
  c2->right.SameAs      (frame, wxRight);
  c2->height.PercentOf  (frame, wxHeight, 50);

  frame->canvas->SetConstraints(c2);

  // Set constraints for text subwindow
  wxLayoutConstraints *c3 = new wxLayoutConstraints;
  c3->left.SameAs       (frame, wxLeft);
  c3->top.Below         (frame->panel);
  c3->right.SameAs      (frame, wxRight);
  c3->bottom.SameAs     (frame, wxBottom);

  frame->text_window->SetConstraints(c3);
\end{verbatim}

\subsubsection{Example 2: panel item layout}

This example sizes a button width to 80 percent of the panel width, and centres
it horizontally. A listbox and multitext item are placed below it. The listbox
takes up 40 percent of the panel width, and the multitext item takes up
the remainder of the width. Margins of 5 pixels are used.

\begin{verbatim}
  // Create some panel items
  wxButton *btn1 = new wxButton(frame->panel, (wxFunction)NULL, "A button") ;

  wxLayoutConstraints *b1 = new wxLayoutConstraints;
  b1->centreX.SameAs    (frame->panel, wxCentreX);
  b1->top.SameAs        (frame->panel, wxTop, 5);
  b1->width.PercentOf   (frame->panel, wxWidth, 80);
  b1->height.PercentOf  (frame->panel, wxHeight, 10);
  btn1->SetConstraints(b1);

  wxListBox *list = new wxListBox(frame->panel, (wxFunction)NULL, "A list",
                                  wxSINGLE, -1, -1, 200, 100);

  wxLayoutConstraints *b2 = new wxLayoutConstraints;
  b2->top.Below         (btn1, 5);
  b2->left.SameAs       (frame->panel, wxLeft, 5);
  b2->width.PercentOf   (frame->panel, wxWidth, 40);
  b2->bottom.SameAs     (frame->panel, wxBottom, 5);
  list->SetConstraints(b2);

  wxMultiText *mtext = new wxMultiText(frame->panel, (wxFunction)NULL, "Multiline text", "Some text",
                        -1, -1, 150, 100);
  
  wxLayoutConstraints *b3 = new wxLayoutConstraints;
  b3->top.Below         (btn1, 5);
  b3->left.RightOf      (list, 5);
  b3->right.SameAs      (frame->panel, wxRight, 5);
  b3->bottom.SameAs     (frame->panel, wxBottom, 5);
  mtext->SetConstraints(b3);
\end{verbatim}

\section{Event handling overview}\label{eventhandlingoverview}

Classes: \helpref{wxEvtHandler}{wxevthandler}, \helpref{wxWindow}{wxwindow}

To handle events that are generated by the windowing system (usually in response
to a user's action), the programmer must derive a class from the window that
is sent the event, and define appropriate behaviour. For example, to respond to
OnPaint messages from a wxCanvas, you would derive a new class MyCanvas
and define the function MyCanvas::OnPaint. Within this function, you
paint the canvas as necessary for your application.

To respond to a user closing a window, define OnClose; to intercept character
input from a canvas, define OnChar, and so on. These events are listed in the
class description for \helpref{wxEvtHandler}{wxevthandler}, which is the
base class for all window classes.

In fact, you don't have to derive a new class from a window class
if you don't want to. You can derive a new class from wxEvtHandler instead,
overriding the appropriate member function, and then call
\rtfsp\helpref{wxWindow::SetEventHandler}{wxwindowseteventhandler} to make this
event handler the object that responds to events. This way, you can avoid
a lot of class derivation, and use the same event handler object to
handle events from instances of different classes. If you ever have to call a window's event handler
manually, use the GetEventHandler function to retrieve the window's event handler and use that
to call the member function. By default, GetEventHandler returns a pointer to the window itself
unless an application has redirected event handling using SetEventHandler.

You could use this technique to respond to panel item commands. Normally,
you supply a function of type wxFunction to the panel item constructor, and
it will be called with references to the panel item and command event.
Instead, you could use a single wxEvtHandler object for handling one or
more panel items, setting the event handler object for the panel item just
after item construction. This handler could even be the panel or dialog box.

Another use of SetEventHandler is to temporarily or permanently change the
behaviour of the GUI. For example, you might want to invoke a dialog editor
in your application that changes aspects of dialog boxes. You can
grab all the input for an existing dialog box, and edit it `in situ',
before restoring its behaviour to normal. So even if the application
has derived new classes to customize behaviour, your utility can indulge
in a spot of body-snatching. It could be a useful technique for on-line
tutorials, too, where you take a user through a serious of steps and
don't want them to diverge from the lesson. Here, you can examine the events
coming from buttons and windows, and if acceptable, pass them through to
the original event handler. Use Set/GetNextHandler and Set/GetPreviousHandler
to form a chain of event handlers, taking care to pass events along the chain.

\section{Toolbar overview}\label{wxtoolbaroverview}

Classes: \helpref{wxToolBar}{wxtoolbar}, \helpref{wxButtonBar}{wxbuttonbar}

The wxToolBar class gives wxWindows programs an extra, and increasingly
popular, user interface component: a set of bitmap buttons or toggles.
A toolbar gives faster access to an application's facilities than
menus, which have to be popped up and selected rather laboriously.
Besides which, a toolbar looks prettier than a purely menu-based
interface.

wxToolBar uses a canvas subwindow for drawing bitmaps, and so bitmap
images cannot be mixed with panel items, but in most cases this won't
be important. A toolbar might appear as a single row of images under
the menubar, or it might be in a separate frame layout in several rows
and columns. The class handles the layout of the images, unless explicit
positioning is requested.

A tool is a bitmap which can either be a button (there is no `state',
it just generates an event when clicked) or it can be a toggle. If a
toggle, a second bitmap can be provided to depict the `on' state; if
the second bitmap is omitted, either the inverse of the first bitmap
will be used (for monochrome displays) or a thick border is drawn
around the bitmap (for colour displays where inverting will not have
the desired result).

Mouse click events for a given button are sent to a member called
\rtfsp{\bf OnLeftClick}, and so an application must derive from wxToolBar in order
to use it. The application can also handle {\bf OnMouseEnter} events for
the tools, to give the user extra feedback about the tools as the mouse
moves over them.

\normalbox{This toolbar class does not give as slick an appearance as,
or the responsiveness of, conventional Windows toolbars. The buttons are not
given a 3D appearance and do not depress like normal buttons. However, you
can use the optimized wxButtonBar library for greatly improved Windows behaviour,
and behaviour under X identical to wxToolBar.
See \helpref{The wxButtonBar library}{wxbuttonbaroverview}.}

\subsection{Using the toolbar library}

Include the file {\tt wx\_tbar.h} to use this class.

An example of toolbar use is given in the sample program contained in {\tt
test.cc} and {\tt test.h}.  This creates a main window, and two
toolbars: a floating toolbar with 24 tools, and a toolbar along the
top of the main drawing canvas, divided into groups.  The icons for
this second toolbar would normally be quite small.

The test program defines a general-purpose derived frame called
\rtfsp{\bf wxFrameWithToolBar} which can manage a frame with one main subwindow
and one horizontal toolbar.

Note that one of the bitmaps on the floating toolbar is a small version of the
main graphic: this demonstrates how a memory device context can be used to
draw into a bitmap. An application which allowed the user to build up a symbol
library dynamically might create this kind of bitmap.

Left clicks and movements over the toolbars are intercepted and information
is displayed on the status line.

The following fragment illustrates the essence of creating a toolbar.

\begin{verbatim}
  toolBarBitmaps[0] = new wxBitmap("icon1");
  toolBarBitmaps[1] = new wxBitmap("icon2");
  toolBarBitmaps[2] = new wxBitmap("icon3");
  ...

  toolBarFrame = new wxFrame(NULL, "Tools", 0, 0, 300, 200,
    wxSDI | wxDEFAULT_FRAME | wxSTAY_ON_TOP);

  // 5 rows
  toolBar = new TestToolBar(toolBarFrame, 10, 10, -1, -1, 0, wxVERTICAL, 5);
  toolBar->SetMargins(2, 2);
  toolBar->GetDC()->SetBackground(wxGREY_BRUSH);

  for (int i = 10; i < 25; i++)
    toolBar->AddTool(i, toolBarBitmaps[i], NULL, TRUE);

  toolBar->Layout();
  float maxWidth, maxHeight;
  toolBar->GetMaxSize(&maxWidth, &maxHeight);
  toolBarFrame->SetClientSize((int)maxWidth, (int)maxHeight);
  toolBarFrame->Show(TRUE);
\end{verbatim}

\subsection{The wxButtonBar library}\label{wxbuttonbaroverview}

\overview{wxToolBar overview}{wxtoolbaroverview}

Class: \helpref{wxButtonBar}{wxbuttonbar}

wxToolBar does the job, but it isn't as slick as it could be. The wxButtonBar
library class presents an almost identical Application Programming
Interface, but under Windows, the buttons are 3D and depress properly.

Under Windows, it expects 16-colour bitmaps that are 16 pixels wide and 15 pixels
high. If you want to use a different size, call {\bf wxButtonBar::SetDefaultSize}\rtfsp
as the demo shows, before adding tools to the button bar. Don't supply more than
one bitmap for each tool, because wxButtonBar generates all three images (normal,
depressed and checked) from the single bitmap you give it.

Include the file {\tt wx\_bbar.h} to use this class.

X-optimized (or generic) button bar code may follow at a future date.

\subsubsection{Windows 95 differences}

Under Windows 95, wxButtonBar behaves slightly differently than under generic WIN32,
since it uses the Windows 95 toolbar common control.

\begin{enumerate}\itemsep=0pt
\item CreateTools must be called after the tools have been added.
\item No absolute positioning is supported but you can specify the number
of rows, and add tool separators with AddSeparator. Layout does nothing.
\item Tooltips are supported.
\item OnRightClick is not supported.
\item The device context support is limited, though there is enough to support
drawing a border from within OnPaint.
\item OnEvent and OnChar are not supported.
\item Scrollbars are not supported.
\end{enumerate}

{\it Note:} under Windows 95, a wxButtonBar cannot be moved to any
position other than the top-left of the frame. If this is a problem, you may
wish to alter {\tt wx\_bbar.h} and {\tt wx\_bbar.cc} to compile the non-Windows 95
code instead.

\section{Database classes overview}\label{odbcoverview}

Classes: \helpref{wxDatabase}{wxdatabase}, \helpref{wxRecordSet}{wxrecordset}, \helpref{wxQueryCol}{wxquerycol},
\rtfsp\helpref{wxQueryField}{wxqueryfield}

\normalboxd{IMPORTANT NOTE: The ODBC classes are a preliminary release and incomplete. Please
take this into account when using them. Feedback and bug fixes are appreciated,
as always. The classes are being developed by Olaf Klein (oklein@smallo.ruhr.de) and
Patrick Halke (patrick@zaphod.ruhr.de).}

wxWindows provides a set of classes for accessing a subset of Microsoft's ODBC (Open Database Connectivity)
product. Currently, this wrapper is available under MS Windows only, although
ODBC may appear on other platforms, and a generic or product-specific SQL emulator for the ODBC
classes may be provided in wxWindows at a later date.

ODBC presents a unified API (Application Programmer's Interface) to a
wide variety of databases, by interfacing indirectly to each database or
file via an ODBC driver. The language for most of the database
operations is SQL, so you need to learn a small amount of SQL as well as
the wxWindows ODBC wrapper API. Even though the databases may not be
SQL-based, the ODBC drivers translate SQL into appropriate operations
for the database or file: even text files have rudimentry ODBC support,
along with dBASE, Access, Excel and other file formats.

The run-time files for ODBC are bundled with many existing database
packages, including MS Office. The required header files, sql.h and
sqlext.h, are bundled with several compilers including MS VC++ and
Watcom C++. The only other way to obtain these header files is from the
ODBC SDK, which is only available with the MS Developer Network CD-ROMs
-- at great expense. If you have odbc.dll, you can make the required
import library odbc.lib using the tool `implib'. You need to have odbc.lib
in your compiler library path.

The minimum you need to distribute with your application is odbc.dll, which must
go in the Windows system directory. For the application to function correctly,
ODBC drivers must be installed on the user's machine. If you do not use the database
classes, odbc.dll will be loaded but not called (so ODBC does not need to be
setup fully if no ODBC calls will be made).

A sample is distributed with wxWindows in {\tt samples/odbc}. You will need to install
the sample dbf file as a data source using the ODBC setup utility, available from
the control panel if ODBC has been fully installed.

\subsection{Procedures for writing an ODBC application}

You first need to create a wxDatabase object. If you want to get information
from the ODBC manager instead of from a particular database (for example
using \helpref{wxRecordSet::GetDataSources}{wxrecordsetgetdatasources}), then you
do not need to call \helpref{wxDatabase::Open}{wxdatabaseopen}.
If you do wish to connect to a datasource, then call wxDatabase::Open.
You can reuse your wxDatabase object, calling wxDatabase::Close and wxDatabase::Open
multiple times.

Then, create a wxRecordSet object for retrieving or sending information.
For ODBC manager information retrieval, you can create it as a dynaset (retrieve the
information as needed) or a snapshot (get all the data at once).
If you are going to call \helpref{wxRecordSet::ExecuteSQL}{wxrecordsetexecutesql}, you need to create it as a snapshot.
Dynaset mode is not yet implemented for user data.

Having called a function such as wxRecordSet::ExecuteSQL or
wxRecordSet::GetDataSources, you may have a number of records
associated with the recordset, if appropriate to the operation. You can
now retrieve information such as the number of records retrieved and the
actual data itself. Use \helpref{wxRecordSet::GetFieldData}{wxrecordsetgetfielddata} or
\helpref{wxRecordSet::GetFieldDataPtr}{wxrecordsetgetfielddataptr} to get the data or a pointer to it, passing
a column index or name. The data returned will be for the current
record. To move around the records, use \helpref{wxRecordSet::MoveNext}{wxrecordsetmovenext},
\rtfsp\helpref{wxRecordSet::MovePrev}{wxrecordsetmoveprev} and associated functions.

You can use the same recordset for multiple operations, or delete
the recordset and create a new one.

Note that when you delete a wxDatabase, any associated recordsets
also get deleted, so beware of holding onto invalid pointers.

\subsection{wxDatabase overview}\label{wxdatabaseoverview}

\overview{Database classes overview}{odbcoverview}

Class: \helpref{wxDatabase}{wxdatabase}

Every database object represents an ODBC connection. To do anything useful
with a database object you need to bind a wxRecordSet object to it. All you
can do with wxDatabase is opening/closing connections and getting some info
about it (users, passwords, and so on).

\subsection{wxQueryCol overview}\label{wxquerycoloverview}

\overview{Database classes overview}{odbcoverview}

Class: \helpref{wxQueryCol}{wxquerycol}

Every data column is represented by an instance of this class.
It contains the name and type of a column and a list of wxQueryFields where
the real data is stored. The links to user-defined variables are stored
here, as well.

\subsection{wxQueryField overview}\label{wxqueryfieldoverview}

\overview{Database classes overview}{odbcoverview}

Class: \helpref{wxQueryField}{wxqueryfield}

As every data column is represented by an instance of the class wxQueryCol,
every data item of a specific column is represented by an instance of
wxQueryField. Each column contains a list of wxQueryFields. If wxRecordSet is
of the type wxOPEN\_TYPE\_DYNASET, there will be only one field for each column,
which will be updated every time you call functions like wxRecordSet::Move
or wxRecordSet::GoTo. If wxRecordSet is of the type wxOPEN\_TYPE\_SNAPSHOT,
all data returned by an ODBC function will be loaded at once and the number
of wxQueryField instances for each column will depend on the number of records.

\subsection{wxRecordSet overview}\label{wxrecordsetoverview}

\overview{Database classes overview}{odbcoverview}

Class: \helpref{wxRecordSet}{wxrecordset}

Each wxRecordSet represents a database query. You can make multiple queries
at a time by using multiple wxRecordSets with a wxDatabase or you can make
your queries in sequential order using the same wxRecordSet.

\subsection{ODBC SQL data types}\label{sqltypes}

\overview{Database classes overview}{odbcoverview}

These are the data types supported in ODBC SQL. Note that there are other, extended level conformance
types, not currently supported in wxWindows.

\begin{twocollist}\itemsep=0pt
\twocolitem{CHAR(n)}{A character string of fixed length {\it n}.}
\twocolitem{VARCHAR(n)}{A varying length character string of maximum length {\it n}.}
\twocolitem{LONG VARCHAR(n)}{A varying length character string: equivalent to VARCHAR for the purposes
of ODBC.}
\twocolitem{DECIMAL(p, s)}{An exact numeric of precision {\it p} and scale {\it s}.}
\twocolitem{NUMERIC(p, s)}{Same as DECIMAL.}
\twocolitem{SMALLINT}{A 2 byte integer.}
\twocolitem{INTEGER}{A 4 byte integer.}
\twocolitem{REAL}{A 4 byte floating point number.}
\twocolitem{FLOAT}{An 8 byte floating point number.}
\twocolitem{DOUBLE PRECISION}{Same as FLOAT.}
\end{twocollist}

These data types correspond to the following ODBC identifiers:

\begin{twocollist}\itemsep=0pt
\twocolitem{SQL\_CHAR}{A character string of fixed length.}
\twocolitem{SQL\_VARCHAR}{A varying length character string.}
\twocolitem{SQL\_DECIMAL}{An exact numeric.}
\twocolitem{SQL\_NUMERIC}{Same as SQL\_DECIMAL.}
\twocolitem{SQL\_SMALLINT}{A 2 byte integer.}
\twocolitem{SQL\_INTEGER}{A 4 byte integer.}
\twocolitem{SQL\_REAL}{A 4 byte floating point number.}
\twocolitem{SQL\_FLOAT}{An 8 byte floating point number.}
\twocolitem{SQL\_DOUBLE}{Same as SQL\_FLOAT.}
\end{twocollist}

\subsection{A selection of SQL commands}\label{sqlcommands}

\overview{Database classes overview}{odbcoverview}

The following is a very brief description of some common SQL commands, with
examples.

\subsubsection{Create}

Creates a table.

Example:

\begin{verbatim}
CREATE TABLE Book
 (BookNumber     INTEGER     PRIMARY KEY
 , CategoryCode  CHAR(2)     DEFAULT 'RO' NOT NULL
 , Title         VARCHAR(100) UNIQUE
 , NumberOfPages SMALLINT
 , RetailPriceAmount NUMERIC(5,2)
 )
\end{verbatim}

\subsubsection{Insert}

Inserts records into a table.

Example:

\begin{verbatim}
INSERT INTO Book
  (BookNumber, CategoryCode, Title)
  VALUES(5, 'HR', 'The Lark Ascending')
\end{verbatim}

\subsubsection{Select}

The Select operation retrieves rows and columns from a table. The criteria
for selection and the columns returned may be specified.

Examples:

\verb$SELECT * FROM Book$

Selects all rows and columns from table Book.

\verb$SELECT Title, RetailPriceAmount FROM Book WHERE RetailPriceAmount > 20.0$

Selects columns Title and RetailPriceAmount from table Book, returning only
the rows that match the WHERE clause.

\verb$SELECT * FROM Book WHERE CatCode = 'LL' OR CatCode = 'RR'$

Selects all columns from table Book, returning only
the rows that match the WHERE clause.

\verb$SELECT * FROM Book WHERE CatCode IS NULL$

Selects all columns from table Book, returning only rows where the CatCode column
is NULL.

\verb$SELECT * FROM Book ORDER BY Title$

Selects all columns from table Book, ordering by Title, in ascending order. To specify
descending order, add DESC after the ORDER BY Title clause.

\verb$SELECT Title FROM Book WHERE RetailPriceAmount >= 20.0 AND RetailPriceAmount <= 35.0$

Selects records where RetailPriceAmount conforms to the WHERE expression.

\subsubsection{Update}

Updates records in a table.

Example:

\verb$UPDATE Incident SET X = 123 WHERE ASSET = 'BD34'$

This example sets a field in column `X' to the number 123, for the record
where the column ASSET has the value `BD34'.


\section{Debugging overview}\label{debuggingoverview}

Classes: \helpref{wxDebugContext}{wxdebugcontext}, \helpref{wxDebugStreamBuf}{wxdebugstreambuf},
\rtfsp\helpref{wxObject}{wxobject}

\normalboxd{{\bf IMPORTANT NOTE:} The debugging facilities in wxWindows are new (June 1995)
so please be careful when using them. Since they operate at a low level
by redefining memory allocation operators, there may be unforeseen problems on specific platforms.
Proceed with caution!}

Various classes, functions and macros are provided in wxWindows to help you debug
your application. Most of these are only available if you compile both wxWindows,
your application and {\it all} libraries that use wxWindows with the DEBUG flag
set to 1 or more.

wxDebugContext is a class that never gets instantiated, but ties together
various functions and variables. It allows you to set the debugging stream, dump
all objects to that stream, write statistics about object allocation, and
check memory for errors.

You can use the \helpref{WXTRACE}{trace} macro to output debugging information in DEBUG mode;
it will be defined to nothing for non-debugging code.

It is good practice to define a Dump member function for each class you derive
from a wxWindows class, so that wxDebugContext::Dump can call it and
give valuable information about the state of the application.

For wxDebugContext to do its work, the {\it new} and {\it delete}\rtfsp
operators for wxObject have been redefined to store extra information
about dynamically allocated objects (but not statically declared
objects). This slows down a debugging version of an application, but can
in theory find difficult-to-detect memory leaks (objects are not
deallocated), overwrites (writing past the end of your object) and
underwrites (writing to memory in front of the object).

If you have difficulty tracking down a memory leak, recompile
in debugging mode and call wxDebugContext::Dump and wxDebugContext::Statistics
at appropriate places. They will tell you what objects have not yet been
deleted, and what kinds of object they are.

If you use the macro WXDEBUG\_NEW instead of the normal 'new', the debugging
output (and error messages reporting memory problems) will also tell you what
file and on what line you allocated the object.

To avoid the need for replacing existing new operators with WXDEBUG\_NEW, you
can write this at the top of each application file:

\begin{verbatim}
#define new WXDEBUG\_NEW
\end{verbatim}

In non-debugging mode, this will revert to the usual interpretation
of new. Note that for this not to mess up new-based allocation of non-wxObject derived classes and
built-in types, there are global definitions of new and delete which match
the syntax required for storing filename and line numbers. These merely
call malloc and free, and so do not do anything interesting. The definitions
may possibly cause multiple symbol problems for some compilers and so might
need to be omitted by setting the USE\_GLOBAL\_MEMORY\_OPERATORS to 0 in wx\_setup.h

\subsection{wxDebugContext overview}\label{wxdebugcontextoverview}

\overview{Debugging overview}{debuggingoverview}

Class: \helpref{wxDebugContext}{wxdebugcontext}

wxDebugContext is a class for performing various debugging and memory tracing
operations. wxDebugContext, and the related macros and function WXTRACE and
wxTrace, are only present if USE\_DEBUG\_CONTEXT is used.

This class has only static data and function members, and there should be
no instances. Probably the most useful members are SetFile (for directing output
to a file, instead of the default standard error or debugger output);
Dump (for dumping the dynamically allocated objects) and PrintStatistics
(for dumping information about allocation of objects). You can also call
Check to check memory blocks for integrity.

Here's an example of use. The SetCheckpoint ensures that only the
allocations done after the checkpoint will be dumped. Unfortunately
the define of new to WXDEBUG\_NEW does not work for Borland C++ (and
perhaps other compilers) because it fails to find the correct overloaded
operator for non-object usage of new. Instead, you need to use WXDEBUG\_NEW
explicitly if there are any examples of non-object new usage in the file.

\begin{verbatim}
#define new WXDEBUG_NEW

  wxDebugContext::SetCheckpoint();

  wxDebugContext::SetFile("c:\\temp\\debug.log");

  wxString *thing = new wxString;

  // Proves that defining 'new' to be 'WXDEBUG_NEW' doesn't mess up
  // non-object allocation. Doesn't work for Borland C++.
  char *ordinaryNonObject = new char[1000];

  wxDebugContext::Dump();
  wxDebugContext::PrintStatistics();
\end{verbatim}

You can use wxDebugContext if DEBUG is 1 or more, or you can use it
at any other time (if USE\_DEBUG\_CONTEXT is 1). It is not disabled
for DEBUG = 1 (as in earlier versions of wxWindows) because you
may not wish to recompile wxWindows and your entire application
just to make use of the error logging facility. This is especially
true in a Windows NT or Windows 95 environment, where you cannot
easily output to a debug window: wxDebugContext can be used to
write to log files instead.

\input wxstring.tex
%

\section{Writing a wxWindows application: a rough guide}\label{roughguide}

To set a wxWindows application going, you'll need to derive a \helpref{wxApp}{wxapp} class.

An application must have a top-level \helpref{wxFrame}{wxframe} window (returned by \helpref{wxApp::OnInit}{wxapponinit}),
each frame containing one or more instances of \helpref{wxPanel}{wxpanel}, \helpref{wxTextWindow}{wxtextwindow}\rtfsp
or \helpref{wxCanvas}{wxcanvas}.

A frame can have a \helpref{wxMenuBar}{wxmenubar}, a status line, and a \helpref{wxIcon}{wxicon} for
when the frame is iconized.

A \helpref{wxPanel}{wxpanel} is used to place items (classes derived from \helpref{wxItem}{wxitem})
which are used for user interaction. Examples of items are \helpref{wxButton}{wxbutton},
\rtfsp\helpref{wxCheckBox}{wxcheckbox}, \helpref{wxChoice}{wxchoice}, \helpref{wxListBox}{wxlistbox}, \helpref{wxSlider}{wxslider},
\rtfsp\helpref{wxRadioBox}{wxradiobox}, \helpref{wxSlider}{wxslider}.

Instances of \helpref{wxDialogBox}{wxdialogbox} can also be used for panels, items and they have
the advantage of not requiring a separate frame.

Instead of creating a dialog box and populating it with items, it is possible to choose
one of the convenient \helpref{dialog functions}{dialogfunctions}, such as \helpref{wxMessageBox}{wxmessagebox}\rtfsp
and \helpref{wxFileSelector}{wxfileselector}.

If you want to draw arbitrary graphics, you'll need a \helpref{wxCanvas}{wxcanvas}. In fact,
you never draw directly onto a canvas---you use a {\it device context} (DC). \helpref{wxDC}{wxdc} is
the base for \helpref{wxCanvasDC}{wxcanvasdc}, \helpref{wxMemoryDC}{wxmemorydc}, \helpref{wxPostScriptDC}{wxpostscriptdc},
\rtfsp\helpref{wxMemoryDC}{wxmemorydc}, \helpref{wxMetaFileDC}{wxmetafiledc} and \helpref{wxPrinterDC}{wxprinterdc}.
If your drawing functions have {\bf wxDC} as a parameter, you can pass any of these DCs
to the function, and thus use the same code to draw to several different devices.
You can draw using the member functions of {\bf wxDC}, such as \helpref{wxDC::DrawLine}{wxdcdrawline}\rtfsp
and \helpref{wxDC::DrawText}{wxdcdrawtext}. Control colour on a canvas (\helpref{wxColour}{wxcolour}) with
brushes (\helpref{wxBrush}{wxbrush}) and pens (\helpref{wxPen}{wxpen}).

On a canvas, you will probably need to intercept key events by overriding the
\rtfsp\helpref{wxCanvas::OnChar}{wxcanvasonchar} member, and mouse events by overriding \helpref{wxCanvas::OnEvent}{wxcanvasonevent}.

Most modern applications will have an on-line, hypertext help system; for this, you
need wxHelp and the \helpref{wxHelpInstance}{wxhelpinstance} class to control
wxHelp. To add sparkle, you might use the wxToolBar class (documented separately)
which makes heavy use of the \helpref{wxBitmap}{wxbitmap}.

GUI applications aren't all graphical wizardry. List and hash table needs are
catered for by \helpref{wxList}{wxlist}, \helpref{wxStringList}{wxstringlist} and \helpref{wxHashTable}{wxhashtable}.
You will undoubtedly need some platform-independent \helpref{file functions}{filefunctions},
and you may find it handy to maintain and search a list of paths using \helpref{wxPathList}{wxpathlist}.
There's a \helpref{miscellany}{miscellany} of operating system and other functions.

If you have several communicating applications, you can try out the DDE-like functions, by
using the three classes \helpref{wxClient}{wxclient}, \helpref{wxServer}{wxserver} and
\rtfsp\helpref{wxConnection}{wxconnection}. These use DDE under Windows, and a simulation using
sockets under UNIX.

\section{The wxWindows resource system}\label{resourceformats}

From version 1.61, wxWindows has an optional {\it resource file} facility,
which allows separation of dialog, menu, bitmap and icon specifications
from the application code.

It is similar in principle to the Windows resource file (whose ASCII form is
suffixed .RC and whose binary form is suffixed .RES). The wxWindows resource
file is currently ASCII-only, suffixed .WXR. Note that under Windows,
the .WXR file does not {\it replace} the native Windows resource file,
it merely supplements it. There is no existing native resource format in X
(except for the defaults file, which has limited expressive power).

Using wxWindows resources for panels and dialogs has an effect on how
you deal with panel item callbacks: you can't specify a callback function in
a resource file, so how do you achieve the same effect as with programmatic
panel construction? The solution is similar to that adopted by Windows, which
is to use the {\it parent} panel or dialog to intercept user events.

From 1.61, wxWindows routes panel item events that do not have a callback
to the \helpref{OnCommand}{wxpaneloncommand} member of the panel (or dialog). So, to use
panel or dialog resources, you need to derive a new class and override the
default (empty) OnCommand member. The first argument is a reference
to a wxWindow, and the second is a reference to a wxCommandEvent. Check the
name of the panel item that's generating an event by using the \helpref{wxWindow::GetName}{wxwindowgetname}\rtfsp
function and a string comparison function such as \helpref{wxStringEq}{wxstringeq}.
You may need to cast the reference to an appropriate specific type to perform
some operations.

To obtain a pointer to a panel item when you only have the name (for example,
when you need to set a value of a text item from outside of the {\bf OnCommand} function),
use the function \helpref{wxFindWindowByName}{wxfindwindowbyname}.

For details of functions for manipulating resource files and loading
user interface elements, see \helpref{wxWindows resource functions}{resourcefuncs}.

\subsection{The format of a .WXR file}

A wxWindows resource file may look a little odd at first. It's C++
compatible, comprising mostly of static string variable declarations with
PrologIO syntax within the string.

Here's a sample .WXR file:

\begin{verbatim}
/*
 * wxWindows Resource File
 * Written by wxBuilder
 *
 */

#include "noname.ids"

static char *aiai_resource = "bitmap(name = 'aiai_resource',\
  bitmap = ['aiai', wxBITMAP_TYPE_BMP_RESOURCE, 'WINDOWS'],\
  bitmap = ['aiai.xpm', wxBITMAP_TYPE_XPM, 'X']).";

static char *menuBar11 = "menu(name = 'menuBar11',\
  menu = \
  [\
    ['&File', 1, '', \
      ['&Open File', 2, 'Open a file'],\
      ['&Save File', 3, 'Save a file'],\
      [],\
      ['E&xit', 4, 'Exit program']\
    ],\
    ['&Help', 5, '', \
      ['&About', 6, 'About this program']\
    ]\
  ]).";

static char *project_resource = "icon(name = 'project_resource',\
  icon = ['project', wxBITMAP_TYPE_ICO_RESOURCE, 'WINDOWS'],\
  icon = ['project_data', wxBITMAP_TYPE_XBM, 'X']).";

static char *panel3 = "dialog(name = 'panel3',\
  style = '',\
  title = 'untitled',\
  button_font = [14, 'wxSWISS', 'wxNORMAL', 'wxBOLD', 0],\
  label_font = [10, 'wxSWISS', 'wxNORMAL', 'wxNORMAL', 0],\
  x = 0, y = 37, width = 292, height = 164,\
  control = [wxButton, 'OK', '', 'button5', 23, 34, -1, -1, 'aiai_resource'],\
  control = [wxMessage, 'A Label', '', 'message7', 166, 61, -1, -1, 'aiai_resource'],\
  control = [wxText, 'Text', 'wxVERTICAL_LABEL', 'text8', 24, 110, -1, -1]).";
\end{verbatim}

As you can see, C++-style comments are allowed, and apparently include files
are supported too: but this is a special case, where the included file
is a file of defines shared by the C++ application code and resource file
to relate identifiers (such as FILE\_OPEN) to integers.

Each {\it resource object} is of standard PrologIO syntax, that is,
an object name such as {\bf dialog} or {\bf icon}, then an open
parenthesis, a list of comma-delimited attribute/value pairs, a closing
parenthesis, and a full stop. Backslashes are required to escape newlines,
for the benefit of C++ syntax. If double quotation marks are used to
delimit strings, they need to be escaped with backslash within a C++ string
(so it's easier to use single quotation marks instead).

\normalbox{{\it A note on PrologIO string syntax:} A string that begins with
an alphabetic character, and contains only alphanumeric characters,
hyphens and underscores, need not be quoted at all. Single quotes and double
quotes may be used to delimit more complex strings. In fact, single-quoted
and no-quoted strings are actually called {\it words}, but are treated
as strings for the purpose of the resource system.}

A resource file like this is typically included in the application main file,
as if it were a normal C++ file. This eliminates the need for a separate
resource file to be distributed alongside the executable. However, the
resource file can be dynamically loaded if desired (for example by a non-C++
language such as CLIPS, Prolog or Python).

Once included, the resources need to be `parsed' (interpreted), because
so far the data is just a number of static string variables. The function\rtfsp
{\bf ::wxResourceParseData} is called early on in initialization of the application
(usually in {\bf wxApp::OnInit}) with a variable as argument. This may need to be
called a number of times, one for each variable. However, more than one
resource `object' can be stored in one string variable at a time, so you can
get all your resources into one variable if you want to.

{\bf ::wxResourceParseData} parses the contents of the resource, ready for use
by functions such as {\bf ::wxResourceCreateBitmap} and {\bf wxPanel::LoadFromResource}.

If a wxWindows resource object (such as a bitmap resource) refers to a
C++ data structure, such as static XBM or XPM data, a further call ({\bf
::wxResourceRegisterBitmapData}) needs to be made on initialization to tell
wxWindows about this data. The wxWindows resource object will refer to a
string identifier, such as `project\_data' in the example file above.
This identifier will be looked up in a table to get the C++ static data
to use for the bitmap or icon.

In the C++ fragment below, the WXR resource file is included,
and appropriate resource initialization is carried out in {\bf OnInit}.
Note that at this stage, no actual wxWindows dialogs, menus, bitmaps or
icons are created; their `templates' are merely being set up for later
use.

\begin{verbatim}
/*
 * File:    noname.cc
 * Purpose: main application module, generated by wxBuilder.
 */

#include "wx.h"
#include "wx_help.h"
#include "noname.h"

// Includes the dialog, menu etc. resources
#include "noname.wxr"

// Includes XBM data
#include "project.xbm"

// Declare an instance of the application: allows the program to start
AppClass theApp;

// Called to initialize the program
wxFrame *AppClass::OnInit(void)
{
#ifdef wx_x
  wxResourceRegisterBitmapData("project_data", project_bits, project_width, project_height);
#endif
  wxResourceParseData(menuBar11);
  wxResourceParseData(aiai_resource);
  wxResourceParseData(project_resource);
  wxResourceParseData(panel3);
  ...
}
\end{verbatim}


\subsection{Dialog resource format}

A dialog resource object may be used for either panels or dialog boxes, and
consists of the following attributes. In the following, a {\it font specification}\rtfsp
is a list consisting of point size, family, style, weight, underlined, optional facename.

\begin{twocollist}\itemsep=0pt
\twocolitemruled{Attribute}{Value}
\twocolitem{name}{The name of the resource.}
\twocolitem{style}{Optional dialog box or panel window style.}
\twocolitem{title}{The title of the dialog box (unused if a panel).}.
\twocolitem{modal}{Whether modal: 1 if modal, 0 if modeless, absent if a panel resource.}
\twocolitem{button\_font}{The font used for control buttons: a list comprising point size (integer),
family (string), font style (string), font weight (string) and underlining (0 or 1).}
\twocolitem{label\_font}{The font used for control labels: a list comprising point size (integer),
family (string), font style (string), font weight (string) and underlining (0 or 1).}
\twocolitem{x}{The x position of the dialog or panel.}
\twocolitem{y}{The y position of the dialog or panel.}
\twocolitem{width}{The width of the dialog or panel.}
\twocolitem{height}{The height of the dialog or panel.}
\twocolitem{background\_colour}{The background colour of the dialog or panel. Only valid if the style includes wxUSER\_COLOURS.}
\twocolitem{label\_colour}{The default label colour for the children of the dialog or panel. Only valid if the style includes wxUSER\_COLOURS.}
\twocolitem{button\_colour}{The default button text colour for the children of the dialog or panel. Only valid if the style includes wxUSER\_COLOURS.}
\twocolitem{label\_font}{Font spec}
\twocolitem{button\_font}{Font spec}
\end{twocollist}

Then comes zero or more attributes named `control' for each control
(panel item) on the dialog or panel. The value is a list of further
elements. In the table below, the names in the first column correspond to
the first element of the value list, and the second column details the
remaining elements of the list.

\begin{twocollist}\itemsep=0pt
\twocolitemruled{Control}{Values}
\twocolitem{wxButton}{title (string), window style (string), name (string), x, y, width, height, button bitmap resource (optional string), button font spec}
\twocolitem{wxCheckBox}{title (string), window style (string), name (string), x, y, width, height, default value (optional integer, 1 or 0), label font spec}
\twocolitem{wxChoice}{title (string), window style (string), name (string), x, y, width, height, values (optional list of strings), label font spec, button font spec}
\twocolitem{wxComboBox}{title (string), window style (string), name (string), x, y, width, height, default text value, values (optional list of strings), label font spec, button font spec}
\twocolitem{wxGauge}{title (string), window style (string), name (string), x, y, width, height, value (optional integer), range (optional integer), label font spec, button font spec}
\twocolitem{wxGroupBox}{title (string), window style (string), name (string), x, y, width, height, label font spec}
\twocolitem{wxListBox}{title (string), window style (string), name (string), x, y, width, height, values (optional list of strings), multiple (optional string, wxSINGLE or wxMULTIPLE),
label font spec, button font spec}
\twocolitem{wxMessage}{title (string), window style (string), name (string), x, y, width, height, message bitmap resource (optional string), label font spec}
\twocolitem{wxMultiText}{title (string), window style (string), name (string), x, y, width, height, default value (optional string),
label font spec, button font spec}
\twocolitem{wxRadioBox}{title (string), window style (string), name (string), x, y, width, height, values (optional list of strings), number of rows or cols,
label font spec, button font spec}
\twocolitem{wxRadioButton}{title (string), window style (string), name (string), x, y, width, height, default value (optional integer, 1 or 0), label font spec}
\twocolitem{wxScrollBar}{title (string), window style (string), name (string), x, y, width, height, value (optional integer),
page length (optional integer), object length (optional integer), view length (optional integer)}
\twocolitem{wxSlider}{title (string), window style (string), name (string), x, y, width, height, value (optional integer), minimum (optional integer), maximum (optional integer),
label font spec, button font spec}
\twocolitem{wxText}{title (string), window style (string), name (string), x, y, width, height, default value (optional string),
label font spec, button font spec}
\end{twocollist}

\subsection{Menubar resource format}

A menubar resource object consists of the following attributes.

\begin{twocollist}\itemsep=0pt
\twocolitemruled{Attribute}{Value}
\twocolitem{name}{The name of the menubar resource.}
\twocolitem{menu}{A list containing all the menus, as detailed below.}
\end{twocollist}

The value of the {\bf menu} attribute is a list of menu item specifications, where each menu
item specification is itself a list comprising:

\begin{itemize}\itemsep=0pt
\item title (a string)
\item menu item identifier (a string or non-zero integer, see below)
\item help string (optional)
\item 0 or 1 for the `checkable' parameter (optional)
\item optionally, further menu item specifications if this item is a pulldown menu.
\end{itemize}

If the menu item specification is the empty list ([]), this is interpreted as a menu separator.

If further (optional) information is associated with each menu item in a future release of wxWindows,
it will be placed after the help string and before the optional pulldown menu specifications.

Note that the menu item identifier must be an integer if the resource is being
included as C++ code and then parsed on initialisation. Unfortunately,\rtfsp
\verb$#$define substitution is not performed inside strings, and
therefore the program cannot know the mapping. However, if the .WXR file
is being loaded dynamically, wxWindows will attempt to replace string
identifiers with \verb$#$defined integers, because it is able to parse
the included \verb$#$defines.

\subsection{Bitmap resource format}

A bitmap resource object consists of a name attribute, and one or more {\bf bitmap} attributes.
There can be more than one of these to allow specification of bitmaps that are optimum for the
platform and display.

\begin{itemize}\itemsep=0pt
\item Bitmap name or filename.
\item Type of bitmap; for example, wxBITMAP\_TYPE\_BMP\_RESOURCE. See class reference under {\bf wxBitmap} for
a full list).
\item Platform this bitmap is valid for; one of WINDOWS, X, MAC and ANY.
\item Number of colours (optional).
\item X resolution (optional).
\item Y resolution (optional).
\end{itemize}

\subsection{Icon resource format}

An icon resource object consists of a name attribute, and one or more {\bf icon} attributes.
There can be more than one of these to allow specification of icons that are optimum for the
platform and display.

\begin{itemize}\itemsep=0pt
\item Icon name or filename.
\item Type of icon; for example, wxBITMAP\_TYPE\_ICO\_RESOURCE. See class reference under {\bf wxBitmap} for
a full list).
\item Platform this bitmap is valid for; one of WINDOWS, X, MAC and ANY.
\item Number of colours (optional).
\item X resolution (optional).
\item Y resolution (optional).
\end{itemize}


\subsection{Resource format design issues}

The .WXR file format is a recent addition and subject to change.
The use of an ASCII resource file format may seem rather inefficient, but this
choice has a number of advantages:

\begin{itemize}\itemsep=0pt
\item Since it is C++ compatible, it can be included into an application's source code,
eliminating the problems associated with distributing a separate resource file
with the executable. However, it can also be loaded dynamically from a file, which will be required
for non-C++ programs that use wxWindows.
\item No extra binary file format and separate converter need be maintained for the wxWindows project
(although others are welcome to add the equivalent of the Windows `rc' resource
parser and a binary format).
\item It would be difficult to append a binary resource component onto an executable
in a portable way.
\item The file format is essentially the PrologIO object format, for which
a parser already exists, so parsing is easy. For those programs that use PrologIO
anyway, the size overhead of the parser is minimal.
\end{itemize}

The disadvantages of the approach include:

\begin{itemize}\itemsep=0pt
\item Parsing adds a small execution overhead to program initialization.
\item Under 16-bit Windows especially, global data is at a premium.
Using a .RC resource table for some wxWindows resource data may be a partial solution,
although .RC strings are limited to 255 characters.
\item Without a resource preprocessor, it is not possible to substitute integers
for identifiers (so menu identifiers have to be written as integers in the resource
object, in addition to providing \verb$#$defines for application code convenience).
\end{itemize}

\subsection{Compiling the resource system}

To enable the resource system, set {\bf USE\_WX\_RESOURCES} to 1 in wx\_setup.h.
If your wxWindows makefile supports it, set the same name in the makefile to 1.

You will also need to compile the PrologIO utility (not always the easiest
task): you will need YACC, and LEX (or FLEX). DOS versions of these are
available on the AIAI ftp site under /pub/wxwin/tools.

\section{Notes on using the reference}\label{referencenotes}

In the descriptions of the wxWindows classes and their member
functions, note that descriptions of inherited member functions are not
duplicated in derived classes unless their behaviour is different. So in
using a class such as wxCanvas, be aware that wxWindow functions may be
relevant.

Note also that arguments with default values may be omitted from a
function call, for brevity. Size and position arguments may usually be
given a value of -1 (the default), in which case wxWindows will choose a
suitable value.

From version 1.50 beta (j), string return values are allocated and
deallocated by wxWindows. Therefore, return values should always be
copied for long-term use, especially since the same buffer is often
used by wxWindows.

The member functions are given in alphabetical order except for
constructors and destructors which appear first.

\section{wxSplitterWindow overview}\label{wxsplitterwndoverview}

Class: \helpref{wxSplitterWindow}{wxsplitterwindow}

A wxSplitterWindow manages one or two subwindows, allowing the user to change the position
of a sash.

\subsection{Example}

The following fragment shows how to create a splitter window, creating two
subwindows and hiding one of them.

{\small
\begin{verbatim}
  splitter = new wxSplitterWindow(this, 0, 0, 400, 400, wxSP_3D);

  leftCanvas = new MyCanvas(splitter);
  leftCanvas->SetBackground(wxRED_BRUSH);
  leftCanvas->SetScrollbars(20, 20, 50, 50, 4, 4);

  rightCanvas = new MyCanvas(splitter);
  rightCanvas->SetBackground(wxCYAN_BRUSH);
  rightCanvas->SetScrollbars(20, 20, 50, 50, 4, 4);
  rightCanvas->Show(FALSE);

  splitter->Initialize(leftCanvas);

  // Set this to prevent unsplitting
//    splitter->SetMinimumPaneSize(20);
\end{verbatim}
}

The next fragment shows how the splitter window can be manipulated after creation.

{\small
\begin{verbatim}
  void MyFrame::OnMenuCommand(int id)
  {
    switch (id)
    {
    case SPLIT_VERTICAL :
        if ( splitter->IsSplit() )
            splitter->Unsplit();
        leftCanvas->Show(TRUE);
        rightCanvas->Show(TRUE);
        splitter->SplitVertically( leftCanvas, rightCanvas );
        break;
    case SPLIT_HORIZONTAL :
        if ( splitter->IsSplit() )
            splitter->Unsplit();
        leftCanvas->Show(TRUE);
        rightCanvas->Show(TRUE);
        splitter->SplitHorizontally( leftCanvas, rightCanvas );
        break;
    case SPLIT_UNSPLIT :
        if ( splitter->IsSplit() )
            splitter->Unsplit();
	break;
    case SPLIT_QUIT:
        this->Close(TRUE);
        break;
    default:
        break;
    }
  }
\end{verbatim}
}

