SCAN has a limited number of data types as compared to a language like PL/I.
This in general can make interfacing with system routines more difficult.
There is however, a datatype that can always be used, FILL.  A FILL is
an object that is between 0 and 65K bytes in length.  SCAN makes no
interpretation of the objects contents.  Thus it can be used to pass or
return the object to another language that does understand the type.
.skip 2

.literal
access_bit_name			FILL( 8*32 )

access_mode			FILL( 1 )

address				POINTER

address_range			RECORD
				start: POINTER,
				end:   POINTER,
				END RECORD

arg_list			RECORD
				count: INTEGER,
				arg1:  POINTER,          ! if by reference
				arg2:  INTEGER,          ! fi by value
				...                      ! depending on needs
				END RECORD

ast_procedure			POINTER

boolean				BOOLEAN
				note: SCAN boolean is just one byte

byte_signed			FILL( 1 )

byte_unsigned			FILL( 1 )

channel				FILL( 2 )

char_string			FIXED STRING( x )   where x is length

complex_number			FILL( x )	    where x is length

cond_value			INTEGER

context				INTEGER

date_time			FILL( 8 )

device_name			FIXED STRING( x )   where x is length

ef_cluster_name			FIXED STRING( x )   where x is length

ef_number			INTEGER

exit_handler_block		FILL( x )           where x is length

fab				** a fab is too complicated a structure
				   to include in this chart - much of it
				   can be described with a SCAN record,
				   however, it is much simpler and less
				   prone to error to access fabs from 
				   other languages that have the record
				   predefined

file_protection			FILL( 2 )

floating_point			FILL( x )           where x is length

function_code			INTEGER

io_status_block			FILL( 8 )

item_list_2			RECORD
				item1: FILL( 8 ),
				item2: FILL( 8 ),
				...
				terminator: INTEGER,
				END RECORD

item_list_3			RECORD
				item1: FILL( 12 ),
				item2: FILL( 12 ),
				...
				terminator: INTEGER,
				END RECORD

item_quota_list			RECORD
				item1: RECORD
				       type:  FILL( 1 ),
				       value: INTEGER,
				       END RECORD,
				item2: RECORD
				       type:  FILL( 1 ),
				       value: INTEGER,
				       END RECORD,
				...
				terminator: FILL( 1 ),
				END RECORD

lock_id				INTEGER

lock_status_block		RECORD
				status: FILL( 2 ),
				reserved: FILL( 2 ),
				lock_id: INTEGER,
				END RECORD

lock_value_block		FILL( 16 )

logical_name			FIXED STRING( x )    where x is length

longword_signed			INTEGER

longword_unsigned		INTEGER

mask_byte			FILL( 1 )

mask_longword			INTEGER

mask_quadword			RECORD
				first_half: INTEGER,
				second_half: INTEGER,
				END RECORD

mask_word			FILL( 2 )

null_arg			use * for argument

octaword_signed			FILL( 16 )

octaword_unsigned		FILL( 16 )

page_protection			INTEGER

procedure			POINTER

process_id			INTEGER

process_name			FIXED STRING( x )        where x is length

quadword_signed			FILL( 8 )

quadword_unsigned		FILL( 8 )

rights_holder			RECORD
				rights_id: INTEGER,
				bitmask:   INTEGER,
				END RECORD

rights_id			INTEGER

rab				** a rab is too complicated a structure
				   to include in this chart - much of it
				   can be described with a SCAN record,
				   however, it is much simpler and less
				   prone to error to access rabs from 
				   other languages that have the record
				   predefined

second_name			FILL( 8 )

section_name			FIXED STRING( x )       where x is length

system_access_id		FILL( 8 )

time_name			FIXED STRING( x )       where x is length

uic				INTEGER

user_arg			INTEGER

varying_arg			INTEGER

vector_byte_signed		FILL( x )		where x is length

vector_byte_unsigned		FILL( x )		where x is length

vector_longword_signed		FILL( 4*x )            where x is length

vector_longword_unsigned	FILL( 4*x )            where x is length

vector_quadword_signed		FILL( 8*x )            where x is length

vector_quadword_unsigned	FILL( 8*x )            where x is length

vector_word_signed		FILL( 2*x )            where x is length

vector_word_unsigned		FILL( 2*x )            where x is length

word_signed			FILL( 2 )

word_unsigned			FILL( 2 )

.end literal
